# Lean as a Theorem Prover


## Inequality Addition

Step 1
Putting the initial theorem we want to show in lean code and observing the final goal in the infoview.

::: {.inout}
::: {.inpt}
```lean
example (a b c d : ℝ) (h1: a < b) 
    (h2 : c ≤ d) : a + c < b + d := by
  
  **done::
```
:::

::: {.outpt}
```state
R: Type u_1
inst✝: Ring R
abcd: ℝ
h1: a < b
h2: c ≤ d
⊢ a + c < b + d
```
:::
:::


Step 2

::: {.inout}
::: {.inpt}
```lean
example (a b c d : ℝ) (h1: a < b) 
    (h2 : c ≤ d) : a + c < b + d := by
  by_cases h3 : c = d

  **done::
```
:::

::: {.outpt}
```state
R: Type u_1
inst✝: Ring R
abcd: ℝ
h1: a < b
h2: c ≤ d
h3: c = d
⊢ a + c < b + d
```
:::
:::

Step 3

::: {.inout}
::: {.inpt}
```lean
example (a b c d : ℝ) (h1: a < b) 
    (h2 : c ≤ d) : a + c < b + d := by
  by_cases h3 : c = d
  rw [h3]

  **done::
```
:::

::: {.outpt}
```state
R: Type u_1
inst✝: Ring R
abcd: ℝ
h1: a < b
h2: c ≤ d
h3: c = d
⊢ a + d < b + d
```
:::
:::

Step 4

::: {.inout}
::: {.inpt}
```lean
example (a b c d : ℝ) (h1: a < b) 
    (h2 : c ≤ d) : a + c < b + d := by
  by_cases h3 : c = d
  rw [h3]
  apply add_lt_add_right h1

  **done::
```
:::

::: {.outpt}
```state
R: Type u_1
inst✝: Ring R
abcd: ℝ
h1: a < b
h2: c ≤ d
h3: ¬c = d
⊢ a + c < b + d
```
:::
:::

Step 5

::: {.inout}
::: {.inpt}
```lean
example (a b c d : ℝ) (h1: a < b) 
    (h2 : c ≤ d) : a + c < b + d := by
  by_cases h3 : c = d
  rw [h3]
  apply add_lt_add_right h1
  push_neg at h3

  **done::
```
:::

::: {.outpt}
```state
R: Type u_1
inst✝: Ring R
abcd: ℝ
h1: a < b
h2: c ≤ d
h3: c ≠ d
⊢ a + c < b + d
```
:::
:::

Step 6a
We can see here that the lean infoview is now displaying my new hypothesis as the current goal.

::: {.inout}
::: {.inpt}
```lean
example (a b c d : ℝ) (h1: a < b) 
    (h2 : c ≤ d) : a + c < b + d := by
  by_cases h3 : c = d
  rw [h3]
  apply add_lt_add_right h1
  push_neg at h3
  have h4 : c < d := by

  **done::
```
:::

::: {.outpt}
```state
R: Type u_1
inst✝: Ring R
abcd: ℝ
h1: a < b
h2: c ≤ d
h3: c ≠ d
⊢ c < d
```
:::
:::

Step 6b

::: {.inout}
::: {.inpt}
```lean
example (a b c d : ℝ) (h1: a < b) 
    (h2 : c ≤ d) : a + c < b + d := by
  by_cases h3 : c = d
  rw [h3]
  apply add_lt_add_right h1
  push_neg at h3
  have h4 : c < d := by
    apply Ne.lt_of_le h3 h2

  **done::
```
:::

::: {.outpt}
```state
No goals
```
:::
:::

Step 7

::: {.inout}
::: {.inpt}
```lean
example (a b c d : ℝ) (h1: a < b) 
    (h2 : c ≤ d) : a + c < b + d := by
  by_cases h3 : c = d
  rw [h3]
  apply add_lt_add_right h1
  push_neg at h3
  have h4 : c < d := by
    apply Ne.lt_of_le h3 h2
  apply add_lt_add h1 h4
  done
```
:::

::: {.outpt}
```state
No goals
```
:::
:::





#### To prove a goal of the form `P → Q`:

1.  Assume `P` is true and prove `Q`.
2.  Assume `Q` is false and prove that `P` is false.



::: {.lftrt}
::: {.bef}
```state
>> ⋮
⊢ P → Q
```
:::

::: {.aft}
```state
>> ⋮
h : P
⊢ Q
```
:::
:::


::: {style="margin: 0% 20%"}
| `Q` | `¬Q` | `(Q` | `→` | `False)`|
|:----------:|:----------:|-:|:-:|:-|
| F | T | F | T | &nbsp;&nbsp;[&nbsp;]{.excl} F |
| T | F | T | F | &nbsp;&nbsp;[&nbsp;]{.excl} F |
:::


::: {.inout}
::: {.inpt}
```lean
theorem Example_3_2_4_v2 (P Q R : Prop)
    (h : P → (Q → R)) : ¬R → (P → ¬Q) := by
  assume h2 : ¬R
  assume h3 : P
  **done::
```
:::

::: {.outpt}
```state
P Q R : Prop
h : P → Q → R
h2 : ¬R
h3 : P
⊢ ¬Q
```
:::
:::


### Exercises

Fill in proofs of the following theorems.  All of them are based on exercises in *HTPI*.

::: {.numex arguments="1"}
```lean
theorem Exercise_3_2_1a (P Q R : Prop)
    (h1 : P → Q) (h2 : Q → R) : P → R := by
  
  **done::
```
:::

::: {.numex arguments="2"}
```lean
theorem Exercise_3_2_1b (P Q R : Prop)
    (h1 : ¬R → (P → ¬Q)) : P → (Q → R) := by
  
  **done::
```
:::

::: {.numex arguments="3"}
```lean
theorem Exercise_3_2_2a (P Q R : Prop)
    (h1 : P → Q) (h2 : R → ¬Q) : P → ¬R := by
  
  **done::
```
:::

::: {.numex arguments="4"}
```lean
theorem Exercise_3_2_2b (P Q : Prop)
    (h1 : P) : Q → ¬(Q → ¬P) := by
  
  **done::
```
:::

## 3.3. Proofs Involving Quantifiers


::: {.ind}
Let `x` stand for an arbitrary object of type `U` and prove `P x`.  If the letter `x` is already being used in the proof to stand for something, then you must choose an unused variable, say `y`, to stand for the arbitrary object, and prove `P y`.
:::

::: {style="margin: 0% 10%"}
| | `quant_neg` Tactic | |
|:--:|:--:|:--:|
| `¬∀ (x : U), P x` | is changed to | `∃ (x : U), ¬P x` |
| `¬∃ (x : U), P x` | is changed to | `∀ (x : U), ¬P x` |
| `∀ (x : U), P x` | is changed to | `¬∃ (x : U), ¬P x` |
| `∃ (x : U), P x` | is changed to | `¬∀ (x : U), ¬P x` |
:::

::: {.thm}
Suppose $B$ is a set and $\mathcal{F}$ is a family of sets.  If $\bigcup\mathcal{F} \subseteq B$ then $\mathcal{F} \subseteq \mathscr{P}(B)$.
:::
::: {.proof}
Suppose $\bigcup \mathcal{F} \subseteq B$.  Let $x$ be an arbitrary element of $\mathcal{F}$.  Let $y$ be an arbitrary element of $x$.  Since $y \in x$ and $x \in \mathcal{F}$, by the definition of $\bigcup \mathcal{F}$, $y \in \bigcup \mathcal{F}$.  But then since $\bigcup \mathcal{F} \subseteq B$, $y \in B$.  Since $y$ was an arbitrary element of $x$, we can conclude that $x \subseteq B$, so $x \in \mathscr{P}(B)$.  But $x$ was an arbitrary element of $\mathcal{F}$, so this shows that $\mathcal{F} \subseteq \mathscr{P}(B)$, as required. [&nbsp;□]{.excl}\qedhere
:::
::: {.nthm arguments="Theorem 3.4.7"}
For every integer $n$, $6 \mid n$ iff $2 \mid n$ and $3 \mid n$.
:::
::: {.proof}
Let $n$ be an arbitrary integer.

($\to$) Suppose $6 \mid n$.  Then we can choose an integer $k$ such that $6k=n$.  Therefore $n = 6k = 2(3k)$, so $2 \mid n$, and similarly $n = 6k = 3(2k)$, so $3 \mid n$.

($\leftarrow$) Suppose $2 \mid n$ and $3 \mid n$.  Then we can choose integers $j$ and $k$ such that $n = 2j$ and $n = 3k$.  Therefore $6(j-k) = 6j - 6k = 3(2j) - 2(3k) = 3n - 2n = n$, so $6 \mid n$. [&nbsp;□]{.excl}\qedhere
:::


::: {.mdsk}
:::

For the next exercise you will need the following definitions:

