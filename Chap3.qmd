# Lean as a Theorem Prover

## Differences From Paragraph Style Proofs

Despite the incredible power that lean could provide in the verification of mathematical proofs, this does pose some difficulties, namely the ease with which the aforementioned proofs can be written up. Typically, proofs are simply written up in a paragraph style, where the steps being taken and the theorems being applied are laid out in plain terms so that it can be easily understood by fellow mathematicians. There are often times when mathematicians will take things for granted or skip over steps that they think the reader will either already know to be fact or can easily reason out for themselves when writing out typical proofs. This lax approach for conveying information simply does not work when trying to communicate with technology, and a much more specific and methodical approach must be adopted in order to take advantage of the logical verification benefits. Thankfully, lean has a community working to create libraries of previously proven theorems that can be applied to speed up the writing and verification of future proofs. This thankfully means that all proofs do not need to be taken all the way back to basic axioms: Users can save time by avoiding proving adjacent theorems and instead focus only on the immediately relevant steps of their proof. 


## Inequality Addition

Step 1
Putting the initial theorem we want to show in lean code and observing the final goal in the infoview.

::: {.inout}
::: {.inpt}
```lean
example (a b c d : ℝ) (h1: a < b) 
    (h2 : c ≤ d) : a + c < b + d := by
  
  **done::
```
:::

::: {.outpt}
```state
R: Type u_1
inst✝: Ring R
abcd: ℝ
h1: a < b
h2: c ≤ d
⊢ a + c < b + d
```
:::
:::


Step 2

::: {.inout}
::: {.inpt}
```lean
example (a b c d : ℝ) (h1: a < b) 
    (h2 : c ≤ d) : a + c < b + d := by
  by_cases h3 : c = d

  **done::
```
:::

::: {.outpt}
```state
R: Type u_1
inst✝: Ring R
abcd: ℝ
h1: a < b
h2: c ≤ d
h3: c = d
⊢ a + c < b + d
```
:::
:::

Step 3

::: {.inout}
::: {.inpt}
```lean
example (a b c d : ℝ) (h1: a < b) 
    (h2 : c ≤ d) : a + c < b + d := by
  by_cases h3 : c = d
  rw [h3]

  **done::
```
:::

::: {.outpt}
```state
R: Type u_1
inst✝: Ring R
abcd: ℝ
h1: a < b
h2: c ≤ d
h3: c = d
⊢ a + d < b + d
```
:::
:::

Step 4

::: {.inout}
::: {.inpt}
```lean
example (a b c d : ℝ) (h1: a < b) 
    (h2 : c ≤ d) : a + c < b + d := by
  by_cases h3 : c = d
  rw [h3]
  apply add_lt_add_right h1

  **done::
```
:::

::: {.outpt}
```state
R: Type u_1
inst✝: Ring R
abcd: ℝ
h1: a < b
h2: c ≤ d
h3: ¬c = d
⊢ a + c < b + d
```
:::
:::

Step 5

::: {.inout}
::: {.inpt}
```lean
example (a b c d : ℝ) (h1: a < b) 
    (h2 : c ≤ d) : a + c < b + d := by
  by_cases h3 : c = d
  rw [h3]
  apply add_lt_add_right h1
  push_neg at h3

  **done::
```
:::

::: {.outpt}
```state
R: Type u_1
inst✝: Ring R
abcd: ℝ
h1: a < b
h2: c ≤ d
h3: c ≠ d
⊢ a + c < b + d
```
:::
:::

Step 6a
We can see here that the lean infoview is now displaying my new hypothesis as the current goal.

::: {.inout}
::: {.inpt}
```lean
example (a b c d : ℝ) (h1: a < b) 
    (h2 : c ≤ d) : a + c < b + d := by
  by_cases h3 : c = d
  rw [h3]
  apply add_lt_add_right h1
  push_neg at h3
  have h4 : c < d := by

  **done::
```
:::

::: {.outpt}
```state
R: Type u_1
inst✝: Ring R
abcd: ℝ
h1: a < b
h2: c ≤ d
h3: c ≠ d
⊢ c < d
```
:::
:::

Step 6b

::: {.inout}
::: {.inpt}
```lean
example (a b c d : ℝ) (h1: a < b) 
    (h2 : c ≤ d) : a + c < b + d := by
  by_cases h3 : c = d
  rw [h3]
  apply add_lt_add_right h1
  push_neg at h3
  have h4 : c < d := by
    apply Ne.lt_of_le h3 h2

  **done::
```
:::

::: {.outpt}
```state
No goals
```
:::
:::

Step 7

::: {.inout}
::: {.inpt}
```lean
example (a b c d : ℝ) (h1: a < b) 
    (h2 : c ≤ d) : a + c < b + d := by
  by_cases h3 : c = d
  rw [h3]
  apply add_lt_add_right h1
  push_neg at h3
  have h4 : c < d := by
    apply Ne.lt_of_le h3 h2
  apply add_lt_add h1 h4
  done
```
:::

::: {.outpt}
```state
No goals
```
:::
:::


## Absolute Convergence
I will now display how I used to lean to demonstrate that a sequence converges if and only if the absolute value of that sequence converges.

Laying out the goal

::: {.inout}
::: {.inpt}
```lean
example (s1 : ℕ → ℝ) : ConvergesTo s1 (0 : ℝ) ↔
    ConvergesTo (abs s1) (0 : ℝ) := by

  **done::
```
:::

::: {.outpt}
```state
s1: ℕ → ℝ
⊢ ConvergesTo s1 0 ↔ ConvergesTo |s1| 0
```
:::
:::

Step 1

::: {.inout}
::: {.inpt}
```lean
example (s1 : ℕ → ℝ) : ConvergesTo s1 (0 : ℝ) ↔
    ConvergesTo (abs s1) (0 : ℝ) := by
  rw [ConvergesTo]
  rw [ConvergesTo]

  **done::
```
:::

::: {.outpt}
```state
s1: ℕ → ℝ
⊢ (∀ (ε : ℝ), ε > 0 → ∃ N, ∀ (n : ℕ), n ≥ N → |s1 n - 0| < ε) ↔
  ∀ (ε : ℝ), ε > 0 → ∃ N, ∀ (n : ℕ), n ≥ N → |abs s1 n - 0| < ε
```
:::
:::

Step 2

::: {.inout}
::: {.inpt}
```lean
example (s1 : ℕ → ℝ) : ConvergesTo s1 (0 : ℝ) ↔
    ConvergesTo (abs s1) (0 : ℝ) := by
  rw [ConvergesTo]
  rw [ConvergesTo]
  have h3 (x : ℕ) : |s1 x| = |abs s1 x| := by
    
    done

  **done::
```
:::

::: {.outpt}
```state
s1: ℕ → ℝ
x: ℕ
⊢ |s1 x| = |abs s1 x|
```
:::
:::

Step 3

::: {.inout}
::: {.inpt}
```lean
example (s1 : ℕ → ℝ) : ConvergesTo s1 (0 : ℝ) ↔
    ConvergesTo (abs s1) (0 : ℝ) := by
  rw [ConvergesTo]
  rw [ConvergesTo]
  have h3 (x : ℕ) : |s1 x| = |abs s1 x| := by
    simp [abs]
    done

  **done::
```
:::

::: {.outpt}
```state
s1: ℕ → ℝ
h3: ∀ (x : ℕ), |s1 x| = |abs s1 x|
⊢ (∀ (ε : ℝ), ε > 0 → ∃ N, ∀ (n : ℕ), n ≥ N → |s1 n - 0| < ε) ↔
  ∀ (ε : ℝ), ε > 0 → ∃ N, ∀ (n : ℕ), n ≥ N → |abs s1 n - 0| < ε
```
:::
:::

Step 4

::: {.inout}
::: {.inpt}
```lean
example (s1 : ℕ → ℝ) : ConvergesTo s1 (0 : ℝ) ↔
    ConvergesTo (abs s1) (0 : ℝ) := by
  rw [ConvergesTo]
  rw [ConvergesTo]
  have h3 (x : ℕ) : |s1 x| = |abs s1 x| := by
    simp [abs]
    done
  apply Iff.intro
  · --Forwards

  · --Reverse

  **done::
```
:::

::: {.outpt}
```state
s1: ℕ → ℝ
h3: ∀ (x : ℕ), |s1 x| = |abs s1 x|
⊢ (∀ (ε : ℝ), ε > 0 → ∃ N, ∀ (n : ℕ), n ≥ N → |s1 n - 0| < ε) →
  ∀ (ε : ℝ), ε > 0 → ∃ N, ∀ (n : ℕ), n ≥ N → |abs s1 n - 0| < ε
```
:::
:::

Step 5

::: {.inout}
::: {.inpt}
```lean
example (s1 : ℕ → ℝ) : ConvergesTo s1 (0 : ℝ) ↔
    ConvergesTo (abs s1) (0 : ℝ) := by
  rw [ConvergesTo]
  rw [ConvergesTo]
  have h3 (x : ℕ) : |s1 x| = |abs s1 x| := by
    simp [abs]
    done
  apply Iff.intro
  · --Forwards
    intro h1

  · --Reverse

  **done::
```
:::

::: {.outpt}
```state
s1: ℕ → ℝ
h3: ∀ (x : ℕ), |s1 x| = |abs s1 x|
h1: ∀ (ε : ℝ), ε > 0 → ∃ N, ∀ (n : ℕ), n ≥ N → |s1 n - 0| < ε
⊢ ∀ (ε : ℝ), ε > 0 → ∃ N, ∀ (n : ℕ), n ≥ N → |abs s1 n - 0| < ε
```
:::
:::

Step 6

::: {.inout}
::: {.inpt}
```lean
example (s1 : ℕ → ℝ) : ConvergesTo s1 (0 : ℝ) ↔
    ConvergesTo (abs s1) (0 : ℝ) := by
  rw [ConvergesTo]
  rw [ConvergesTo]
  have h3 (x : ℕ) : |s1 x| = |abs s1 x| := by
    simp [abs]
    done
  apply Iff.intro
  · --Forwards
    intro h1
    simp

  · --Reverse

  **done::
```
:::

::: {.outpt}
```state
s1: ℕ → ℝ
h3: ∀ (x : ℕ), |s1 x| = |abs s1 x|
h1: ∀ (ε : ℝ), ε > 0 → ∃ N, ∀ (n : ℕ), n ≥ N → |s1 n - 0| < ε
⊢ ∀ (ε : ℝ), 0 < ε → ∃ N, ∀ (n : ℕ), N ≤ n → |abs s1 n| < ε
```
:::
:::

Step 7

::: {.inout}
::: {.inpt}
```lean
example (s1 : ℕ → ℝ) : ConvergesTo s1 (0 : ℝ) ↔
    ConvergesTo (abs s1) (0 : ℝ) := by
  rw [ConvergesTo]
  rw [ConvergesTo]
  have h3 (x : ℕ) : |s1 x| = |abs s1 x| := by
    simp [abs]
    done
  apply Iff.intro
  · --Forwards
    intro h1
    simp
    simp at h1

  · --Reverse

  **done::
```
:::

::: {.outpt}
```state
s1: ℕ → ℝ
h3: ∀ (x : ℕ), |s1 x| = |abs s1 x|
h1: ∀ (ε : ℝ), 0 < ε → ∃ N, ∀ (n : ℕ), N ≤ n → |s1 n| < ε
⊢ ∀ (ε : ℝ), 0 < ε → ∃ N, ∀ (n : ℕ), N ≤ n → |abs s1 n| < ε
```
:::
:::

Step 8

::: {.inout}
::: {.inpt}
```lean
example (s1 : ℕ → ℝ) : ConvergesTo s1 (0 : ℝ) ↔
    ConvergesTo (abs s1) (0 : ℝ) := by
  rw [ConvergesTo]
  rw [ConvergesTo]
  have h3 (x : ℕ) : |s1 x| = |abs s1 x| := by
    simp [abs]
    done
  apply Iff.intro
  · --Forwards
    intro h1
    simp
    simp at h1
    simp [← h3]

  · --Reverse

  **done::
```
:::

::: {.outpt}
```state
s1: ℕ → ℝ
h3: ∀ (x : ℕ), |s1 x| = |abs s1 x|
h1: ∀ (ε : ℝ), 0 < ε → ∃ N, ∀ (n : ℕ), N ≤ n → |s1 n| < ε
⊢ ∀ (ε : ℝ), 0 < ε → ∃ N, ∀ (n : ℕ), N ≤ n → |s1 n| < ε
```
:::
:::

Step 9

::: {.inout}
::: {.inpt}
```lean
example (s1 : ℕ → ℝ) : ConvergesTo s1 (0 : ℝ) ↔
    ConvergesTo (abs s1) (0 : ℝ) := by
  rw [ConvergesTo]
  rw [ConvergesTo]
  have h3 (x : ℕ) : |s1 x| = |abs s1 x| := by
    simp [abs]
    done
  apply Iff.intro
  · --Forwards
    intro h1
    simp
    simp at h1
    simp [← h3]
    apply h1
  · --Reverse

  **done::
```
:::

::: {.outpt}
```state
s1: ℕ → ℝ
h3: ∀ (x : ℕ), |s1 x| = |abs s1 x|
⊢ (∀ (ε : ℝ), ε > 0 → ∃ N, ∀ (n : ℕ), n ≥ N → |abs s1 n - 0| < ε) →
  ∀ (ε : ℝ), ε > 0 → ∃ N, ∀ (n : ℕ), n ≥ N → |s1 n - 0| < ε
```
:::
:::

Step 10

::: {.inout}
::: {.inpt}
```lean
example (s1 : ℕ → ℝ) : ConvergesTo s1 (0 : ℝ) ↔
    ConvergesTo (abs s1) (0 : ℝ) := by
  rw [ConvergesTo]
  rw [ConvergesTo]
  have h3 (x : ℕ) : |s1 x| = |abs s1 x| := by
    simp [abs]
    done
  apply Iff.intro
  · --Forwards
    intro h1
    simp
    simp at h1
    simp [← h3]
    apply h1
  · --Reverse
    intro h1
    simp
    simp at h1
    simp_rw [h3]

  **done::
```
:::

::: {.outpt}
```state
s1: ℕ → ℝ
h3: ∀ (x : ℕ), |s1 x| = |abs s1 x|
h1: ∀ (ε : ℝ), 0 < ε → ∃ N, ∀ (n : ℕ), N ≤ n → |abs s1 n| < ε
⊢ ∀ (ε : ℝ), 0 < ε → ∃ N, ∀ (n : ℕ), N ≤ n → |abs s1 n| < ε
```
:::
:::

Step 11

::: {.inout}
::: {.inpt}
```lean
example (s1 : ℕ → ℝ) : ConvergesTo s1 (0 : ℝ) ↔
    ConvergesTo (abs s1) (0 : ℝ) := by
  rw [ConvergesTo]
  rw [ConvergesTo]
  have h3 (x : ℕ) : |s1 x| = |abs s1 x| := by
    simp [abs]
    done
  apply Iff.intro
  · --Forwards
    intro h1
    simp
    simp at h1
    simp [← h3]
    apply h1
  · --Reverse
    intro h1
    simp
    simp at h1
    simp_rw [h3]
    apply h1
  done
```
:::

::: {.outpt}
```state
No goals
```
:::
:::





## Perhaps a Third Great Example??






#### To prove a goal of the form `P → Q`:

1.  Assume `P` is true and prove `Q`.
2.  Assume `Q` is false and prove that `P` is false.



::: {.lftrt}
::: {.bef}
```state
>> ⋮
⊢ P → Q
```
:::

::: {.aft}
```state
>> ⋮
h : P
⊢ Q
```
:::
:::


::: {style="margin: 0% 20%"}
| `Q` | `¬Q` | `(Q` | `→` | `False)`|
|:----------:|:----------:|-:|:-:|:-|
| F | T | F | T | &nbsp;&nbsp;[&nbsp;]{.excl} F |
| T | F | T | F | &nbsp;&nbsp;[&nbsp;]{.excl} F |
:::


::: {.inout}
::: {.inpt}
```lean
theorem Example_3_2_4_v2 (P Q R : Prop)
    (h : P → (Q → R)) : ¬R → (P → ¬Q) := by
  assume h2 : ¬R
  assume h3 : P
  **done::
```
:::

::: {.outpt}
```state
P Q R : Prop
h : P → Q → R
h2 : ¬R
h3 : P
⊢ ¬Q
```
:::
:::


### Exercises

Fill in proofs of the following theorems.  All of them are based on exercises in *HTPI*.

::: {.numex arguments="1"}
```lean
theorem Exercise_3_2_1a (P Q R : Prop)
    (h1 : P → Q) (h2 : Q → R) : P → R := by
  
  **done::
```
:::

::: {.numex arguments="2"}
```lean
theorem Exercise_3_2_1b (P Q R : Prop)
    (h1 : ¬R → (P → ¬Q)) : P → (Q → R) := by
  
  **done::
```
:::

::: {.numex arguments="3"}
```lean
theorem Exercise_3_2_2a (P Q R : Prop)
    (h1 : P → Q) (h2 : R → ¬Q) : P → ¬R := by
  
  **done::
```
:::

::: {.numex arguments="4"}
```lean
theorem Exercise_3_2_2b (P Q : Prop)
    (h1 : P) : Q → ¬(Q → ¬P) := by
  
  **done::
```
:::

## 3.3. Proofs Involving Quantifiers


::: {.ind}
Let `x` stand for an arbitrary object of type `U` and prove `P x`.  If the letter `x` is already being used in the proof to stand for something, then you must choose an unused variable, say `y`, to stand for the arbitrary object, and prove `P y`.
:::

::: {style="margin: 0% 10%"}
| | `quant_neg` Tactic | |
|:--:|:--:|:--:|
| `¬∀ (x : U), P x` | is changed to | `∃ (x : U), ¬P x` |
| `¬∃ (x : U), P x` | is changed to | `∀ (x : U), ¬P x` |
| `∀ (x : U), P x` | is changed to | `¬∃ (x : U), ¬P x` |
| `∃ (x : U), P x` | is changed to | `¬∀ (x : U), ¬P x` |
:::

::: {.thm}
Suppose $B$ is a set and $\mathcal{F}$ is a family of sets.  If $\bigcup\mathcal{F} \subseteq B$ then $\mathcal{F} \subseteq \mathscr{P}(B)$.
:::
::: {.proof}
Suppose $\bigcup \mathcal{F} \subseteq B$.  Let $x$ be an arbitrary element of $\mathcal{F}$.  Let $y$ be an arbitrary element of $x$.  Since $y \in x$ and $x \in \mathcal{F}$, by the definition of $\bigcup \mathcal{F}$, $y \in \bigcup \mathcal{F}$.  But then since $\bigcup \mathcal{F} \subseteq B$, $y \in B$.  Since $y$ was an arbitrary element of $x$, we can conclude that $x \subseteq B$, so $x \in \mathscr{P}(B)$.  But $x$ was an arbitrary element of $\mathcal{F}$, so this shows that $\mathcal{F} \subseteq \mathscr{P}(B)$, as required. [&nbsp;□]{.excl}\qedhere
:::
::: {.nthm arguments="Theorem 3.4.7"}
For every integer $n$, $6 \mid n$ iff $2 \mid n$ and $3 \mid n$.
:::
::: {.proof}
Let $n$ be an arbitrary integer.

($\to$) Suppose $6 \mid n$.  Then we can choose an integer $k$ such that $6k=n$.  Therefore $n = 6k = 2(3k)$, so $2 \mid n$, and similarly $n = 6k = 3(2k)$, so $3 \mid n$.

($\leftarrow$) Suppose $2 \mid n$ and $3 \mid n$.  Then we can choose integers $j$ and $k$ such that $n = 2j$ and $n = 3k$.  Therefore $6(j-k) = 6j - 6k = 3(2j) - 2(3k) = 3n - 2n = n$, so $6 \mid n$. [&nbsp;□]{.excl}\qedhere
:::


::: {.mdsk}
:::

For the next exercise you will need the following definitions:

