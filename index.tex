% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  letterpaper,
  DIV=11,
  numbers=noendperiod]{scrreprt}

\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else  
    % xetex/luatex font selection
  \setmonofont[]{JuliaMono}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\usepackage{soul}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\setcounter{secnumdepth}{0}
% Make \paragraph and \subparagraph free-standing
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{241,243,245}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.40,0.45,0.13}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.28,0.35,0.67}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.46,0.62}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.07,0.07,0.07}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

\usepackage{mathrsfs}
\usepackage{twemojis}
\usepackage{myunixode}
\usepackage[normalem]{ulem}
\usepackage{scrlayer-scrpage}
\automark{section}
\newcommand{\copyrightnotice}{\footnotesize\copyright\ 2023 Daniel J. Velleman.  Short excerpts from
\href{https://doi.org/10.1017/9781108539890}{\textit{How To Prove It}},\\
published by Cambridge Univ. Press, reprinted with permission.}
\newcommand{\longcopyrightnotice}{\footnotesize\copyright\ 2023 Daniel J. Velleman.\\
Short excerpts from Daniel J. Velleman,
\href{https://doi.org/10.1017/9781108539890}{\textit{How To Prove It: A Structured Approach, 3rd Edition}}\\
\copyright\ Daniel J. Velleman 2019, published by Cambridge University Press, reprinted with permission.}
\setkomafont{pagefoot}{\upshape}
\ifoot*{\longcopyrightnotice}
\cfoot*{}
\ofoot*{\pagemark}

\makeatletter
\def\redsquiggly{\bgroup \markoverwith{\textcolor{red}{\lower3.5\p@\hbox{\sixly \char58}}}\ULon}
\def\brownsquiggly{\bgroup \markoverwith{\textcolor[HTML]{B8860B}{\lower3.5\p@\hbox{\sixly \char58}}}\ULon}
\def\bluesquiggly{\bgroup \markoverwith{\textcolor[HTML]{1E90FF}{\lower3.5\p@\hbox{\sixly \char58}}}\ULon}
\makeatother

\renewcommand{\NormalTok}[1]{\textcolor[HTML]{000000}{#1}}
\renewcommand{\KeywordTok}[1]{\textcolor[HTML]{0000FF}{#1}}
\renewcommand{\SpecialCharTok}[1]{}
\renewcommand{\ErrorTok}[1]{\redsquiggly{#1}}
\renewcommand{\WarningTok}[1]{\redsquiggly{\textcolor[HTML]{0000FF}{#1}}}
\renewcommand{\StringTok}[1]{\textcolor[HTML]{A52A2A}{#1}}
\renewcommand{\CommentTok}[1]{\textcolor[HTML]{008000}{#1}}
\renewcommand{\InformationTok}[1]{\textcolor[HTML]{D2691E}{\textbf{#1}}}
\renewcommand{\RegionMarkerTok}[1]{▼\:\textcolor[HTML]{008000}{\textbf{#1}}}
\renewcommand{\SpecialStringTok}[1]{\textcolor[HTML]{4682B4}{\textbf{#1}}}
\renewcommand{\ConstantTok}[1]{\textcolor[HTML]{DC143C}{#1}}
\renewcommand{\AnnotationTok}[1]{\brownsquiggly{#1}}
\renewcommand{\AlertTok}[1]{\brownsquiggly{\textcolor[HTML]{0000FF}{#1}}}
\renewcommand{\OtherTok}[1]{\bluesquiggly{#1}}
\renewcommand{\DocumentationTok}[1]{\bluesquiggly{\textcolor[HTML]{0000FF}{#1}}}

\newenvironment{ind}
	{\begin{list}{}{\setlength{\leftmargin}{1em}}\item\relax}
	{\end{list}}

%redefines Shaded so it can't break
\newcommand{\nobreakShaded}{\renewenvironment{Shaded}
	{\begin{tcolorbox}[frame hidden, enhanced, interior hidden, boxrule=0pt,
		borderline west={3pt}{0pt}{shadecolor}, sharp corners]}
	{\end{tcolorbox}}}

%Make end of environment ignore pars that come after it
\def\useignorespacesandallpars#1\ignorespaces\fi{%
#1\fi\ignorespacesandallpars}

\makeatletter
\def\ignorespacesandallpars{%
  \@ifnextchar\par
    {\expandafter\ignorespacesandallpars\@gobble}%
    {}%
}
\makeatother

\newenvironment{inpt}
	{\nobreakShaded\noindent\begin{minipage}[t]{0.63\textwidth}
		\uline{Lean File}}
	{\end{minipage}\hfill\useignorespacesandallpars}

\newenvironment{outpt}
	{\nobreakShaded\begin{minipage}[t]{0.32\textwidth}
		\uline{Tactic State in Infoview}}
	{\end{minipage}}

\newenvironment{bef}
	{\nobreakShaded\noindent\begin{minipage}[t]{0.475\textwidth}
		\uline{Tactic State Before Using Strategy}}
	{\end{minipage}\hfill\useignorespacesandallpars}

\newenvironment{aft}
	{\nobreakShaded\begin{minipage}[t]{0.475\textwidth}
		\uline{Tactic State After Using Strategy}}
	{\end{minipage}}

\newenvironment{numex}[1]
	{\begin{minipage}[t]{0.04\textwidth}\vspace{8pt}{#1}.
		\end{minipage}\nobreakShaded\begin{minipage}[t]{0.96\textwidth}\vspace{0pt}}
	{\end{minipage}}

\newenvironment{mdsk}
	{\medskip}
	{}

\newenvironment{absnobreak}
  {\par\nobreak\vfil\penalty0\vfilneg
   \vtop\bgroup}
  {\par\xdef\tpd{\the\prevdepth}\egroup
   \prevdepth=\tpd}

\newcommand{\excl}[1]{}
\newcommand{\incl}[1]{#1}

\newcommand{\setmin}{\mathbin{\backslash}}
\newcommand{\symmdiff}{\bigtriangleup}

\pagenumbering{roman}  %So front matter uses roman numerals.  Switch back to arabic at beginning of preface.
\publishers{\longcopyrightnotice}
\KOMAoption{captions}{tableheading}
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{bookmark}{}{\usepackage{bookmark}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Table of contents}
\else
  \newcommand\contentsname{Table of contents}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{List of Figures}
\else
  \newcommand\listfigurename{List of Figures}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{List of Tables}
\else
  \newcommand\listtablename{List of Tables}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figure}
\else
  \newcommand\figurename{Figure}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Table}
\else
  \newcommand\tablename{Table}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{List of Listings}}
\usepackage{amsthm}
\theoremstyle{remark}
\AtBeginDocument{\renewcommand*{\proofname}{Proof}}
\newtheorem*{remark}{Remark}
\newtheorem*{solution}{Solution}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother
\makeatletter
\@ifpackageloaded{tcolorbox}{}{\usepackage[skins,breakable]{tcolorbox}}
\makeatother
\makeatletter
\@ifundefined{shadecolor}{\definecolor{shadecolor}{rgb}{.97, .97, .97}}
\makeatother
\makeatletter
\makeatother
\makeatletter
\makeatother
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same} % disable monospaced font for URLs
\hypersetup{
  pdftitle={Untitled Lean Thesis},
  pdfauthor={Logan Johnson},
  colorlinks=true,
  linkcolor={blue},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}

\title{Untitled Lean Thesis}
\author{Logan Johnson}
\date{Invalid Date}

\begin{document}
\maketitle
%Can't be in preamble because Quarto loads amsthm too late.
\theoremstyle{plain}
\newtheorem*{thm}{Theorem}
\newcommand{\thmnm}{Theorem}
\newtheorem*{namedthm}{\thmnm}
\theoremstyle{definition}
\newtheorem*{dfn}{Definition}
\newcommand{\defnm}{Definition}
\newtheorem*{nameddfn}{\defnm}

\newenvironment{nthm}[1]
  {\renewcommand{\thmnm}{#1}\begin{namedthm}}
  {\end{namedthm}}

\newenvironment{ndfn}[1]
  {\renewcommand{\defnm}{#1}\begin{nameddfn}}
  {\end{nameddfn}}

\newenvironment{npf}[1]
  {\begin{proof}[#1]}
  {\end{proof}}

% Usage:
% ::: {.thm} will create an unnumbered thm environment with title Theorem.
% ::: {.nthm arguments="Name of Theorem"} will create an unnumbered theorem whose title is Name of Theorem.

\let\oldgreater\textgreater
\renewcommand{\textgreater}{\null\oldgreater}   % To prevent => changing to double arrow

\ifdefined\Shaded\renewenvironment{Shaded}{\begin{tcolorbox}[sharp corners, interior hidden, boxrule=0pt, frame hidden, breakable, borderline west={3pt}{0pt}{shadecolor}, enhanced]}{\end{tcolorbox}}\fi

\renewcommand*\contentsname{Table of contents}
{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{1}
\tableofcontents
}
\bookmarksetup{startatroot}

\hypertarget{preface}{%
\chapter*{Preface}\label{preface}}
\addcontentsline{toc}{chapter}{Preface}

\markboth{Preface}{Preface}

\pagenumbering{arabic}
\markdouble{Preface}

I will not do my homework today.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 14
\end{verbatim}

Hello World

\hypertarget{making-chapters}{%
\section*{Making Chapters}\label{making-chapters}}
\addcontentsline{toc}{section}{Making Chapters}

\markright{Making Chapters}

I am using this section to figure out how to incorporate a table of
contents and different sections/chapters of the paper. This should prove
useful in the final thesis and allow readers to quickly jump to
important or interesting sections.

\hypertarget{incorporating-some-code}{%
\section*{Incorporating Some Code}\label{incorporating-some-code}}
\addcontentsline{toc}{section}{Incorporating Some Code}

\markright{Incorporating Some Code}

I will also be able to use some LaTeX equations within the document
which could halp to make the paper look quite nice.

If \(a < b\) and \(c \le d\), prove that \(a + c \le b + d\). It just so
happens that I was able to prove this using lean!

\begin{verbatim}
example (a b c d : ℝ) (h1: a < b) (h2 : c ≤ d) : a + c < b + d := by
  by_cases h3 : c = d
  rw [h3]
  apply add_lt_add_right h1
  push_neg at h3
  have h4 : c < d := by
    apply Ne.lt_of_le h3 h2
  apply add_lt_add h1 h4
  done
\end{verbatim}

Now to display the benefits of the lean infoview!

\hypertarget{showing-the-infoview-with-picture-sequences}{%
\section*{Showing the Infoview with Picture
Sequences}\label{showing-the-infoview-with-picture-sequences}}
\addcontentsline{toc}{section}{Showing the Infoview with Picture
Sequences}

\markright{Showing the Infoview with Picture Sequences}

Not going to do this now as I think the columns are far superior.

\hypertarget{showing-infoview-with-columns}{%
\section*{Showing Infoview with
Columns}\label{showing-infoview-with-columns}}
\addcontentsline{toc}{section}{Showing Infoview with Columns}

\markright{Showing Infoview with Columns}

\ul{Lean File}

\begin{verbatim}
example (a b c d : ℝ) (h1: a < b) (h2 : c ≤ d) : a + c < b + d := by

  done
\end{verbatim}

\ul{Infoview}

\begin{verbatim}
R: Type u_1
inst✝: Ring R
abcd: ℝ
h1: a < b
h2: c ≤ d
⊢ a + c < b + d
\end{verbatim}

As we can clearly see, this is the first step of the code and it can now
be explained with great ease. Now onto the next step!

\ul{Lean File}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{example}\NormalTok{ (a b c d }\SpecialCharTok{:}\NormalTok{ ℝ) (h1}\SpecialCharTok{:}\NormalTok{ a }\SpecialCharTok{\textless{}}\NormalTok{ b) (h2 }\SpecialCharTok{:}\NormalTok{ c ≤ d) }\SpecialCharTok{:}\NormalTok{ a }\SpecialCharTok{+}\NormalTok{ c }\SpecialCharTok{\textless{}}\NormalTok{ b }\SpecialCharTok{+}\NormalTok{ d }\SpecialCharTok{:}\ErrorTok{=}\NormalTok{ by}
\NormalTok{  by\_cases h3 }\SpecialCharTok{:}\NormalTok{ c }\OtherTok{=}\NormalTok{ d}

\NormalTok{  done}
\end{Highlighting}
\end{Shaded}

\ul{Infoview}

\begin{verbatim}
case pos
R: Type u_1
inst✝: Ring R
abcd: ℝ
h1: a < b
h2: c ≤ d
h3: c = d
⊢ a + c < b + d
case neg
R: Type u_1
inst✝: Ring R
abcd: ℝ
h1: a < b
h2: c ≤ d
h3: ¬c = d
⊢ a + c < b + d
\end{verbatim}

We can see here that lean is smart enough to split our goal into two
different goals, where each one uses a different case by our assumption.

I believe that displaying the code in unevaluated R chunks could prove
useful as it looks nicer than just being a basic preformatted chunk and
it takes less work than doing css work or something.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_2\_4\_v2 (P Q R : }\KeywordTok{Prop}\NormalTok{)}
\NormalTok{    (h : P → (Q → R)) : ¬R → (P → ¬Q) := }\KeywordTok{by}
  \KeywordTok{assume}\NormalTok{ h2 : ¬R}
  \KeywordTok{assume}\NormalTok{ h3 : P}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{P Q R }\NormalTok{: Prop}
\InformationTok{h }\NormalTok{: P → Q → R}
\InformationTok{h2 }\NormalTok{: ¬R}
\InformationTok{h3 }\NormalTok{: P}
\NormalTok{⊢ ¬Q}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{about-this-book}{%
\section*{About This Book}\label{about-this-book}}
\addcontentsline{toc}{section}{About This Book}

\markright{About This Book}

This book is intended to accompany my book
\href{https://doi.org/10.1017/9781108539890}{\emph{How To Prove It: A
Structured Approach, 3rd edition}} (henceforth called \emph{HTPI}),
which is published by Cambridge University Press. Although this book is
self-contained, we will sometimes have occasion to refer to passages in
\emph{HTPI}, so this book will be easiest to understand if you have a
copy of \emph{HTPI} available to you.

\emph{HTPI} explains a systematic approach to constructing mathematical
proofs. The purpose of this book is to show you how to use a computer
software package called \emph{Lean} to help you master the techniques
presented in \emph{HTPI}. Lean is free software that is available for
Windows, MacOS, and Unix computers. To get the most out of this book,
you will need to download and install Lean on your computer. We will
explain how to do that below.

The chapters and sections of this book are numbered to match the
sections of \emph{HTPI} to which they correspond. The first two chapters
of \emph{HTPI} cover preliminary topics in elementary logic and set
theory that are needed to understand the proof techniques presented in
later chapters. We assume that you are already familiar with that
material (if not, go read those chapters in \emph{HTPI}!), so Chapters 1
and 2 of this book will just briefly summarize the most important
points. Those chapters are followed by an introduction to Lean that
explains the basics of using Lean to write proofs. The presentation of
proof techniques in \emph{HTPI} begins in earnest in Chapter 3, so that
is where we will begin to discuss how Lean can be used to master those
techniques.

If you are reading this book online, then at the end of the title in the
left margin you will find an icon that is a link to a pdf version of the
book. Below that is a search box, which you can use to search for any
word or phrase anywhere in the book. Below the search box is a list of
the chapters of the book. Click on any chapter to go to that chapter.
Within each chapter, a table of contents in the right margin lists the
sections in that chapter. Again, you can go to any section by clicking
on it. At the end of each chapter there are links to take you to the
next or previous chapter.

\hypertarget{about-lean}{%
\section*{About Lean}\label{about-lean}}
\addcontentsline{toc}{section}{About Lean}

\markright{About Lean}

\href{https://leanprover.github.io}{Lean} is a kind of software package
called a \emph{proof assistant}. What that means is that Lean can help
you to write proofs. As we will see over the course of this book, there
are several ways in which Lean can be helpful. First of all, if you type
a proof into Lean, then Lean can check the correctness of the proof and
point out errors. As you are typing a proof into Lean, it will keep
track of what has been accomplished so far in the proof and what remains
to be done to finish the proof, and it will display that information for
you. That can keep you moving in the right direction as you are figuring
out a proof. And sometimes Lean can fill in small details of the proof
for you.

Of course, to make this possible, you must type your proof in a format
that Lean understands. Much of this book will be taken up with
explaining how to write a proof so that Lean will understand it.

\hypertarget{installing-lean}{%
\section*{Installing Lean}\label{installing-lean}}
\addcontentsline{toc}{section}{Installing Lean}

\markright{Installing Lean}

We will be using Visual Studio Code to run Lean, so you will need to
install VS Code first. VS Code is free and can be downloaded
\href{https://code.visualstudio.com}{here}.

You will also need the Lean package that accompanies this book, which
can be downloaded from
\url{https://github.com/djvelleman/HTPILeanPackage}. After following the
link, click on the green ``Code'' button and, in the pop-up menu, select
``Download ZIP''. Open the downloaded zip file to create a folder
containing the HTPI Lean package. You can put this folder wherever you
want on your computer.

Now open VS Code. You should see a window that looks something like
this:

\includegraphics{Images/VSCodeStart.png}

Click on the \emph{Extensions} icon on the left side of the window,
which is circled in red in the image above. That will bring up a list of
available extensions:

\includegraphics{Images/FindExtension.png}

In the \emph{Search Extensions in Marketplace} field, type ``lean4''. VS
Code should find the Lean 4 extension and display it:

\includegraphics{Images/InstallExtension.png}

Click on ``Install'' to install the Lean 4 extension.

Next, in VS Code, select ``Open Folder \ldots{}'' from the File menu and
open the folder containing the HTPI Lean package that you downloaded
earlier. Under the heading ``Explorer'' on the left side of the window,
you should see a list of the files in the package. (If you don't see the
list, try clicking on the \emph{Explorer} icon, circled in red below.)

\includegraphics{Images/OpenPackage.png}

Click on the file ``Blank.lean'' in the file list. You should see a
warning that VS Code failed to start the `lean' language server:

\begin{figure}

{\centering \includegraphics{Images/Install-elan.png}

}

\end{figure}

Click on the ``Install Lean using Elan'' button, and the Lean server
should be installed. Then Lean should ``build'' the HTPI Lean package.
This may take a while, but it only has to be done once. If anything goes
wrong, try quitting VS Code and restarting. Eventually your window
should look like this:

\includegraphics{Images/Ready.png}

If you don't see the Infoview pane on the right side of the window,
click on the icon circled in red in the image above, and the Infoview
pane should appear.

Your installation is now complete.

\hypertarget{about-the-htpi-lean-package}{%
\section*{About the HTPI Lean
Package}\label{about-the-htpi-lean-package}}
\addcontentsline{toc}{section}{About the HTPI Lean Package}

\markright{About the HTPI Lean Package}

For each chapter, starting with ``Introduction to Lean,'' the package
has a file containing all Lean definitions and theorems from that
chapter. There are also files containing all the exercises. In the
exercise file for a chapter, all definitions and theorems from that
chapter and all earlier chapters are available for use in solving the
exercises.

The chapter files are inside the folder ``HTPILib''. There is also one
other file in that folder. All of these files are needed to make the
package work. \emph{Do not edit the files in the HTPILib folder}, or you
will need to re-download the package.

\hypertarget{license}{%
\section*{License}\label{license}}
\addcontentsline{toc}{section}{License}

\markright{License}

This book is licensed under a
\href{http://creativecommons.org/licenses/by-sa/4.0/}{Creative Commons
Attribution-ShareAlike 4.0 International License}. This license allows
you to share or adapt the book. In any adaptation, you must identify
Daniel J. Velleman as the author, and you must also acknowledge that
excerpts from \emph{How To Prove It, 3rd edition}, copyright Daniel J.
Velleman 2019, published by Cambridge University Press, are reprinted
with the permission of Cambridge University Press. Each such excerpt is
identified in this book with a parenthetical note ``(HTPI p.~\ldots)''
specifying the page of \emph{How To Prove It, 3rd edition} from which
the excerpt is taken. For further details, see the text of the
\href{https://creativecommons.org/licenses/by-sa/4.0/legalcode}{license}.

\hypertarget{acknowledgments}{%
\section*{Acknowledgments}\label{acknowledgments}}
\addcontentsline{toc}{section}{Acknowledgments}

\markright{Acknowledgments}

A number of people have provided advice, encouragement, and feedback
about this project. In particular, I would like to thank Jeremy Avigad,
Clayton Cafiero, François Dorais, Charles Hoskinson, Heather Macbeth,
Pietro Monticone, and Ketil Wright.

\bookmarksetup{startatroot}

\hypertarget{real-analysis}{%
\chapter{Real Analysis}\label{real-analysis}}

\begin{longtable}[]{@{}cc@{}}
\toprule\noalign{}
Symbol & Meaning \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\(\neg\) & not \\
\(\wedge\) & and \\
\(\vee\) & or \\
\(\to\) & if \ldots{} then \\
\(\leftrightarrow\) & iff (that is, if and only if) \\
\end{longtable}

\hypertarget{prop-laws}{}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.3226}}
  >{\centering\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2258}}
  >{\centering\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2258}}
  >{\centering\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2258}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Name
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Equivalence
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
De Morgan's Laws & \(\neg (P \wedge Q)\) & is equivalent to &
\(\neg P \vee \neg Q\) \\
& \(\neg (P \vee Q)\) & is equivalent to & \(\neg P \wedge \neg Q\) \\
Double Negation Law & \(\neg\neg P\) & is equivalent to & \(P\) \\
Conditional Laws & \(P \to Q\) & is equivalent to & \(\neg P \vee Q\) \\
& \(P \to Q\) & is equivalent to & \(\neg(P \wedge \neg Q)\) \\
Contrapositive Law & \(P \to Q\) & is equivalent to &
\(\neg Q \to \neg P\) \\
\end{longtable}

\begin{quote}
\(A \cap B = \{x \mid x \in A \wedge x \in B\} = {}\) the
\emph{intersection} of \(A\) and \(B\),

\(A \cup B = \{x \mid x \in A \vee x \in B\} = {}\) the \emph{union} of
\(A\) and \(B\),

\(A \setmin B = \{x \mid x \in A \wedge x \notin B\} = {}\) the
\emph{difference} of \(A\) and \(B\),

\(A \symmdiff B = (A \setmin B) \cup (B \setmin A) = {}\) the
\emph{symmetric difference} of \(A\) and \(B\).

\end{quote}

\bookmarksetup{startatroot}

\hypertarget{functional-programming}{%
\chapter{Functional Programming}\label{functional-programming}}

\markdouble{2 Quantificational Logic}

Chapter 2 of \emph{How To Prove It} introduces two more symbols of
logic, the quantifiers \(\forall\) and \(\exists\). If \(P(x)\) is a
statement about an object \(x\), then

\begin{quote}
\(\forall x\,P(x)\) means ``for all \(x\), \(P(x)\),''

\end{quote}

and

\begin{quote}
\(\exists x\,P(x)\) means ``there exists some \(x\) such that
\(P(x)\).''

\end{quote}

Lean also uses these symbols, although we will see that quantified
statements are written slightly differently in Lean from the way they
are written in \emph{HTPI}. In the statement \(P(x)\), the variable
\(x\) is called a \emph{free variable}. But in \(\forall x\,P(x)\) or
\(\exists x\,P(x)\), it is a \emph{bound variable}; we say that the
quantifiers \(\forall\) and \(\exists\) \emph{bind} the variable.

Once again, there are logical equivalences involving these symbols that
will be useful to us later:

\begin{longtable}[]{@{}ccc@{}}
\toprule\noalign{}
& Quantifier Negation Laws & \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\(\neg \exists x\,P(x)\) & is equivalent to &
\(\forall x\,\neg P(x)\) \\
\(\neg \forall x\,P(x)\) & is equivalent to &
\(\exists x\,\neg P(x)\) \\
\end{longtable}

Chapter 2 of \emph{HTPI} also introduces some more advanced set theory
operations. For any set \(A\),

\begin{quote}
\(\mathscr{P}(A) = \{X \mid X \subseteq A\} = {}\) the \emph{power set}
of \(A\).

\end{quote}

Also, if \(\mathcal{F}\) is a family of sets---that is, a set whose
elements are sets---then

\begin{quote}
\(\bigcap \mathcal{F} = \{x \mid \forall A(A \in \mathcal{F} \to x \in A)\} = {}\)
the \emph{intersection} of the family \(\mathcal{F}\),

\(\bigcup \mathcal{F} = \{x \mid \exists A(A \in \mathcal{F} \wedge x \in A)\} = {}\)
the \emph{union} of the family \(\mathcal{F}\).

\end{quote}

Finally, Chapter 2 introduces the notation \(\exists ! x\,P(x)\) to mean
``there is exactly one \(x\) such that \(P(x).\)'' This can be thought
of as an abbreviation for
\(\exists x(P(x) \wedge \neg\exists y(P(y) \wedge y \ne x))\). By the
quantifier negation, De Morgan, and conditional laws, this is equivalent
to \(\exists x(P(x) \wedge \forall y(P(y) \to y = x))\).

\bookmarksetup{startatroot}

\hypertarget{lean-as-a-theorem-prover}{%
\chapter{Lean as a Theorem Prover}\label{lean-as-a-theorem-prover}}

\hypertarget{proofs-involving-negations-and-conditionals}{%
\section{3.1 \& 3.2. Proofs Involving Negations and
Conditionals}\label{proofs-involving-negations-and-conditionals}}

Sections 3.1 and 3.2 of \emph{How To Prove It} present strategies for
dealing with givens and goals involving negations and conditionals. We
restate those strategies here, and explain how to use them with Lean.

Section 3.1 gives two strategies for proving a goal of the form
\texttt{P\ →\ Q} (\emph{HTPI} pp.~95, 96):

\hypertarget{to-prove-a-goal-of-the-form-p-q}{%
\subsubsection{\texorpdfstring{To prove a goal of the form
\texttt{P\ →\ Q}:}{To prove a goal of the form P → Q:}}\label{to-prove-a-goal-of-the-form-p-q}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Assume \texttt{P} is true and prove \texttt{Q}.
\item
  Assume \texttt{Q} is false and prove that \texttt{P} is false.
\end{enumerate}

We've already seen how to carry out both of these strategies in Lean.
For the first strategy, use the \texttt{assume} tactic to introduce the
assumption \texttt{P} and assign an identifier to it; Lean will
automatically set \texttt{Q} as the goal. We can summarize the effect of
using this strategy by showing how the tactic state changes if you use
the tactic \texttt{assume\ h\ :\ P}:

\begin{bef}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{ ⋮}
\NormalTok{⊢ P → Q}
\end{Highlighting}
\end{Shaded}

\end{bef}

\begin{aft}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{ ⋮}
\InformationTok{h }\NormalTok{: P}
\NormalTok{⊢ Q}
\end{Highlighting}
\end{Shaded}

\end{aft}

The second strategy is justified by the contrapositive law. In Lean, you
can use the \texttt{contrapos} tactic to rewrite the goal as
\texttt{¬Q\ →\ ¬P} and then use the tactic \texttt{assume\ h\ :\ ¬Q}.
The net effect of these two tactics is:

\begin{bef}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{ ⋮}
\NormalTok{⊢ P → Q}
\end{Highlighting}
\end{Shaded}

\end{bef}

\begin{aft}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{ ⋮}
\InformationTok{h }\NormalTok{: ¬Q}
\NormalTok{⊢ ¬P}
\end{Highlighting}
\end{Shaded}

\end{aft}

Section 3.2 gives two strategies for using givens of the form
\texttt{P\ →\ Q}, with the second once again being a variation on the
first based on the contrapositive law (\emph{HTPI} p.~108):

\hypertarget{to-use-a-given-of-the-form-p-q}{%
\subsubsection{\texorpdfstring{To use a given of the form
\texttt{P\ →\ Q}:}{To use a given of the form P → Q:}}\label{to-use-a-given-of-the-form-p-q}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  If you are also given \texttt{P}, or you can prove that \texttt{P} is
  true, then you can use this given to conclude that \texttt{Q} is true.
\item
  If you are also given \texttt{¬Q}, or you can prove that \texttt{Q} is
  false, then you can use this given to conclude that \texttt{P} is
  false.
\end{enumerate}

The first strategy is the modus ponens rule of inference, and we saw in
the last chapter that if you have \texttt{h1\ :\ P\ →\ Q} and
\texttt{h2\ :\ P}, then \texttt{h1\ h2} is a (term-mode) proof of
\texttt{Q}; often we use this rule with the \texttt{have} or
\texttt{show} tactic. For the second strategy, if you have
\texttt{h1\ :\ P\ →\ Q} and \texttt{h2\ :\ ¬Q}, then the
\texttt{contrapos\ at\ h1} tactic will change \texttt{h1} to
\texttt{h1\ :\ ¬Q\ →\ ¬P}, and then \texttt{h1\ h2} will be a proof of
\texttt{¬P}.

All of the strategies listed above for working with conditional
statements as givens or goals were illustrated in examples in the last
chapter.

Section 3.2 of \emph{HTPI} offers two strategies for proving negative
goals (\emph{HTPI} pp.~101, 102):

\hypertarget{to-prove-a-goal-of-the-form-p}{%
\subsubsection{\texorpdfstring{To prove a goal of the form
\texttt{¬P}:}{To prove a goal of the form ¬P:}}\label{to-prove-a-goal-of-the-form-p}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Reexpress the goal in some other form.
\item
  Use proof by contradiction: assume \texttt{P} is true and try to
  deduce a contradiction.
\end{enumerate}

For the first strategy, the tactics \texttt{demorgan},
\texttt{conditional}, \texttt{double\_neg}, and \texttt{bicond\_neg} may
be useful, and we saw how those tactics work in the last chapter. But
how do you write a proof by contradiction in Lean? The answer is to use
a tactic called \texttt{by\_contra}. If the goal is \texttt{¬P}, then
the tactic \texttt{by\_contra\ h} will introduce the assumption
\texttt{h\ :\ P} and set the goal to be \texttt{False}, like this:

\begin{bef}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{ ⋮}
\NormalTok{⊢ ¬P}
\end{Highlighting}
\end{Shaded}

\end{bef}

\begin{aft}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{ ⋮}
\InformationTok{h }\NormalTok{: P}
\NormalTok{⊢ False}
\end{Highlighting}
\end{Shaded}

\end{aft}

In Lean, \texttt{False} represents a statement that is always
false---that is, a contradiction, as that term is defined in Section 1.2
of \emph{HTPI}. The \texttt{by\_contra} tactic can actually be used even
if the goal is not a negative statement. If the goal is a statement
\texttt{P} that is not a negative statement, then \texttt{by\_contra\ h}
will initiate a proof by contradiction by introducing the assumption
\texttt{h\ :\ ¬P} and setting the goal to be \texttt{False}.

You will usually complete a proof by contradiction by deducing two
contradictory statements---say, \texttt{h1\ :\ Q} and
\texttt{h2\ :\ ¬Q}. But how do you convince Lean that the proof is over?
You must be able to prove the goal \texttt{False} from the two givens
\texttt{h1} and \texttt{h2}. There are two ways to do this. The first is
based on the fact that Lean treats a statement of the form \texttt{¬Q}
as meaning the same thing as \texttt{Q\ →\ False}. This makes sense,
because these statements are logically equivalent, as shown by the
following truth table:

\begin{longtable}[]{@{}ccrcl@{}}
\toprule\noalign{}
\texttt{Q} & \texttt{¬Q} & \texttt{(Q} & \texttt{→} & \texttt{False)} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
F & T & F & T & ~~\excl{~} F \\
T & F & T & F & ~~\excl{~} F \\
\end{longtable}

Thinking of \texttt{h2\ :\ ¬Q} as meaning \texttt{h2\ :\ Q\ →\ False},
we can combine it with \texttt{h1\ :\ Q} using modus ponens to deduce
\texttt{False}. In other words, \texttt{h2\ h1} is a proof of
\texttt{False}.

But there is a second way of completing the proof that it is worthwhile
to know about. From contradictory statements \texttt{h1\ :\ Q} and
\texttt{h2\ :\ ¬Q} you can validly deduce \emph{any} statement. This
follows from the definition of a \emph{valid argument} in Section 1.1 of
\emph{HTPI}. According to that definition, you can validly infer a
conclusion \texttt{R} from premises \texttt{h1\ :\ Q} and
\texttt{h2\ :\ ¬Q} if the premises cannot both be true without the
conclusion also being true. In this case, that standard is met, for the
simple reason that the premises cannot both be true! (This gives part of
the answer to exercise 18 in Section 1.2 of \emph{HTPI}.) Thus, Lean has
a rule that allows you to prove any statement from contradictory
premises. If you have \texttt{h1\ :\ Q} and \texttt{h2\ :\ ¬Q}, then
Lean will recognize \texttt{absurd\ h1\ h2} as a (term-mode) proof of
\emph{any} statement.

To summarize, if you have \texttt{h1\ :\ Q} and \texttt{h2\ :\ ¬Q}, then
there are two ways to prove \texttt{False}. Lean will recognize
\texttt{h2\ h1} as a proof of \texttt{False}, and it will recognize
\texttt{absurd\ h1\ h2} as a proof of any statement, including
\texttt{False}. Notice the difference in the order in which \texttt{h1}
and \texttt{h2} are listed in these two proofs: In the first one, the
negative statement \texttt{h2} must come first, just as the conditional
statement must come first in an application of modus ponens. But in a
proof using \texttt{absurd}, the negative statement must come second.

To illustrate proof by contradiction in Lean, let's redo our first
example from the last Chapter in a different way. That example was based
on Example 3.2.4 in \emph{HTPI}. We'll begin with the same first two
steps, introducing two assumptions.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_2\_4\_v2 (P Q R : }\KeywordTok{Prop}\NormalTok{)}
\NormalTok{    (h : P → (Q → R)) : ¬R → (P → ¬Q) := }\KeywordTok{by}
  \KeywordTok{assume}\NormalTok{ h2 : ¬R}
  \KeywordTok{assume}\NormalTok{ h3 : P}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{P Q R }\NormalTok{: Prop}
\InformationTok{h }\NormalTok{: P → Q → R}
\InformationTok{h2 }\NormalTok{: ¬R}
\InformationTok{h3 }\NormalTok{: P}
\NormalTok{⊢ ¬Q}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Now the goal is a negative statement, so we use the tactic
\texttt{by\_contra\ h4} to introduce the assumption \texttt{h4\ :\ Q}
and set the goal to be \texttt{False}:

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_2\_4\_v2 (P Q R : }\KeywordTok{Prop}\NormalTok{)}
\NormalTok{    (h : P → (Q → R)) : ¬R → (P → ¬Q) := }\KeywordTok{by}
  \KeywordTok{assume}\NormalTok{ h2 : ¬R}
  \KeywordTok{assume}\NormalTok{ h3 : P}
  \KeywordTok{by\_contra}\NormalTok{ h4}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{P Q R }\NormalTok{: Prop}
\InformationTok{h }\NormalTok{: P → Q → R}
\InformationTok{h2 }\NormalTok{: ¬R}
\InformationTok{h3 }\NormalTok{: P}
\InformationTok{h4 }\NormalTok{: Q}
\NormalTok{⊢ False}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Using the givens \texttt{h}, \texttt{h3}, and \texttt{h4} we can deduce
first \texttt{Q\ →\ R} and then \texttt{R} by two applications of modus
ponens:

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_2\_4\_v2 (P Q R : }\KeywordTok{Prop}\NormalTok{)}
\NormalTok{    (h : P → (Q → R)) : ¬R → (P → ¬Q) := }\KeywordTok{by}
  \KeywordTok{assume}\NormalTok{ h2 : ¬R}
  \KeywordTok{assume}\NormalTok{ h3 : P}
  \KeywordTok{by\_contra}\NormalTok{ h4}
  \KeywordTok{have}\NormalTok{ h5 : Q → R := h h3}
  \KeywordTok{have}\NormalTok{ h6 : R := h5 h4}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{P Q R }\NormalTok{: Prop}
\InformationTok{h }\NormalTok{: P → Q → R}
\InformationTok{h2 }\NormalTok{: ¬R}
\InformationTok{h3 }\NormalTok{: P}
\InformationTok{h4 }\NormalTok{: Q}
\InformationTok{h5 }\NormalTok{: Q → R}
\InformationTok{h6 }\NormalTok{: R}
\NormalTok{⊢ False}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Now we have a contradiction: \texttt{h2\ :\ ¬R} and \texttt{h6\ :\ R}.
To complete the proof, we deduce \texttt{False} from these two givens.
Either \texttt{h2\ h6} or \texttt{absurd\ h6\ h2} would be accepted by
Lean as a proof of \texttt{False}:

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_2\_4\_v2 (P Q R : }\KeywordTok{Prop}\NormalTok{)}
\NormalTok{    (h : P → (Q → R)) : ¬R → (P → ¬Q) := }\KeywordTok{by}
  \KeywordTok{assume}\NormalTok{ h2 : ¬R}
  \KeywordTok{assume}\NormalTok{ h3 : P}
  \KeywordTok{by\_contra}\NormalTok{ h4}
  \KeywordTok{have}\NormalTok{ h5 : Q → R := h h3}
  \KeywordTok{have}\NormalTok{ h6 : R := h5 h4}
  \KeywordTok{show}\NormalTok{ False }\KeywordTok{from}\NormalTok{ h2 h6}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialStringTok{No}\InformationTok{ }\SpecialStringTok{goals}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Finally, we have two strategies for using a given that is a negative
statement (\emph{HTPI} pp.~105, 108):

\hypertarget{to-use-a-given-of-the-form-p}{%
\subsubsection{\texorpdfstring{To use a given of the form
\texttt{¬P}:}{To use a given of the form ¬P:}}\label{to-use-a-given-of-the-form-p}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Reexpress the given in some other form.
\item
  If you are doing a proof by contradiction, you can achieve a
  contradiction by proving \texttt{P}, since that would contradict the
  given \texttt{¬P}.
\end{enumerate}

Of course, strategy 1 suggests the use of the \texttt{demorgan},
\texttt{conditional}, \texttt{double\_neg}, and \texttt{bicond\_neg}
tactics, if they apply. For strategy 2, if you are doing a proof by
contradiction and you have a given \texttt{h\ :\ ¬P}, then the tactic
\texttt{contradict\ h} will set the goal to be \texttt{P}, which will
complete the proof by contradicting \texttt{h}. In fact, this tactic can
be used with any given; if you have a given \texttt{h\ :\ P}, where
\texttt{P} is not a negative statement, then \texttt{contradict\ h} will
set the goal to be \texttt{¬P}. You can also follow the word
\texttt{contradict} with a proof that is more complicated than a single
identifier. For example, if you have givens \texttt{h1\ :\ P\ →\ ¬Q} and
\texttt{h2\ :\ P}, then \texttt{h1\ h2} is a proof of \texttt{¬Q}, so
the tactic \texttt{contradict\ h1\ h2} will set the goal to be
\texttt{Q}.

If you're not doing a proof by contradiction, then the tactic
\texttt{contradict\ h\ with\ h\textquotesingle{}} will first initiate a
proof by contradiction by assuming the negation of the goal, giving that
assumption the identifier \texttt{h\textquotesingle{}}, and then it will
set the goal to be the negation of the statement proven by \texttt{h}.
In other words, \texttt{contradict\ h\ with\ h\textquotesingle{}} is
shorthand for \texttt{by\_contra\ h\textquotesingle{};\ contradict\ h}.

We can illustrate this with yet another way to write the proof from
Example 3.2.4. Our first three steps will be the same as last time:

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_2\_4\_v3 (P Q R : }\KeywordTok{Prop}\NormalTok{)}
\NormalTok{    (h : P → (Q → R)) : ¬R → (P → ¬Q) := }\KeywordTok{by}
  \KeywordTok{assume}\NormalTok{ h2 : ¬R}
  \KeywordTok{assume}\NormalTok{ h3 : P}
  \KeywordTok{by\_contra}\NormalTok{ h4}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{P Q R }\NormalTok{: Prop}
\InformationTok{h }\NormalTok{: P → Q → R}
\InformationTok{h2 }\NormalTok{: ¬R}
\InformationTok{h3 }\NormalTok{: P}
\InformationTok{h4 }\NormalTok{: Q}
\NormalTok{⊢ False}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Since we are now doing a proof by contradiction and the given
\texttt{h2\ :\ ¬R} is a negative statement, a likely way to proceed is
to try to prove \texttt{R}, which would contradict \texttt{h2}. So we
use the tactic \texttt{contradict\ h2}:

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_2\_4\_v3 (P Q R : }\KeywordTok{Prop}\NormalTok{)}
\NormalTok{    (h : P → (Q → R)) : ¬R → (P → ¬Q) := }\KeywordTok{by}
  \KeywordTok{assume}\NormalTok{ h2 : ¬R}
  \KeywordTok{assume}\NormalTok{ h3 : P}
  \KeywordTok{by\_contra}\NormalTok{ h4}
  \KeywordTok{contradict}\NormalTok{ h2}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{P Q R }\NormalTok{: Prop}
\InformationTok{h }\NormalTok{: P → Q → R}
\InformationTok{h2 }\NormalTok{: ¬R}
\InformationTok{h3 }\NormalTok{: P}
\InformationTok{h4 }\NormalTok{: Q}
\NormalTok{⊢ R}
\end{Highlighting}
\end{Shaded}

\end{outpt}

As before, we can now prove \texttt{R} by combining \texttt{h},
\texttt{h3}, and \texttt{h4}. In fact, we could do it in one step: by
modus ponens, \texttt{h\ h3} is a proof of \texttt{Q\ →\ R}, and
therefore, by another application of modus ponens, \texttt{(h\ h3)\ h4}
is a proof of \texttt{R}. The parentheses here are not necessary; Lean
will interpret \texttt{h\ h3\ h4} as \texttt{(h\ h3)\ h4}, so we can
complete the proof like this:

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_2\_4\_v3 (P Q R : }\KeywordTok{Prop}\NormalTok{)}
\NormalTok{    (h : P → (Q → R)) : ¬R → (P → ¬Q) := }\KeywordTok{by}
  \KeywordTok{assume}\NormalTok{ h2 : ¬R}
  \KeywordTok{assume}\NormalTok{ h3 : P}
  \KeywordTok{by\_contra}\NormalTok{ h4}
  \KeywordTok{contradict}\NormalTok{ h2}
  \KeywordTok{show}\NormalTok{ R }\KeywordTok{from}\NormalTok{ h h3 h4}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialStringTok{No}\InformationTok{ }\SpecialStringTok{goals}
\end{Highlighting}
\end{Shaded}

\end{outpt}

You could shorten this proof slightly by replacing the lines
\texttt{by\_contra\ h4} and \texttt{contradict\ h2} with the single line
\texttt{contradict\ h2\ with\ h4}.

There is one more idea that is introduced in Section 3.2 of \emph{HTPI}.
The last example in that section illustrates how you can sometimes use
rules of inference to work backwards. Here's a similar example in Lean:

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Like\_Example\_3\_2\_5}
\NormalTok{    (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) (a : U)}
\NormalTok{    (h1 : a ∈ A) (h2 : a ∉ A \textbackslash{} B)}
\NormalTok{    (h3 : a ∈ B → a ∈ C) : a ∈ C := }\KeywordTok{by}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{a }\NormalTok{: U}
\InformationTok{h1 }\NormalTok{: a ∈ A}
\InformationTok{h2 }\NormalTok{: ¬a ∈ A \textbackslash{} B}
\InformationTok{h3 }\NormalTok{: a ∈ B → a ∈ C}
\NormalTok{⊢ a ∈ C}
\end{Highlighting}
\end{Shaded}

\end{outpt}

The goal is \texttt{a\ ∈\ C}, and the only given that even mentions
\texttt{C} is \texttt{h3\ :\ a\ ∈\ B\ →\ a\ ∈\ C}. If only we could
prove \texttt{a\ ∈\ B}, then we could apply \texttt{h3}, using modus
ponens, to reach our goal. So it would make sense to work toward the
goal of proving \texttt{a\ ∈\ B}.

To get Lean to use this proof strategy, we use the tactic
\texttt{apply\ h3\ \_}. The underscore here represents a blank to be
filled in by Lean. You might think of this tactic as asking Lean the
question: If we want \texttt{h3\ \_} to be a proof of the goal
\texttt{a\ ∈\ C}, what do we have to put in the blank? Lean is able to
figure out that the answer is: a proof of \texttt{a\ ∈\ B}. So it sets
the goal to be \texttt{a\ ∈\ B}, since a proof of that goal, when
inserted into the blank in \texttt{h3\ \_}, would prove the original
goal \texttt{a\ ∈\ C}:

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Like\_Example\_3\_2\_5}
\NormalTok{    (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) (a : U)}
\NormalTok{    (h1 : a ∈ A) (h2 : a ∉ A \textbackslash{} B)}
\NormalTok{    (h3 : a ∈ B → a ∈ C) : a ∈ C := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ h3 \_}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C}\NormalTok{: Set U}
\InformationTok{a }\NormalTok{: U}
\InformationTok{h1 }\NormalTok{: a ∈ A}
\InformationTok{h2 }\NormalTok{: ¬a ∈ A \textbackslash{} B}
\InformationTok{h3 }\NormalTok{: a ∈ B → a ∈ C}
\NormalTok{⊢ a ∈ B}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Our situation now is very much like the one in the theorem
\texttt{Example\_3\_2\_5\_Simple} in the previous chapter, and the rest
of our proof will be similar to the proof there. The given \texttt{h2}
is a negative statement, so, as suggested by our first strategy for
using negative givens, we reexpress it as an equivalent positive
statement. Writing out the definition of set difference, \texttt{h2}
means \texttt{¬(a\ ∈\ A\ ∧\ a\ ∉\ B)}, and then one of De Morgan's laws
and a conditional law allow us to rewrite it first as
\texttt{a\ ∉\ A\ ∨\ a\ ∈\ B} and then as \texttt{a\ ∈\ A\ →\ a\ ∈\ B}.
Of course, we have tactics to accomplish all of these reexpressions:

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Like\_Example\_3\_2\_5}
\NormalTok{    (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) (a : U)}
\NormalTok{    (h1 : a ∈ A) (h2 : a ∉ A \textbackslash{} B)}
\NormalTok{    (h3 : a ∈ B → a ∈ C) : a ∈ C := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ h3 \_}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2}
  \KeywordTok{demorgan} \KeywordTok{at}\NormalTok{ h2; }\KeywordTok{conditional} \KeywordTok{at}\NormalTok{ h2}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{a }\NormalTok{: U}
\InformationTok{h1 }\NormalTok{: a ∈ A}
\InformationTok{h2 }\NormalTok{: a ∈ A → a ∈ B}
\InformationTok{h3 }\NormalTok{: a ∈ B → a ∈ C}
\NormalTok{⊢ a ∈ B}
\end{Highlighting}
\end{Shaded}

\end{outpt}

And now it is easy to complete the proof by applying modus ponens, using
\texttt{h2} and \texttt{h1}:

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Like\_Example\_3\_2\_5}
\NormalTok{    (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) (a : U)}
\NormalTok{    (h1 : a ∈ A) (h2 : a ∉ A \textbackslash{} B)}
\NormalTok{    (h3 : a ∈ B → a ∈ C) : a ∈ C := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ h3 \_}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2}
  \KeywordTok{demorgan} \KeywordTok{at}\NormalTok{ h2; }\KeywordTok{conditional} \KeywordTok{at}\NormalTok{ h2}
  \KeywordTok{show}\NormalTok{ a ∈ B }\KeywordTok{from}\NormalTok{ h2 h1}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialStringTok{No}\InformationTok{ }\SpecialStringTok{goals}
\end{Highlighting}
\end{Shaded}

\end{outpt}

We will see many more uses of the \texttt{apply} tactic later in this
book.

Sections 3.1 and 3.2 of \emph{HTPI} contain several proofs that involve
algebraic reasoning. Although one can do such proofs in Lean, it
requires ideas that we are not ready to introduce yet. So for the moment
we will stick to proofs involving only logic and set theory.

\hypertarget{exercises}{%
\subsection{Exercises}\label{exercises}}

Fill in proofs of the following theorems. All of them are based on
exercises in \emph{HTPI}.

\begin{numex}{1}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_2\_1a (P Q R : }\KeywordTok{Prop}\NormalTok{)}
\NormalTok{    (h1 : P → Q) (h2 : Q → R) : P → R := }\KeywordTok{by}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{2}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_2\_1b (P Q R : }\KeywordTok{Prop}\NormalTok{)}
\NormalTok{    (h1 : ¬R → (P → ¬Q)) : P → (Q → R) := }\KeywordTok{by}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{3}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_2\_2a (P Q R : }\KeywordTok{Prop}\NormalTok{)}
\NormalTok{    (h1 : P → Q) (h2 : R → ¬Q) : P → ¬R := }\KeywordTok{by}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{4}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_2\_2b (P Q : }\KeywordTok{Prop}\NormalTok{)}
\NormalTok{    (h1 : P) : Q → ¬(Q → ¬P) := }\KeywordTok{by}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{numex}

\hypertarget{proofs-involving-quantifiers}{%
\section{3.3. Proofs Involving
Quantifiers}\label{proofs-involving-quantifiers}}

In the notation used in \emph{HTPI}, if \(P(x)\) is a statement about
\(x\), then \(\forall x\, P(x)\) means ``for all \(x\), \(P(x)\),'' and
\(\exists x\, P(x)\) means ``there exists at least one \(x\) such that
\(P(x)\).'' The letter \(P\) here does not stand for a proposition; it
is only when it is applied to some object \(x\) that we get a
proposition. We will say that \(P\) is a \emph{predicate}, and when we
apply \(P\) to an object \(x\) we get the proposition \(P(x)\). You
might want to think of the predicate \(P\) as representing some property
that an object might have, and the proposition \(P(x)\) asserts that
\(x\) has that property.

To use a predicate in Lean, you must tell Lean the type of objects to
which it applies. If \texttt{U} is a type, then \texttt{Pred\ U} is the
type of predicates that apply to objects of type \texttt{U}. If
\texttt{P} has type \texttt{Pred\ U} (that is, \texttt{P} is a predicate
applying to objects of type \texttt{U}) and \texttt{x} has type
\texttt{U}, then to apply \texttt{P} to \texttt{x} we just write
\texttt{P\ x} (with a space but no parentheses). Thus, if we have
\texttt{P\ :\ Pred\ U} and \texttt{x\ :\ U}, then \texttt{P\ x} is an
expression of type \texttt{Prop}. That is, \texttt{P\ x} is a
proposition, and its meaning is that \texttt{x} has the property
represented by the predicate \texttt{P}.

There are a few differences between the way quantified statements are
written in \emph{HTPI} and the way they are written in Lean. First of
all, when we apply a quantifier to a variable in Lean we will specify
the type of the variable explicitly. Also, Lean requires that after
specifying the variable and its type, you must put a comma before the
proposition to which the quantifier is applied. Thus, if \texttt{P} has
type \texttt{Pred\ U}, then to say that \texttt{P} holds for all objects
of type \texttt{U} we would write \texttt{∀\ (x\ :\ U),\ P\ x}.
Similarly, \texttt{∃\ (x\ :\ U),\ P\ x} is the proposition asserting
that there exists at least one \texttt{x} of type \texttt{U} such that
\texttt{P\ x}.

And there is one more important difference between the way quantified
statements are written in \emph{HTPI} and Lean. In \emph{HTPI}, a
quantifier is interpreted as applying to as little as possible. Thus,
\(\forall x\, P(x) \wedge Q(x)\) is interpreted as
\((\forall x\, P(x)) \wedge Q(x)\); if you want the quantifier
\(\forall x\) to apply to the entire statement \(P(x) \wedge Q(x)\) you
must use parentheses and write \(\forall x(P(x) \wedge Q(x))\). The
convention in Lean is exactly the opposite: a quantifier applies to as
much as possible. Thus, Lean will interpret
\texttt{∀\ (x\ :\ U),\ P\ x\ ∧\ Q\ x} as meaning
\texttt{∀\ (x\ :\ U),\ (P\ x\ ∧\ Q\ x)}. If you want the quantifier to
apply to only \texttt{P\ x}, then you must use parentheses and write
\texttt{(∀\ (x\ :\ U),\ P\ x)\ ∧\ Q\ x}.

With this preparation, we are ready to consider how to write proofs
involving quantifiers in Lean. The most common way to prove a goal of
the form \texttt{∀\ (x\ :\ U),\ P\ x} is to use the following strategy
(\emph{HTPI} p.~114):

\hypertarget{to-prove-a-goal-of-the-form-x-u-p-x}{%
\subsubsection{\texorpdfstring{To prove a goal of the form
\texttt{∀\ (x\ :\ U),\ P\ x}:}{To prove a goal of the form ∀ (x : U), P x:}}\label{to-prove-a-goal-of-the-form-x-u-p-x}}

\begin{ind}
Let \texttt{x} stand for an arbitrary object of type \texttt{U} and
prove \texttt{P\ x}. If the letter \texttt{x} is already being used in
the proof to stand for something, then you must choose an unused
variable, say \texttt{y}, to stand for the arbitrary object, and prove
\texttt{P\ y}.

\end{ind}

To do this in Lean, you should use the tactic \texttt{fix\ x\ :\ U},
which tells Lean to treat \texttt{x} as standing for some fixed but
arbitrary object of type \texttt{U}. This has the following effect on
the tactic state:

\begin{bef}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{ ⋮}
\NormalTok{⊢ ∀ (x : U), P x}
\end{Highlighting}
\end{Shaded}

\end{bef}

\begin{aft}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{ ⋮}
\InformationTok{x }\NormalTok{: U}
\NormalTok{⊢ P x}
\end{Highlighting}
\end{Shaded}

\end{aft}

To use a given of the form \texttt{∀\ (x\ :\ U),\ P\ x}, we usually
apply a rule of inference called \emph{universal instantiation}, which
is described by the following proof strategy (\emph{HTPI} p.~121):

\hypertarget{to-use-a-given-of-the-form-x-u-p-x}{%
\subsubsection{\texorpdfstring{To use a given of the form
\texttt{∀\ (x\ :\ U),\ P\ x}:}{To use a given of the form ∀ (x : U), P x:}}\label{to-use-a-given-of-the-form-x-u-p-x}}

\begin{ind}
You may plug in any value of type \texttt{U}, say \texttt{a}, for
\texttt{x} and use this given to conclude that \texttt{P\ a} is true.

\end{ind}

This strategy says that if you have \texttt{h\ :\ ∀\ (x\ :\ U),\ P\ x}
and \texttt{a\ :\ U}, then you can infer \texttt{P\ a}. Indeed, in this
situation Lean will recognize \texttt{h\ a} as a proof of \texttt{P\ a}.
For example, you can write
\texttt{have\ h\textquotesingle{}\ :\ P\ a\ :=\ h\ a} in a Lean
tactic-mode proof, and Lean will add
\texttt{h\textquotesingle{}\ :\ P\ a} to the tactic state. Note that
\texttt{a} here need not be simply a variable; it can be any expression
denoting an object of type \texttt{U}.

Let's try these strategies out in a Lean proof. In Lean, if you don't
want to give a theorem a name, you can simply call it an
\texttt{example} rather than a \texttt{theorem}, and then there is no
need to give it a name. In the following theorem, you can enter the
symbol \texttt{∀} by typing \texttt{\textbackslash{}forall} or
\texttt{\textbackslash{}all}, and you can enter \texttt{∃} by typing
\texttt{\textbackslash{}exists} or \texttt{\textbackslash{}ex}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (P Q : Pred U)}
\NormalTok{    (h1 : ∀ (x : U), P x → ¬Q x)}
\NormalTok{    (h2 : ∀ (x : U), Q x) :}
\NormalTok{    ¬∃ (x : U), P x := }\KeywordTok{by}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{P Q }\NormalTok{: Pred U}
\InformationTok{h1 }\NormalTok{: ∀ (x : U), P x → ¬Q x}
\InformationTok{h2 }\NormalTok{: ∀ (x : U), Q x}
\NormalTok{⊢ ¬∃ (x : U), P x}
\end{Highlighting}
\end{Shaded}

\end{outpt}

To use the givens \texttt{h1} and \texttt{h2}, we will probably want to
use universal instantiation. But to do that we would need an object of
type \texttt{U} to plug in for \texttt{x} in \texttt{h1} and
\texttt{h2}, and there is no object of type \texttt{U} in the tactic
state. So at this point, we can't apply universal instantiation to
\texttt{h1} and \texttt{h2}. We should watch for an object of type
\texttt{U} to come up in the course of the proof, and consider applying
universal instantiation if one does. Until then, we turn our attention
to the goal.

The goal is a negative statement, so we begin by reexpressing it as an
equivalent positive statement, using a quantifier negation law. The
tactic \texttt{quant\_neg} applies a quantifier negation law to rewrite
the goal. As with the other tactics for applying logical equivalences,
you can write \texttt{quant\_neg\ at\ h} if you want to apply a
quantifier negation law to a given \texttt{h}. The effect of the tactic
can be summarized as follows:

\begin{longtable}[]{@{}ccc@{}}
\toprule\noalign{}
& \texttt{quant\_neg} Tactic & \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{¬∀\ (x\ :\ U),\ P\ x} & is changed to &
\texttt{∃\ (x\ :\ U),\ ¬P\ x} \\
\texttt{¬∃\ (x\ :\ U),\ P\ x} & is changed to &
\texttt{∀\ (x\ :\ U),\ ¬P\ x} \\
\texttt{∀\ (x\ :\ U),\ P\ x} & is changed to &
\texttt{¬∃\ (x\ :\ U),\ ¬P\ x} \\
\texttt{∃\ (x\ :\ U),\ P\ x} & is changed to &
\texttt{¬∀\ (x\ :\ U),\ ¬P\ x} \\
\end{longtable}

Using the \texttt{quant\_neg} tactic leads to the following result.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (P Q : Pred U)}
\NormalTok{    (h1 : ∀ (x : U), P x → ¬Q x)}
\NormalTok{    (h2 : ∀ (x : U), Q x) :}
\NormalTok{    ¬∃ (x : U), P x := }\KeywordTok{by}
  \KeywordTok{quant\_neg}     \CommentTok{{-}{-}Goal is now ∀ (x : U), ¬P x}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{P Q }\NormalTok{: Pred U}
\InformationTok{h1 }\NormalTok{: ∀ (x : U), P x → ¬Q x}
\InformationTok{h2 }\NormalTok{: ∀ (x : U), Q x}
\NormalTok{⊢ ∀ (x : U), ¬P x}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Now the goal starts with \texttt{∀}, so we use the strategy above and
introduce an arbitrary object of type \texttt{U}. Since the variable
\texttt{x} occurs as a bound variable in several statements in this
theorem, it might be best to use a different letter for the arbitrary
object; this isn't absolutely necessary, but it may help to avoid
confusion. So our next tactic is \texttt{fix\ y\ :\ U}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (P Q : Pred U)}
\NormalTok{    (h1 : ∀ (x : U), P x → ¬Q x)}
\NormalTok{    (h2 : ∀ (x : U), Q x) :}
\NormalTok{    ¬∃ (x : U), P x := }\KeywordTok{by}
  \KeywordTok{quant\_neg}     \CommentTok{{-}{-}Goal is now ∀ (x : U), ¬P x}
  \KeywordTok{fix}\NormalTok{ y : U}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{P Q }\NormalTok{: Pred U}
\InformationTok{h1 }\NormalTok{: ∀ (x : U), P x → ¬Q x}
\InformationTok{h2 }\NormalTok{: ∀ (x : U), Q x}
\InformationTok{y }\NormalTok{: U}
\NormalTok{⊢ ¬P y}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Now we have an object of type \texttt{U} in the tactic state, namely,
\texttt{y}. So let's try applying universal instantiation to \texttt{h1}
and \texttt{h2} and see if it helps.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (P Q : Pred U)}
\NormalTok{    (h1 : ∀ (x : U), P x → ¬Q x)}
\NormalTok{    (h2 : ∀ (x : U), Q x) :}
\NormalTok{    ¬∃ (x : U), P x := }\KeywordTok{by}
  \KeywordTok{quant\_neg}     \CommentTok{{-}{-}Goal is now ∀ (x : U), ¬P x}
  \KeywordTok{fix}\NormalTok{ y : U}
  \KeywordTok{have}\NormalTok{ h3 : P y → ¬Q y := h1 y}
  \KeywordTok{have}\NormalTok{ h4 : Q y := h2 y}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{P Q }\NormalTok{: Pred U}
\InformationTok{h1 }\NormalTok{: ∀ (x : U), P x → ¬Q x}
\InformationTok{h2 }\NormalTok{: ∀ (x : U), Q x}
\InformationTok{y }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: P y → ¬Q y}
\InformationTok{h4 }\NormalTok{: Q y}
\NormalTok{⊢ ¬P y}
\end{Highlighting}
\end{Shaded}

\end{outpt}

We're almost done, because the goal now follows easily from \texttt{h3}
and \texttt{h4}. If we use the contrapositive law to rewrite \texttt{h3}
as \texttt{Q\ y\ →\ ¬P\ y}, then we can apply modus ponens to the
rewritten \texttt{h3} and \texttt{h4} to reach the goal:

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (P Q : Pred U)}
\NormalTok{    (h1 : ∀ (x : U), P x → ¬Q x)}
\NormalTok{    (h2 : ∀ (x : U), Q x) :}
\NormalTok{    ¬∃ (x : U), P x := }\KeywordTok{by}
  \KeywordTok{quant\_neg}     \CommentTok{{-}{-}Goal is now ∀ (x : U), ¬P x}
  \KeywordTok{fix}\NormalTok{ y : U}
  \KeywordTok{have}\NormalTok{ h3 : P y → ¬Q y := h1 y}
  \KeywordTok{have}\NormalTok{ h4 : Q y := h2 y}
  \KeywordTok{contrapos} \KeywordTok{at}\NormalTok{ h3  }\CommentTok{{-}{-}Now h3 : Q y → ¬P y}
  \KeywordTok{show}\NormalTok{ ¬P y }\KeywordTok{from}\NormalTok{ h3 h4}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialStringTok{No}\InformationTok{ }\SpecialStringTok{goals}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Our next example is a theorem of set theory. You already know how to
type a few set theory symbols in Lean, but you'll need a few more for
our next example. Here's a summary of the most important set theory
symbols and how to type them in Lean.

\begin{longtable}[]{@{}cc@{}}
\toprule\noalign{}
Symbol & How To Type It \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{∈} & \texttt{\textbackslash{}in} \\
\texttt{∉} & \texttt{\textbackslash{}notin} or
\texttt{\textbackslash{}inn} \\
\texttt{⊆} & \texttt{\textbackslash{}sub} \\
\texttt{⊈} & \texttt{\textbackslash{}subn} \\
\texttt{=} & \texttt{=} \\
\texttt{≠} & \texttt{\textbackslash{}ne} \\
\texttt{∪} & \texttt{\textbackslash{}union} or
\texttt{\textbackslash{}cup} \\
\texttt{∩} & \texttt{\textbackslash{}inter} or
\texttt{\textbackslash{}cap} \\
\texttt{\textbackslash{}} & \texttt{\textbackslash{}\textbackslash{}} \\
\texttt{△} & \texttt{\textbackslash{}bigtriangleup} \\
\texttt{∅} & \texttt{\textbackslash{}emptyset} \\
\texttt{𝒫} & \texttt{\textbackslash{}powerset} \\
\end{longtable}

With this preparation, we can turn to our next example.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) (h1 : A ⊆ B ∪ C)}
\NormalTok{    (h2 : ∀ (x : U), x ∈ A → x ∉ B) : A ⊆ C := }\KeywordTok{by}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: A ⊆ B ∪ C}
\InformationTok{h2 }\NormalTok{: ∀ (x : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  x ∈ A → ¬x ∈ B}
\NormalTok{⊢ A ⊆ C}
\end{Highlighting}
\end{Shaded}

\end{outpt}

We begin by using the \texttt{define} tactic to write out the definition
of the goal.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) (h1 : A ⊆ B ∪ C)}
\NormalTok{    (h2 : ∀ (x : U), x ∈ A → x ∉ B) : A ⊆ C := }\KeywordTok{by}
  \KeywordTok{define}  \CommentTok{{-}{-}Goal : ∀ ⦃a : U⦄, a ∈ A → a ∈ C}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C}\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: A ⊆ B ∪ C}
\InformationTok{h2 }\NormalTok{: ∀ (x : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  x ∈ A → ¬x ∈ B}
\NormalTok{⊢ ∀ ⦃a : U⦄,}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  a ∈ A → a ∈ C}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Notice that Lean's definition of the goal starts with
\texttt{∀\ ⦃a\ :\ U⦄}, not \texttt{∀\ (a\ :\ U)}. Why did Lean use those
funny double braces rather than parentheses? We'll return to that
question shortly. The difference doesn't affect our next steps, which
are to introduce an arbitrary object \texttt{y} of type \texttt{U} and
assume \texttt{y\ ∈\ A}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) (h1 : A ⊆ B ∪ C)}
\NormalTok{    (h2 : ∀ (x : U), x ∈ A → x ∉ B) : A ⊆ C := }\KeywordTok{by}
  \KeywordTok{define}  \CommentTok{{-}{-}Goal : ∀ ⦃a : U⦄, a ∈ A → a ∈ C}
  \KeywordTok{fix}\NormalTok{ y : U}
  \KeywordTok{assume}\NormalTok{ h3 : y ∈ A}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: A ⊆ B ∪ C}
\InformationTok{h2 }\NormalTok{: ∀ (x : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  x ∈ A → ¬x ∈ B}
\InformationTok{y }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: y ∈ A}
\NormalTok{⊢ y ∈ C}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Now we can combine \texttt{h2} and \texttt{h3} to conclude that
\texttt{¬y\ ∈\ B}. Since we have \texttt{y\ :\ U}, by universal
instantiation, \texttt{h2\ y} is a proof of
\texttt{y\ ∈\ A\ →\ ¬y\ ∈\ B}, and therefore by modus ponens,
\texttt{h2\ y\ h3} is a proof of \texttt{¬y\ ∈\ B}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) (h1 : A ⊆ B ∪ C)}
\NormalTok{    (h2 : ∀ (x : U), x ∈ A → x ∉ B) : A ⊆ C := }\KeywordTok{by}
  \KeywordTok{define}  \CommentTok{{-}{-}Goal : ∀ ⦃a : U⦄, a ∈ A → a ∈ C}
  \KeywordTok{fix}\NormalTok{ y : U}
  \KeywordTok{assume}\NormalTok{ h3 : y ∈ A}
  \KeywordTok{have}\NormalTok{ h4 : y ∉ B := h2 y h3}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: A ⊆ B ∪ C}
\InformationTok{h2 }\NormalTok{: ∀ (x : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  x ∈ A → ¬x ∈ B}
\InformationTok{y }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: y ∈ A}
\InformationTok{h4 }\NormalTok{: ¬y ∈ B}
\NormalTok{⊢ y ∈ C}
\end{Highlighting}
\end{Shaded}

\end{outpt}

We should be able to use similar reasoning to combine \texttt{h1} and
\texttt{h3}, if we first write out the definition of \texttt{h1}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) (h1 : A ⊆ B ∪ C)}
\NormalTok{    (h2 : ∀ (x : U), x ∈ A → x ∉ B) : A ⊆ C := }\KeywordTok{by}
  \KeywordTok{define}  \CommentTok{{-}{-}Goal : ∀ ⦃a : U⦄, a ∈ A → a ∈ C}
  \KeywordTok{fix}\NormalTok{ y : U}
  \KeywordTok{assume}\NormalTok{ h3 : y ∈ A}
  \KeywordTok{have}\NormalTok{ h4 : y ∉ B := h2 y h3}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1  }\CommentTok{{-}{-}h1 : ∀ ⦃a : U⦄, a ∈ A → a ∈ B ∪ C}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: ∀ ⦃a : U⦄,}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  a ∈ A → a ∈ B ∪ C}
\InformationTok{h2 }\NormalTok{: ∀ (x : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  x ∈ A → ¬x ∈ B}
\InformationTok{y }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: y ∈ A}
\InformationTok{h4 }\NormalTok{: ¬y ∈ B}
\NormalTok{⊢ y ∈ C}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Once again, Lean has used double braces to define \texttt{h1}, and now
we are ready to explain what they mean. If the definition had been
\texttt{h1\ :\ ∀\ (a\ :\ U),\ a\ ∈\ A\ →\ a\ ∈\ B\ ∪\ C}, then exactly
as in the previous step, \texttt{h1\ y\ h3} would be a proof of
\texttt{y\ ∈\ B\ ∪\ C}. The use of double braces in the definition
\texttt{h1\ :\ ∀\ ⦃a\ :\ U⦄,\ a\ ∈\ A\ →\ a\ ∈\ B\ ∪\ C} means that you
don't need to tell Lean that \texttt{y} is being plugged in for
\texttt{a} in the universal instantiation step; Lean will figure that
out on its own. Thus, you can just write \texttt{h1\ h3} as a proof of
\texttt{y\ ∈\ B\ ∪\ C}. Indeed, if you write \texttt{h1\ y\ h3} then you
will get an error message, because Lean expects \emph{not} to be told
what to plug in for \texttt{a}. You might think of the definition of
\texttt{h1} as meaning \texttt{h1\ :\ \_\ ∈\ A\ →\ \_\ ∈\ B\ ∪\ C},
where the blanks can be filled in with anything of type \texttt{U} (with
the same thing being put in both blanks). When you ask Lean to apply
modus ponens by combining this statement with \texttt{h3\ :\ y\ ∈\ A},
Lean figures out that in order for modus ponens to apply, the blanks
must be filled in with \texttt{y}.

In this situation, the \texttt{a} in \texttt{h1} is called an
\emph{implicit argument}. What this means is that, when \texttt{h1} is
applied to make an inference in a proof, the value to be assigned to
\texttt{a} is not specified explicitly; rather, the value is inferred by
Lean. We will see many more examples of implicit arguments later in this
book. In fact, there are two slightly different kinds of implicit
arguments in Lean. One kind is indicated using the double braces
\texttt{⦃\ ⦄} used in this example, and the other is indicated using
curly braces, \texttt{\{\ \}}. The difference between these two kinds of
implicit arguments won't be important in this book; all that will matter
to us is that if you see either \texttt{∀\ ⦃a\ :\ U⦄} or
\texttt{∀\ \{a\ :\ U\}} rather than \texttt{∀\ (a\ :\ U)}, then you must
remember that \texttt{a} is an implicit argument.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) (h1 : A ⊆ B ∪ C)}
\NormalTok{    (h2 : ∀ (x : U), x ∈ A → x ∉ B) : A ⊆ C := }\KeywordTok{by}
  \KeywordTok{define}  \CommentTok{{-}{-}Goal : ∀ ⦃a : U⦄, a ∈ A → a ∈ C}
  \KeywordTok{fix}\NormalTok{ y : U}
  \KeywordTok{assume}\NormalTok{ h3 : y ∈ A}
  \KeywordTok{have}\NormalTok{ h4 : y ∉ B := h2 y h3}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1  }\CommentTok{{-}{-}h1 : ∀ ⦃a : U⦄, a ∈ A → a ∈ B ∪ C}
  \KeywordTok{have}\NormalTok{ h5 : y ∈ B ∪ C := h1 h3}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: ∀ ⦃a : U⦄,}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  a ∈ A → a ∈ B ∪ C}
\InformationTok{h2 }\NormalTok{: ∀ (x : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  x ∈ A → ¬x ∈ B}
\InformationTok{y }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: y ∈ A}
\InformationTok{h4 }\NormalTok{: ¬y ∈ B}
\InformationTok{h5 }\NormalTok{: y ∈ B ∪ C}
\NormalTok{⊢ y ∈ C}
\end{Highlighting}
\end{Shaded}

\end{outpt}

If Lean was able to figure out that \texttt{y} should be plugged in for
\texttt{a} in \texttt{h1} in this step, couldn't it have figured out
that \texttt{y} should be plugged in for \texttt{x} in \texttt{h2} in
the previous \texttt{have} step? The answer is yes. Of course, in
\texttt{h2}, \texttt{x} was not an implicit argument, so Lean wouldn't
\emph{automatically} figure out what to plug in for \texttt{x}. But we
could have asked it to figure it out by writing the proof in the
previous step as \texttt{h2\ \_\ h3} rather than \texttt{h2\ y\ h3}. In
a term-mode proof, an underscore represents a blank to be filled in by
Lean. Try changing the earlier step of the proof to
\texttt{have\ h4\ :\ y\ ∉\ B\ :=\ h2\ \_\ h3} and you will see that Lean
will accept it. Of course, in this case this doesn't save us any typing,
but in some situations it is useful to let Lean figure out some part of
a proof.

Lean's ability to fill in blanks in term-mode proofs is limited. For
example, if you try changing the previous step to
\texttt{have\ h4\ :\ y\ ∉\ B\ :=\ h2\ y\ \_}, you'll get a red squiggle
under the blank, and the error message in the Infoview pane will say
\texttt{don\textquotesingle{}t\ know\ how\ to\ synthesize\ placeholder}.
In other words, Lean was unable to figure out how to fill in the blank
in this case. In future proofs you might try replacing some expressions
with blanks to get a feel for what Lean can and cannot figure out for
itself.

Continuing with the proof, we see that we're almost done, because we can
combine \texttt{h4} and \texttt{h5} to reach our goal. To see how, we
first write out the definition of \texttt{h5}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) (h1 : A ⊆ B ∪ C)}
\NormalTok{    (h2 : ∀ (x : U), x ∈ A → x ∉ B) : A ⊆ C := }\KeywordTok{by}
  \KeywordTok{define}  \CommentTok{{-}{-}Goal : ∀ ⦃a : U⦄, a ∈ A → a ∈ C}
  \KeywordTok{fix}\NormalTok{ y : U}
  \KeywordTok{assume}\NormalTok{ h3 : y ∈ A}
  \KeywordTok{have}\NormalTok{ h4 : y ∉ B := h2 y h3}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1  }\CommentTok{{-}{-}h1 : ∀ ⦃a : U⦄, a ∈ A → a ∈ B ∪ C}
  \KeywordTok{have}\NormalTok{ h5 : y ∈ B ∪ C := h1 h3}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h5  }\CommentTok{{-}{-}h5 : y ∈ B ∨ y ∈ C}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: ∀ ⦃a : U⦄,}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  a ∈ A → a ∈ B ∪ C}
\InformationTok{h2 }\NormalTok{: ∀ (x : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  x ∈ A → ¬x ∈ B}
\InformationTok{y }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: y ∈ A}
\InformationTok{h4 }\NormalTok{: ¬y ∈ B}
\InformationTok{h5 }\NormalTok{: y ∈ B ∨ y ∈ C}
\NormalTok{⊢ y ∈ C}
\end{Highlighting}
\end{Shaded}

\end{outpt}

A conditional law will convert \texttt{h5} to
\texttt{¬y\ ∈\ B\ →\ y\ ∈\ C}, and then modus ponens with \texttt{h4}
will complete the proof.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) (h1 : A ⊆ B ∪ C)}
\NormalTok{    (h2 : ∀ (x : U), x ∈ A → x ∉ B) : A ⊆ C := }\KeywordTok{by}
  \KeywordTok{define}  \CommentTok{{-}{-}Goal : ∀ ⦃a : U⦄, a ∈ A → a ∈ C}
  \KeywordTok{fix}\NormalTok{ y : U}
  \KeywordTok{assume}\NormalTok{ h3 : y ∈ A}
  \KeywordTok{have}\NormalTok{ h4 : y ∉ B := h2 y h3}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1  }\CommentTok{{-}{-}h1 : ∀ ⦃a : U⦄, a ∈ A → a ∈ B ∪ C}
  \KeywordTok{have}\NormalTok{ h5 : y ∈ B ∪ C := h1 h3}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h5  }\CommentTok{{-}{-}h5 : y ∈ B ∨ y ∈ C}
  \KeywordTok{conditional} \KeywordTok{at}\NormalTok{ h5  }\CommentTok{{-}{-}h5 : ¬y ∈ B → y ∈ C}
  \KeywordTok{show}\NormalTok{ y ∈ C }\KeywordTok{from}\NormalTok{ h5 h4}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialStringTok{No}\InformationTok{ }\SpecialStringTok{goals}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Next we turn to strategies for working with existential quantifiers
(\emph{HTPI} p.~118).

\hypertarget{to-prove-a-goal-of-the-form-x-u-p-x-1}{%
\subsubsection{\texorpdfstring{To prove a goal of the form
\texttt{∃\ (x\ :\ U),\ P\ x}:}{To prove a goal of the form ∃ (x : U), P x:}}\label{to-prove-a-goal-of-the-form-x-u-p-x-1}}

\begin{ind}
Find a value of \texttt{x}, say \texttt{a}, for which you think
\texttt{P\ a} is true, and prove \texttt{P\ a}.

\end{ind}

This strategy is based on the fact that if you have \texttt{a\ :\ U} and
\texttt{h\ :\ P\ a}, then you can infer \texttt{∃\ (x\ :\ U),\ P\ x}.
Indeed, in this situation the expression \texttt{Exists.intro\ a\ h} is
a Lean term-mode proof of \texttt{∃\ (x\ :\ U),\ P\ x}. The name
\texttt{Exists.intro} indicates that this is a rule for introducing an
existential quantifier.

Note that, as with the universal instantiation rule, \texttt{a} here can
be any expression denoting an object of type \texttt{U}; it need not be
simply a variable. For example, if \texttt{A} and \texttt{B} have type
\texttt{Set\ U}, \texttt{F} has type \texttt{Set\ (Set\ U)}, and you
have a given \texttt{h\ :\ A\ ∪\ B\ ∈\ F}, then
\texttt{Exists.intro\ (A\ ∪\ B)\ h} is a proof of
\texttt{∃\ (x\ :\ Set\ U),\ x\ ∈\ F}.

As suggested by the strategy above, we will often want to use the
\texttt{Exists.intro} rule in situations in which our goal is
\texttt{∃\ (x\ :\ U),\ P\ x} and we have an object \texttt{a} of type
\texttt{U} that we think makes \texttt{P\ a} true, but we don't yet have
a proof of \texttt{P\ a}. In that situation we can use the tactic
\texttt{apply\ Exists.intro\ a\ \_}. Recall that the \texttt{apply}
tactic asks Lean to figure out what to put in the blank to turn
\texttt{Exists.intro\ a\ \_} into a proof of the goal. Lean will figure
out that what needs to go in the blank is a proof of \texttt{P\ a}, so
it sets \texttt{P\ a} to be the goal. In other words, the tactic
\texttt{apply\ Exists.intro\ a\ \_} has the following effect on the
tactic state:

\begin{bef}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{ ⋮}
\InformationTok{a }\NormalTok{: U}
\NormalTok{⊢ ∃ (x : U), P x}
\end{Highlighting}
\end{Shaded}

\end{bef}

\begin{aft}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{ ⋮}
\InformationTok{a }\NormalTok{: U}
\NormalTok{⊢ P a}
\end{Highlighting}
\end{Shaded}

\end{aft}

Our strategy for using an existential given is a rule that is called
\emph{existential instantiation} in \emph{HTPI} (\emph{HTPI} p.~120):

\hypertarget{to-use-a-given-of-the-form-x-u-p-x-1}{%
\subsubsection{\texorpdfstring{To use a given of the form
\texttt{∃\ (x\ :\ U),\ P\ x}:}{To use a given of the form ∃ (x : U), P x:}}\label{to-use-a-given-of-the-form-x-u-p-x-1}}

\begin{ind}
Introduce a new variable, say \texttt{u}, into the proof to stand for an
object of type \texttt{U} for which \texttt{P\ u} is true.

\end{ind}

Suppose that, in a Lean proof, you have
\texttt{h\ :\ ∃\ (x\ :\ U),\ P\ x}. To apply the existential
instantiation rule, you would use the tactic
\texttt{obtain\ (u\ :\ U)\ (h\textquotesingle{}\ :\ P\ u)\ from\ h}.
This tactic introduces into the tactic state both a new variable
\texttt{u} of type \texttt{U} and also the identifier
\texttt{h\textquotesingle{}} for the new given \texttt{P\ u}. Note that
\texttt{h} can be any proof of a statement of the form
\texttt{∃\ (x\ :\ U),\ P\ x}; it need not be just a single identifier.

Often, if your goal is an existential statement
\texttt{∃\ (x\ :\ U),\ P\ x}, you won't be able to use the strategy
above for existential goals right away, because you won't know what
object \texttt{a} to use in the tactic
\texttt{apply\ Exists.intro\ a\ \_}. You may have to wait until a likely
candidate for \texttt{a} pops up in the course of the proof. On the
other hand, it is usually best to use the \texttt{obtain} tactic right
away if you have an existential given. This is illustrated in our next
example.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (P Q : Pred U)}
\NormalTok{    (h1 : ∀ (x : U), ∃ (y : U), P x → ¬ Q y)}
\NormalTok{    (h2 : ∃ (x : U), ∀ (y : U), P x → Q y) :}
\NormalTok{    ∃ (x : U), ¬P x := }\KeywordTok{by}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{P Q }\NormalTok{: Pred U}
\InformationTok{h1 }\NormalTok{: ∀ (x : U), ∃ (y : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  P x → ¬Q y}
\InformationTok{h2 }\NormalTok{: ∃ (x : U), ∀ (y : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  P x → Q y}
\NormalTok{⊢ ∃ (x : U), ¬P x}
\end{Highlighting}
\end{Shaded}

\end{outpt}

The goal is the existential statement \texttt{∃\ (x\ :\ U),\ ¬P\ x}, and
our strategy for existential goals says that we should try to find an
object \texttt{a} of type \texttt{U} that we think would make the
statement \texttt{¬P\ a} true. But we don't have any objects of type
\texttt{U} in the tactic state, so it looks like we can't use that
strategy yet. Similarly, we can't use the given \texttt{h1} yet, since
we have nothing to plug in for \texttt{x} in \texttt{h1}. However,
\texttt{h2} is an existential given, and we can use it right away.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (P Q : Pred U)}
\NormalTok{    (h1 : ∀ (x : U), ∃ (y : U), P x → ¬ Q y)}
\NormalTok{    (h2 : ∃ (x : U), ∀ (y : U), P x → Q y) :}
\NormalTok{    ∃ (x : U), ¬P x := }\KeywordTok{by}
  \KeywordTok{obtain}\NormalTok{ (a : U)}
\NormalTok{    (h3 : ∀ (y : U), P a → Q y) }\KeywordTok{from}\NormalTok{ h2}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{P Q }\NormalTok{: Pred U}
\InformationTok{h1 }\NormalTok{: ∀ (x : U), ∃ (y : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  P x → ¬Q y}
\InformationTok{h2 }\NormalTok{: ∃ (x : U), ∀ (y : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  P x → Q y}
\InformationTok{a }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: ∀ (y : U), P a → Q y}
\NormalTok{⊢ ∃ (x : U), ¬P x}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Now that we have \texttt{a\ :\ U}, we can apply universal instantiation
to \texttt{h1}, plugging in \texttt{a} for \texttt{x}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (P Q : Pred U)}
\NormalTok{    (h1 : ∀ (x : U), ∃ (y : U), P x → ¬ Q y)}
\NormalTok{    (h2 : ∃ (x : U), ∀ (y : U), P x → Q y) :}
\NormalTok{    ∃ (x : U), ¬P x := }\KeywordTok{by}
  \KeywordTok{obtain}\NormalTok{ (a : U)}
\NormalTok{    (h3 : ∀ (y : U), P a → Q y) }\KeywordTok{from}\NormalTok{ h2}
  \KeywordTok{have}\NormalTok{ h4 : ∃ (y : U), P a → ¬ Q y := h1 a}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{P Q }\NormalTok{: Pred U}
\InformationTok{h1 }\NormalTok{: ∀ (x : U), ∃ (y : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  P x → ¬Q y}
\InformationTok{h2 }\NormalTok{: ∃ (x : U), ∀ (y : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  P x → Q y}
\InformationTok{a }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: ∀ (y : U), P a → Q y}
\InformationTok{h4 }\NormalTok{: ∃ (y : U), P a → ¬Q y}
\NormalTok{⊢ ∃ (x : U), ¬P x}
\end{Highlighting}
\end{Shaded}

\end{outpt}

By the way, this is another case in which Lean could have figured out a
part of the proof on its own. Try changing \texttt{h1\ a} in the last
step to \texttt{h1\ \_}, and you'll see that Lean will be able to figure
out how to fill in the blank.

Our new given \texttt{h4} is another existential statement, so again we
use it right away to introduce another object of type \texttt{U}. Since
this object might not be the same as \texttt{a}, we must give it a
different name. (Indeed, if you try to use the name \texttt{a} again,
Lean will give you an error message.)

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (P Q : Pred U)}
\NormalTok{    (h1 : ∀ (x : U), ∃ (y : U), P x → ¬ Q y)}
\NormalTok{    (h2 : ∃ (x : U), ∀ (y : U), P x → Q y) :}
\NormalTok{    ∃ (x : U), ¬P x := }\KeywordTok{by}
  \KeywordTok{obtain}\NormalTok{ (a : U)}
\NormalTok{    (h3 : ∀ (y : U), P a → Q y) }\KeywordTok{from}\NormalTok{ h2}
  \KeywordTok{have}\NormalTok{ h4 : ∃ (y : U), P a → ¬ Q y := h1 a}
  \KeywordTok{obtain}\NormalTok{ (b : U) (h5 : P a → ¬ Q b) }\KeywordTok{from}\NormalTok{ h4}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{P Q }\NormalTok{: Pred U}
\InformationTok{h1 }\NormalTok{: ∀ (x : U), ∃ (y : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  P x → ¬Q y}
\InformationTok{h2 }\NormalTok{: ∃ (x : U), ∀ (y : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  P x → Q y}
\InformationTok{a }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: ∀ (y : U), P a → Q y}
\InformationTok{h4 }\NormalTok{: ∃ (y : U), P a → ¬Q y}
\InformationTok{b }\NormalTok{: U}
\InformationTok{h5 }\NormalTok{: P a → ¬Q b}
\NormalTok{⊢ ∃ (x : U), ¬P x}
\end{Highlighting}
\end{Shaded}

\end{outpt}

We have not yet used \texttt{h3}. We could plug in either \texttt{a} or
\texttt{b} for \texttt{y} in \texttt{h3}, but a little thought should
show you that plugging in \texttt{b} is more useful.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (P Q : Pred U)}
\NormalTok{    (h1 : ∀ (x : U), ∃ (y : U), P x → ¬ Q y)}
\NormalTok{    (h2 : ∃ (x : U), ∀ (y : U), P x → Q y) :}
\NormalTok{    ∃ (x : U), ¬P x := }\KeywordTok{by}
  \KeywordTok{obtain}\NormalTok{ (a : U)}
\NormalTok{    (h3 : ∀ (y : U), P a → Q y) }\KeywordTok{from}\NormalTok{ h2}
  \KeywordTok{have}\NormalTok{ h4 : ∃ (y : U), P a → ¬ Q y := h1 a}
  \KeywordTok{obtain}\NormalTok{ (b : U) (h5 : P a → ¬ Q b) }\KeywordTok{from}\NormalTok{ h4}
  \KeywordTok{have}\NormalTok{ h6 : P a → Q b := h3 b}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{P Q }\NormalTok{: Pred U}
\InformationTok{h1 }\NormalTok{: ∀ (x : U), ∃ (y : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  P x → ¬Q y}
\InformationTok{h2 }\NormalTok{: ∃ (x : U), ∀ (y : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  P x → Q y}
\InformationTok{a }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: ∀ (y : U), P a → Q y}
\InformationTok{h4 }\NormalTok{: ∃ (y : U), P a → ¬Q y}
\InformationTok{b }\NormalTok{: U}
\InformationTok{h5 }\NormalTok{: P a → ¬Q b}
\InformationTok{h6 }\NormalTok{: P a → Q b}
\NormalTok{⊢ ∃ (x : U), ¬P x}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Now look at \texttt{h5} and \texttt{h6}. They show that \texttt{P\ a}
leads to contradictory conclusions, \texttt{¬Q\ b} and \texttt{Q\ b}.
This means that \texttt{P\ a} must be false. We finally know what value
of \texttt{x} to use to prove the goal.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (P Q : Pred U)}
\NormalTok{    (h1 : ∀ (x : U), ∃ (y : U), P x → ¬ Q y)}
\NormalTok{    (h2 : ∃ (x : U), ∀ (y : U), P x → Q y) :}
\NormalTok{    ∃ (x : U), ¬P x := }\KeywordTok{by}
  \KeywordTok{obtain}\NormalTok{ (a : U)}
\NormalTok{    (h3 : ∀ (y : U), P a → Q y) }\KeywordTok{from}\NormalTok{ h2}
  \KeywordTok{have}\NormalTok{ h4 : ∃ (y : U), P a → ¬ Q y := h1 a}
  \KeywordTok{obtain}\NormalTok{ (b : U) (h5 : P a → ¬ Q b) }\KeywordTok{from}\NormalTok{ h4}
  \KeywordTok{have}\NormalTok{ h6 : P a → Q b := h3 b}
  \KeywordTok{apply}\NormalTok{ Exists.intro a \_}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{P Q }\NormalTok{: Pred U}
\InformationTok{h1 }\NormalTok{: ∀ (x : U), ∃ (y : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  P x → ¬Q y}
\InformationTok{h2 }\NormalTok{: ∃ (x : U), ∀ (y : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  P x → Q y}
\InformationTok{a }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: ∀ (y : U), P a → Q y}
\InformationTok{h4 }\NormalTok{: ∃ (y : U), P a → ¬Q y}
\InformationTok{b }\NormalTok{: U}
\InformationTok{h5 }\NormalTok{: P a → ¬Q b}
\InformationTok{h6 }\NormalTok{: P a → Q b}
\NormalTok{⊢ ¬P a}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Since the goal is now a negative statement that cannot be reexpressed as
a positive statement, we use proof by contradiction.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (P Q : Pred U)}
\NormalTok{    (h1 : ∀ (x : U), ∃ (y : U), P x → ¬ Q y)}
\NormalTok{    (h2 : ∃ (x : U), ∀ (y : U), P x → Q y) :}
\NormalTok{    ∃ (x : U), ¬P x := }\KeywordTok{by}
  \KeywordTok{obtain}\NormalTok{ (a : U)}
\NormalTok{    (h3 : ∀ (y : U), P a → Q y) }\KeywordTok{from}\NormalTok{ h2}
  \KeywordTok{have}\NormalTok{ h4 : ∃ (y : U), P a → ¬ Q y := h1 a}
  \KeywordTok{obtain}\NormalTok{ (b : U) (h5 : P a → ¬ Q b) }\KeywordTok{from}\NormalTok{ h4}
  \KeywordTok{have}\NormalTok{ h6 : P a → Q b := h3 b}
  \KeywordTok{apply}\NormalTok{ Exists.intro a \_}
  \KeywordTok{by\_contra}\NormalTok{ h7}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{P Q }\NormalTok{: Pred U}
\InformationTok{h1 }\NormalTok{: ∀ (x : U), ∃ (y : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  P x → ¬Q y}
\InformationTok{h2 }\NormalTok{: ∃ (x : U), ∀ (y : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  P x → Q y}
\InformationTok{a }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: ∀ (y : U), P a → Q y}
\InformationTok{h4 }\NormalTok{: ∃ (y : U), P a → ¬Q y}
\InformationTok{b }\NormalTok{: U}
\InformationTok{h5 }\NormalTok{: P a → ¬Q b}
\InformationTok{h6 }\NormalTok{: P a → Q b}
\InformationTok{h7 }\NormalTok{: P a}
\NormalTok{⊢ False}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Now \texttt{h5\ h7} is a proof of \texttt{¬Q\ b} and \texttt{h6\ h7} is
a proof of \texttt{Q\ b}, so \texttt{h5\ h7\ (h6\ h7)} is a proof of
\texttt{False}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (P Q : Pred U)}
\NormalTok{    (h1 : ∀ (x : U), ∃ (y : U), P x → ¬ Q y)}
\NormalTok{    (h2 : ∃ (x : U), ∀ (y : U), P x → Q y) :}
\NormalTok{    ∃ (x : U), ¬P x := }\KeywordTok{by}
  \KeywordTok{obtain}\NormalTok{ (a : U)}
\NormalTok{    (h3 : ∀ (y : U), P a → Q y) }\KeywordTok{from}\NormalTok{ h2}
  \KeywordTok{have}\NormalTok{ h4 : ∃ (y : U), P a → ¬ Q y := h1 a}
  \KeywordTok{obtain}\NormalTok{ (b : U) (h5 : P a → ¬ Q b) }\KeywordTok{from}\NormalTok{ h4}
  \KeywordTok{have}\NormalTok{ h6 : P a → Q b := h3 b}
  \KeywordTok{apply}\NormalTok{ Exists.intro a \_}
  \KeywordTok{by\_contra}\NormalTok{ h7}
  \KeywordTok{show}\NormalTok{ False }\KeywordTok{from}\NormalTok{ h5 h7 (h6 h7)}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialStringTok{No}\InformationTok{ }\SpecialStringTok{goals}
\end{Highlighting}
\end{Shaded}

\end{outpt}

We conclude this section with the theorem from Example 3.3.5 in
\emph{HTPI}. That theorem concerns a union of a family of sets. In
\emph{HTPI}, such a union is written using a large union symbol,
\(\bigcup\). Lean uses the symbol \texttt{⋃₀}, which is entered by
typing \texttt{\textbackslash{}U0} (that is, backslash--capital
U--zero). For an intersection of a family of sets, Lean uses
\texttt{⋂₀}, typed as \texttt{\textbackslash{}I0}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_3\_5 (U : }\KeywordTok{Type}\NormalTok{) (B : Set U)}
\NormalTok{    (F : Set (Set U)) : ⋃₀ F ⊆ B → F ⊆ 𝒫 B := }\KeywordTok{by}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{B }\NormalTok{: Set U}
\InformationTok{F }\NormalTok{: Set (Set U)}
\NormalTok{⊢ ⋃₀ F ⊆ B → F ⊆ 𝒫 B}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Note that \texttt{F} has type \texttt{Set\ (Set\ U)}, which means that
it is a set whose elements are sets of objects of type \texttt{U}. Since
the goal is a conditional statement, we assume the antecedent and set
the consequent as our goal. We'll also write out the definition of the
new goal.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_3\_5 (U : }\KeywordTok{Type}\NormalTok{) (B : Set U)}
\NormalTok{    (F : Set (Set U)) : ⋃₀ F ⊆ B → F ⊆ 𝒫 B := }\KeywordTok{by}
  \KeywordTok{assume}\NormalTok{ h1 : ⋃₀ F ⊆ B}
  \KeywordTok{define}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{B }\NormalTok{: Set U}
\InformationTok{F }\NormalTok{: Set (Set U)}
\InformationTok{h1 }\NormalTok{: ⋃₀ F ⊆ B}
\NormalTok{⊢ ∀ ⦃a : Set U⦄,}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  a ∈ F → a ∈ 𝒫 B}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Based on the form of the goal, we introduce an arbitrary object
\texttt{x} of type \texttt{Set\ U} and assume \texttt{x\ ∈\ F}. The new
goal will be \texttt{x\ ∈\ 𝒫\ B}. The \texttt{define} tactic works out
that this means \texttt{x\ ⊆\ B}, which can be further expanded to
\texttt{∀\ ⦃a\ :\ U⦄,\ a\ ∈\ x\ →\ a\ ∈\ B}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_3\_5 (U : }\KeywordTok{Type}\NormalTok{) (B : Set U)}
\NormalTok{    (F : Set (Set U)) : ⋃₀ F ⊆ B → F ⊆ 𝒫 B := }\KeywordTok{by}
  \KeywordTok{assume}\NormalTok{ h1 : ⋃₀ F ⊆ B}
  \KeywordTok{define}
  \KeywordTok{fix}\NormalTok{ x : Set U}
  \KeywordTok{assume}\NormalTok{ h2 : x ∈ F}
  \KeywordTok{define}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{B }\NormalTok{: Set U}
\InformationTok{F }\NormalTok{: Set (Set U)}
\InformationTok{h1 }\NormalTok{: ⋃₀ F ⊆ B}
\InformationTok{x }\NormalTok{: Set U}
\InformationTok{h2 }\NormalTok{: x ∈ F}
\NormalTok{⊢ ∀ ⦃a : U⦄,}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  a ∈ x → a ∈ B}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Once again the form of the goal dictates our next steps: introduce an
arbitrary \texttt{y} of type \texttt{U} and assume \texttt{y\ ∈\ x}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_3\_5 (U : }\KeywordTok{Type}\NormalTok{) (B : Set U)}
\NormalTok{    (F : Set (Set U)) : ⋃₀ F ⊆ B → F ⊆ 𝒫 B := }\KeywordTok{by}
  \KeywordTok{assume}\NormalTok{ h1 : ⋃₀ F ⊆ B}
  \KeywordTok{define}
  \KeywordTok{fix}\NormalTok{ x : Set U}
  \KeywordTok{assume}\NormalTok{ h2 : x ∈ F}
  \KeywordTok{define}
  \KeywordTok{fix}\NormalTok{ y : U}
  \KeywordTok{assume}\NormalTok{ h3 : y ∈ x}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{B }\NormalTok{: Set U}
\InformationTok{F }\NormalTok{: Set (Set U)}
\InformationTok{h1 }\NormalTok{: ⋃₀ F ⊆ B}
\InformationTok{x }\NormalTok{: Set U}
\InformationTok{h2 }\NormalTok{: x ∈ F}
\InformationTok{y }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: y ∈ x}
\NormalTok{⊢ y ∈ B}
\end{Highlighting}
\end{Shaded}

\end{outpt}

The goal can be analyzed no further, so we turn to the givens. We
haven't used \texttt{h1} yet. To see how to use it, we write out its
definition.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_3\_5 (U : }\KeywordTok{Type}\NormalTok{) (B : Set U)}
\NormalTok{    (F : Set (Set U)) : ⋃₀ F ⊆ B → F ⊆ 𝒫 B := }\KeywordTok{by}
  \KeywordTok{assume}\NormalTok{ h1 : ⋃₀ F ⊆ B}
  \KeywordTok{define}
  \KeywordTok{fix}\NormalTok{ x : Set U}
  \KeywordTok{assume}\NormalTok{ h2 : x ∈ F}
  \KeywordTok{define}
  \KeywordTok{fix}\NormalTok{ y : U}
  \KeywordTok{assume}\NormalTok{ h3 : y ∈ x}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{B }\NormalTok{: Set U}
\InformationTok{F }\NormalTok{: Set (Set U)}
\InformationTok{h1 }\NormalTok{: ∀ ⦃a : U⦄,}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  a ∈ ⋃₀ F → a ∈ B}
\InformationTok{x }\NormalTok{: Set U}
\InformationTok{h2 }\NormalTok{: x ∈ F}
\InformationTok{y }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: y ∈ x}
\NormalTok{⊢ y ∈ B}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Now we see that we can try to use \texttt{h1} to reach our goal. Indeed,
\texttt{h1\ \_} would be a proof of the goal if we could fill in the
blank with a proof of \texttt{y\ ∈\ ∪₀F}. So we use the
\texttt{apply\ h1\ \_} tactic.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_3\_5 (U : }\KeywordTok{Type}\NormalTok{) (B : Set U)}
\NormalTok{    (F : Set (Set U)) : ⋃₀ F ⊆ B → F ⊆ 𝒫 B := }\KeywordTok{by}
  \KeywordTok{assume}\NormalTok{ h1 : ⋃₀ F ⊆ B}
  \KeywordTok{define}
  \KeywordTok{fix}\NormalTok{ x : Set U}
  \KeywordTok{assume}\NormalTok{ h2 : x ∈ F}
  \KeywordTok{define}
  \KeywordTok{fix}\NormalTok{ y : U}
  \KeywordTok{assume}\NormalTok{ h3 : y ∈ x}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
  \KeywordTok{apply}\NormalTok{ h1 \_}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{B }\NormalTok{: Set U}
\InformationTok{F }\NormalTok{: Set (Set U)}
\InformationTok{h1 }\NormalTok{: ∀ ⦃a : U⦄,}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  a ∈ ⋃₀ F → a ∈ B}
\InformationTok{x }\NormalTok{: Set U}
\InformationTok{h2 }\NormalTok{: x ∈ F}
\InformationTok{y }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: y ∈ x}
\NormalTok{⊢ y ∈ ⋃₀ F}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Once again we have a goal that can be analyzed by using the
\texttt{define} tactic.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_3\_5 (U : }\KeywordTok{Type}\NormalTok{) (B : Set U)}
\NormalTok{    (F : Set (Set U)) : ⋃₀ F ⊆ B → F ⊆ 𝒫 B := }\KeywordTok{by}
  \KeywordTok{assume}\NormalTok{ h1 : ⋃₀ F ⊆ B}
  \KeywordTok{define}
  \KeywordTok{fix}\NormalTok{ x : Set U}
  \KeywordTok{assume}\NormalTok{ h2 : x ∈ F}
  \KeywordTok{define}
  \KeywordTok{fix}\NormalTok{ y : U}
  \KeywordTok{assume}\NormalTok{ h3 : y ∈ x}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
  \KeywordTok{apply}\NormalTok{ h1 \_}
  \KeywordTok{define}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{B }\NormalTok{: Set U}
\InformationTok{F }\NormalTok{: Set (Set U)}
\InformationTok{h1 }\NormalTok{: ∀ ⦃a : U⦄,}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  a ∈ ⋃₀ F → a ∈ B}
\InformationTok{x }\NormalTok{: Set U}
\InformationTok{h2 }\NormalTok{: x ∈ F}
\InformationTok{y }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: y ∈ x}
\NormalTok{⊢ ∃ (t : Set U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  t ∈ F ∧ y ∈ t}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Our goal is now an existential statement, so we look for a value of
\texttt{t} that will make the statement \texttt{t\ ∈\ F\ ∧\ y\ ∈\ t}
true. The givens \texttt{h2} and \texttt{h3} tell us that \texttt{x} is
such a value, so as described earlier our next tactic should be
\texttt{apply\ Exists.intro\ x\ \_}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_3\_5 (U : }\KeywordTok{Type}\NormalTok{) (B : Set U)}
\NormalTok{    (F : Set (Set U)) : ⋃₀ F ⊆ B → F ⊆ 𝒫 B := }\KeywordTok{by}
  \KeywordTok{assume}\NormalTok{ h1 : ⋃₀ F ⊆ B}
  \KeywordTok{define}
  \KeywordTok{fix}\NormalTok{ x : Set U}
  \KeywordTok{assume}\NormalTok{ h2 : x ∈ F}
  \KeywordTok{define}
  \KeywordTok{fix}\NormalTok{ y : U}
  \KeywordTok{assume}\NormalTok{ h3 : y ∈ x}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
  \KeywordTok{apply}\NormalTok{ h1 \_}
  \KeywordTok{define}
  \KeywordTok{apply}\NormalTok{ Exists.intro x \_}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{B }\NormalTok{: Set U}
\InformationTok{F }\NormalTok{: Set (Set U)}
\InformationTok{h1 }\NormalTok{: ∀ ⦃a : U⦄,}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  a ∈ ⋃₀ F → a ∈ B}
\InformationTok{x }\NormalTok{: Set U}
\InformationTok{h2 }\NormalTok{: x ∈ F}
\InformationTok{y }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: y ∈ x}
\NormalTok{⊢ x ∈ F ∧ y ∈ x}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Clearly the goal now follows from \texttt{h2} and \texttt{h3}, but how
do we write the proof in Lean? Since we need to introduce the ``and''
symbol \texttt{∧}, you shouldn't be surprised to learn that the rule we
need is called \texttt{And.intro}. Proof strategies for statements
involving ``and'' will be the subject of the next section.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_3\_5 (U : }\KeywordTok{Type}\NormalTok{) (B : Set U)}
\NormalTok{    (F : Set (Set U)) : ⋃₀ F ⊆ B → F ⊆ 𝒫 B := }\KeywordTok{by}
  \KeywordTok{assume}\NormalTok{ h1 : ⋃₀ F ⊆ B}
  \KeywordTok{define}
  \KeywordTok{fix}\NormalTok{ x : Set U}
  \KeywordTok{assume}\NormalTok{ h2 : x ∈ F}
  \KeywordTok{define}
  \KeywordTok{fix}\NormalTok{ y : U}
  \KeywordTok{assume}\NormalTok{ h3 : y ∈ x}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
  \KeywordTok{apply}\NormalTok{ h1 \_}
  \KeywordTok{define}
  \KeywordTok{apply}\NormalTok{ Exists.intro x \_}
  \KeywordTok{show}\NormalTok{ x ∈ F ∧ y ∈ x }\KeywordTok{from}\NormalTok{ And.intro h2 h3}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialStringTok{No}\InformationTok{ }\SpecialStringTok{goals}
\end{Highlighting}
\end{Shaded}

\end{outpt}

You might want to compare the Lean proof above to the way the proof was
written in \emph{HTPI}. Here are the theorem and proof from \emph{HTPI}
(\emph{HTPI} p.~125):

\begin{thm}
Suppose \(B\) is a set and \(\mathcal{F}\) is a family of sets. If
\(\bigcup\mathcal{F} \subseteq B\) then
\(\mathcal{F} \subseteq \mathscr{P}(B)\).

\end{thm}

\begin{proof}

Suppose \(\bigcup \mathcal{F} \subseteq B\). Let \(x\) be an arbitrary
element of \(\mathcal{F}\). Let \(y\) be an arbitrary element of \(x\).
Since \(y \in x\) and \(x \in \mathcal{F}\), by the definition of
\(\bigcup \mathcal{F}\), \(y \in \bigcup \mathcal{F}\). But then since
\(\bigcup \mathcal{F} \subseteq B\), \(y \in B\). Since \(y\) was an
arbitrary element of \(x\), we can conclude that \(x \subseteq B\), so
\(x \in \mathscr{P}(B)\). But \(x\) was an arbitrary element of
\(\mathcal{F}\), so this shows that
\(\mathcal{F} \subseteq \mathscr{P}(B)\), as required. \excl{~□}\qedhere

\end{proof}

\hypertarget{exercises-1}{%
\subsection{Exercises}\label{exercises-1}}

\begin{numex}{1}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_3\_1}
\NormalTok{    (U : }\KeywordTok{Type}\NormalTok{) (P Q : Pred U) (h1 : ∃ (x : U), P x → Q x) :}
\NormalTok{    (∀ (x : U), P x) → ∃ (x : U), Q x := }\KeywordTok{by}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{2}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_3\_8 (U : }\KeywordTok{Type}\NormalTok{) (F : Set (Set U)) (A : Set U)}
\NormalTok{    (h1 : A ∈ F) : A ⊆ ⋃₀ F := }\KeywordTok{by}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{3}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_3\_9 (U : }\KeywordTok{Type}\NormalTok{) (F : Set (Set U)) (A : Set U)}
\NormalTok{    (h1 : A ∈ F) : ⋂₀ F ⊆ A := }\KeywordTok{by}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{4}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_3\_10 (U : }\KeywordTok{Type}\NormalTok{) (B : Set U) (F : Set (Set U))}
\NormalTok{    (h1 : ∀ (A : Set U), A ∈ F → B ⊆ A) : B ⊆ ⋂₀ F := }\KeywordTok{by}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{5}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_3\_13 (U : }\KeywordTok{Type}\NormalTok{)}
\NormalTok{    (F G : Set (Set U)) : F ⊆ G → ⋂₀ G ⊆ ⋂₀ F := }\KeywordTok{by}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{numex}

\hypertarget{proofs-involving-conjunctions-and-biconditionals}{%
\section{3.4. Proofs Involving Conjunctions and
Biconditionals}\label{proofs-involving-conjunctions-and-biconditionals}}

The strategies in \emph{HTPI} for working with conjunctions are very
simple (\emph{HTPI} p.~130).

\hypertarget{to-prove-a-goal-of-the-form-p-q-1}{%
\subsubsection{\texorpdfstring{To prove a goal of the form
\texttt{P\ ∧\ Q}:}{To prove a goal of the form P ∧ Q:}}\label{to-prove-a-goal-of-the-form-p-q-1}}

\begin{ind}
Prove \texttt{P} and \texttt{Q} separately.

\end{ind}

We already saw an example, at the end of the last section, of the use of
the rule \texttt{And.intro} to prove a conjunction. In general, if you
have \texttt{h1\ :\ P} and \texttt{h2\ :\ Q}, then
\texttt{And.intro\ h1\ h2} is a proof of \texttt{P\ ∧\ Q}. It follows
that if your goal is \texttt{P\ ∧\ Q} but you don't yet have proofs of
\texttt{P} and \texttt{Q}, then you can use the tactic
\texttt{apply\ And.intro\ \_\ \_}. Lean will figure out that the blanks
need to be filled in with proofs of \texttt{P} and \texttt{Q}, so it
will ask you to prove \texttt{P} and \texttt{Q} separately, as suggested
by the strategy above.

If you already have a proof of either \texttt{P} or \texttt{Q}, then you
can fill in one of the blanks in the \texttt{apply} tactic. For example,
if you have \texttt{h\ :\ P}, then you can write
\texttt{apply\ And.intro\ h\ \_}, and Lean will tell you that you just
have to prove \texttt{Q} to complete the proof. Similarly, if you have
\texttt{h\ :\ Q}, then \texttt{apply\ And.intro\ \_\ h} will lead to
just the single goal \texttt{P}. There is also a shortcut you can use
with the \texttt{apply} tactic: any blanks that come at the end of the
tactic can be left out. So instead of \texttt{apply\ And.intro\ \_\ \_},
you can just write \texttt{apply\ And.intro}, and instead of
\texttt{apply\ And.intro\ h\ \_}, you can write
\texttt{apply\ And.intro\ h}. On the other hand,
\texttt{apply\ And.intro\ \_\ h} can't be shortened; it is only blanks
\emph{at the end} that can be left out.

The strategy for a given that is a conjunction is similar (\emph{HTPI}
p.~131).

\hypertarget{to-use-a-given-of-the-form-p-q-1}{%
\subsubsection{\texorpdfstring{To use a given of the form
\texttt{P\ ∧\ Q}:}{To use a given of the form P ∧ Q:}}\label{to-use-a-given-of-the-form-p-q-1}}

\begin{ind}
Treat this as two separate givens: \texttt{P}, and \texttt{Q}.

\end{ind}

If you have a given \texttt{h\ :\ P\ ∧\ Q}, then Lean will recognize
\texttt{h.left} as a proof of \texttt{P}, and \texttt{h.right} as a
proof of \texttt{Q}.

Here's an example that illustrates these strategies. It is similar to
Example 3.4.1 in \emph{HTPI}

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Like\_Example\_3\_4\_1 (U : }\KeywordTok{Type}\NormalTok{)}
\NormalTok{    (A B C D : Set U) (h1 : A ⊆ B)}
\NormalTok{    (h2 : ¬∃ (c : U), c ∈ C ∩ D) :}
\NormalTok{    A ∩ C ⊆ B \textbackslash{} D := }\KeywordTok{by}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C D }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: A ⊆ B}
\InformationTok{h2 }\NormalTok{: ¬∃ (c : U), c ∈ C ∩ D}
\NormalTok{⊢ A ∩ C ⊆ B \textbackslash{} D}
\end{Highlighting}
\end{Shaded}

\end{outpt}

The \texttt{define} tactic will rewrite the goal as
\texttt{∀\ ⦃a\ :\ U⦄,\ a\ ∈\ A\ ∩\ C\ →\ a\ ∈\ B\ \textbackslash{}\ D},
and then we can introduce an arbitrary \texttt{x\ :\ U} and assume
\texttt{x\ ∈\ A\ ∩\ C}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Like\_Example\_3\_4\_1 (U : }\KeywordTok{Type}\NormalTok{)}
\NormalTok{    (A B C D : Set U) (h1 : A ⊆ B)}
\NormalTok{    (h2 : ¬∃ (c : U), c ∈ C ∩ D) :}
\NormalTok{    A ∩ C ⊆ B \textbackslash{} D := }\KeywordTok{by}
  \KeywordTok{define}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{assume}\NormalTok{ h3 : x ∈ A ∩ C}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C D }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: A ⊆ B}
\InformationTok{h2 }\NormalTok{: ¬∃ (c : U), c ∈ C ∩ D}
\InformationTok{x }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: x ∈ A ∩ C}
\NormalTok{⊢ x ∈ B \textbackslash{} D}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Now let's take a look at the definitions of \texttt{h3} and the goal:

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Like\_Example\_3\_4\_1 (U : }\KeywordTok{Type}\NormalTok{)}
\NormalTok{    (A B C D : Set U) (h1 : A ⊆ B)}
\NormalTok{    (h2 : ¬∃ (c : U), c ∈ C ∩ D) :}
\NormalTok{    A ∩ C ⊆ B \textbackslash{} D := }\KeywordTok{by}
  \KeywordTok{define}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{assume}\NormalTok{ h3 : x ∈ A ∩ C}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h3; }\KeywordTok{define}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C D }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: A ⊆ B}
\InformationTok{h2 }\NormalTok{: ¬∃ (c : U), c ∈ C ∩ D}
\InformationTok{x }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: x ∈ A ∧ x ∈ C}
\NormalTok{⊢ x ∈ B ∧ ¬x ∈ D}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Since the goal is now a conjunction, we apply the strategy above by
using the tactic \texttt{apply\ And.intro}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Like\_Example\_3\_4\_1 (U : }\KeywordTok{Type}\NormalTok{)}
\NormalTok{    (A B C D : Set U) (h1 : A ⊆ B)}
\NormalTok{    (h2 : ¬∃ (c : U), c ∈ C ∩ D) :}
\NormalTok{    A ∩ C ⊆ B \textbackslash{} D := }\KeywordTok{by}
  \KeywordTok{define}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{assume}\NormalTok{ h3 : x ∈ A ∩ C}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h3; }\KeywordTok{define}
  \KeywordTok{apply}\NormalTok{ And.intro}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ left}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C D }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: A ⊆ B}
\InformationTok{h2 }\NormalTok{: ¬∃ (c : U), c ∈ C ∩ D}
\InformationTok{x }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: x ∈ A ∧ x ∈ C}
\NormalTok{⊢ x ∈ B}
\RegionMarkerTok{case}\NormalTok{ right}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C D }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: A ⊆ B}
\InformationTok{h2 }\NormalTok{: ¬∃ (c : U), c ∈ C ∩ D}
\InformationTok{x }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: x ∈ A ∧ x ∈ C}
\NormalTok{⊢ ¬x ∈ D}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Look carefully at the tactic state. Lean has listed \emph{two} goals,
one after the other, and it has helpfully labeled them ``case left'' and
``case right,'' indicating that the first goal is to prove the left side
of the conjunction and the second is to prove the right. The given
information in both cases is the same, but in the first case the goal is
\texttt{x\ ∈\ B}, and in the second it is \texttt{¬x\ ∈\ D}. At this
point, if we simply continue with the proof, Lean will interpret our
tactics as applying to the first goal, until we achieve that goal. Once
we achieve it, Lean will move on to the second goal.

However, we can make our proof more readable by separating and labeling
the proofs of the two goals. To do this, we type a bullet (which looks
like this: \texttt{·}) and then a comment describing the first goal. (To
type a bullet, type \texttt{\textbackslash{}.}---that is,
backslash--period.) The proof of the first goal will appear below this
line, indented further and ending with \texttt{done}. To prepare for
this, we leave a blank line, type tab to increase the indenting, and
then type \texttt{done}. Then we do the same for the second goal: on the
next line, we return to the previous level of indenting and type a
bullet and a comment describing the second goal. We follow this with a
blank line and then an indented \texttt{done} to indicate the end of the
proof of the second goal. We're going to work on the first goal first,
so we click on the first blank line to position the cursor there. The
screen now looks like this:

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Like\_Example\_3\_4\_1 (U : }\KeywordTok{Type}\NormalTok{)}
\NormalTok{    (A B C D : Set U) (h1 : A ⊆ B)}
\NormalTok{    (h2 : ¬∃ (c : U), c ∈ C ∩ D) :}
\NormalTok{    A ∩ C ⊆ B \textbackslash{} D := }\KeywordTok{by}
  \KeywordTok{define}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{assume}\NormalTok{ h3 : x ∈ A ∩ C}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h3; }\KeywordTok{define}
  \KeywordTok{apply}\NormalTok{ And.intro}
\NormalTok{  · }\CommentTok{{-}{-} Proof that x ∈ B}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\NormalTok{  · }\CommentTok{{-}{-} Proof that ¬x ∈ D}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ left}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C D }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: A ⊆ B}
\InformationTok{h2 }\NormalTok{: ¬∃ (c : U), c ∈ C ∩ D}
\InformationTok{x }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: x ∈ A ∧ x ∈ C}
\NormalTok{⊢ x ∈ B}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Of course, there are red squiggles under both new occurrences of
\texttt{done}, since neither goal has yet been achieved. We can work on
the goals in either order by positioning the cursor on either blank
line, and the Infoview pane will show the tactic state for the goal at
the position of the cursor. In the display above, we have positioned the
cursor on the first blank line, so the Infoview shows the tactic state
for the first goal.

This first goal is easy: We have \texttt{h1\ :\ A\ ⊆\ B} and, as
explained above, \texttt{h3.left\ :\ x\ ∈\ A}. As we have seen in
several previous examples, the tactic \texttt{define\ at\ h1} will
rewrite \texttt{h1} as \texttt{∀\ ⦃a\ :\ U⦄,\ a\ ∈\ A\ →\ a\ ∈\ B}, and
then \texttt{h1\ h3.left} will be a proof of \texttt{x\ ∈\ B}. And now
we'll let you in on a little secret: usually the \texttt{define} tactic
isn't really necessary. \emph{You} may find the \texttt{define} tactic
to be useful in many situations, because it helps you see what a
statement means. But \emph{Lean} doesn't need to be told to work out
what the statement means; it will do that automatically. So we can skip
the define tactic and just give \texttt{h1\ h3.left} as a proof of
\texttt{x\ ∈\ B}. In general, if you have \texttt{h1\ :\ A\ ⊆\ B} and
\texttt{h2\ :\ x\ ∈\ A}, then Lean will recognize \texttt{h1\ h2} as a
proof of \texttt{x\ ∈\ B}. Thus, the tactic
\texttt{show\ x\ ∈\ B\ from\ h1\ h3.left} will complete the first goal.
Once we type this (indented to the same position as the \texttt{done}
for the first goal), the red squiggle disappears from the first
\texttt{done}, and the tactic state shows the \texttt{No\ goals}
message. If we then click on the blank line for the second goal, the
Infoview pane shows the tactic state for that goal:

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Like\_Example\_3\_4\_1 (U : }\KeywordTok{Type}\NormalTok{)}
\NormalTok{    (A B C D : Set U) (h1 : A ⊆ B)}
\NormalTok{    (h2 : ¬∃ (c : U), c ∈ C ∩ D) :}
\NormalTok{    A ∩ C ⊆ B \textbackslash{} D := }\KeywordTok{by}
  \KeywordTok{define}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{assume}\NormalTok{ h3 : x ∈ A ∩ C}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h3; }\KeywordTok{define}
  \KeywordTok{apply}\NormalTok{ And.intro}
\NormalTok{  · }\CommentTok{{-}{-} Proof that x ∈ B:}
    \KeywordTok{show}\NormalTok{ x ∈ B }\KeywordTok{from}\NormalTok{ h1 h3.left}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Proof that ¬x ∈ D}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ right}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C D }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: A ⊆ B}
\InformationTok{h2 }\NormalTok{: ¬∃ (c : U), c ∈ C ∩ D}
\InformationTok{x }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: x ∈ A ∧ x ∈ C}
\NormalTok{⊢ ¬x ∈ D}
\end{Highlighting}
\end{Shaded}

\end{outpt}

The second goal is a negative statement, and the given \texttt{h2} is
also a negative statement. This suggests using proof by contradiction,
and achieving the contradiction by contradicting \texttt{h2}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Like\_Example\_3\_4\_1 (U : }\KeywordTok{Type}\NormalTok{)}
\NormalTok{    (A B C D : Set U) (h1 : A ⊆ B)}
\NormalTok{    (h2 : ¬∃ (c : U), c ∈ C ∩ D) :}
\NormalTok{    A ∩ C ⊆ B \textbackslash{} D := }\KeywordTok{by}
  \KeywordTok{define}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{assume}\NormalTok{ h3 : x ∈ A ∩ C}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h3; }\KeywordTok{define}
  \KeywordTok{apply}\NormalTok{ And.intro}
\NormalTok{  · }\CommentTok{{-}{-} Proof that x ∈ B.}
    \KeywordTok{show}\NormalTok{ x ∈ B }\KeywordTok{from}\NormalTok{ h1 h3.left}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Proof that ¬x ∈ D.}
    \KeywordTok{contradict}\NormalTok{ h2 }\KeywordTok{with}\NormalTok{ h4}
    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ right}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C D }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: A ⊆ B}
\InformationTok{h2 }\NormalTok{: ¬∃ (c : U), c ∈ C ∩ D}
\InformationTok{x }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: x ∈ A ∧ x ∈ C}
\InformationTok{h4 }\NormalTok{: x ∈ D}
\NormalTok{⊢ ∃ (c : U), c ∈ C ∩ D}
\end{Highlighting}
\end{Shaded}

\end{outpt}

The goal is now an existential statement, and looking at \texttt{h3} and
\texttt{h4} it is clear that the right value to plug in for \texttt{c}
in the goal is \texttt{x}. The tactic \texttt{apply\ Exists.intro\ x}
will change the goal to \texttt{x\ ∈\ C\ ∩\ D} (we have again left off
the unnecessary blank at the end of the \texttt{apply} tactic).

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Like\_Example\_3\_4\_1 (U : }\KeywordTok{Type}\NormalTok{)}
\NormalTok{    (A B C D : Set U) (h1 : A ⊆ B)}
\NormalTok{    (h2 : ¬∃ (c : U), c ∈ C ∩ D) :}
\NormalTok{    A ∩ C ⊆ B \textbackslash{} D := }\KeywordTok{by}
  \KeywordTok{define}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{assume}\NormalTok{ h3 : x ∈ A ∩ C}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h3; }\KeywordTok{define}
  \KeywordTok{apply}\NormalTok{ And.intro}
\NormalTok{  · }\CommentTok{{-}{-} Proof that x ∈ B.}
    \KeywordTok{show}\NormalTok{ x ∈ B }\KeywordTok{from}\NormalTok{ h1 h3.left}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Proof that ¬x ∈ D.}
    \KeywordTok{contradict}\NormalTok{ h2 }\KeywordTok{with}\NormalTok{ h4}
    \KeywordTok{apply}\NormalTok{ Exists.intro x}
    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ right}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C D }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: A ⊆ B}
\InformationTok{h2 }\NormalTok{: ¬∃ (c : U), c ∈ C ∩ D}
\InformationTok{x }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: x ∈ A ∧ x ∈ C}
\InformationTok{h4 }\NormalTok{: x ∈ D}
\NormalTok{⊢ x ∈ C ∩ D}
\end{Highlighting}
\end{Shaded}

\end{outpt}

The \texttt{define} tactic would now rewrite the goal as
\texttt{x\ ∈\ C\ ∧\ x\ ∈\ D}, and we could prove this goal by combining
\texttt{h3.right} and \texttt{h4}, using the \texttt{And.intro} rule.
But since we know what the result of the \texttt{define} tactic will be,
there is really no need to use it. We can just use \texttt{And.intro}
right away to complete the proof.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Like\_Example\_3\_4\_1 (U : }\KeywordTok{Type}\NormalTok{)}
\NormalTok{    (A B C D : Set U) (h1 : A ⊆ B)}
\NormalTok{    (h2 : ¬∃ (c : U), c ∈ C ∩ D) :}
\NormalTok{    A ∩ C ⊆ B \textbackslash{} D := }\KeywordTok{by}
  \KeywordTok{define}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{assume}\NormalTok{ h3 : x ∈ A ∩ C}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h3; }\KeywordTok{define}
  \KeywordTok{apply}\NormalTok{ And.intro}
\NormalTok{  · }\CommentTok{{-}{-} Proof that x ∈ B.}
    \KeywordTok{show}\NormalTok{ x ∈ B }\KeywordTok{from}\NormalTok{ h1 h3.left}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Proof that ¬x ∈ D.}
    \KeywordTok{contradict}\NormalTok{ h2 }\KeywordTok{with}\NormalTok{ h4}
    \KeywordTok{apply}\NormalTok{ Exists.intro x}
    \KeywordTok{show}\NormalTok{ x ∈ C ∩ D }\KeywordTok{from}\NormalTok{ And.intro h3.right h4}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialStringTok{No}\InformationTok{ }\SpecialStringTok{goals}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Since \texttt{P\ ↔\ Q} is shorthand for
\texttt{(P\ →\ Q)\ ∧\ (Q\ →\ P)}, the strategies given above for
conjunctions lead immediately to the following strategies for
biconditionals (\emph{HTPI} p.~132):

\hypertarget{to-prove-a-goal-of-the-form-p-q-2}{%
\subsubsection{\texorpdfstring{To prove a goal of the form
\texttt{P\ ↔\ Q}:}{To prove a goal of the form P ↔ Q:}}\label{to-prove-a-goal-of-the-form-p-q-2}}

\begin{ind}
Prove \texttt{P\ →\ Q} and \texttt{Q\ →\ P} separately.

\end{ind}

\hypertarget{to-use-a-given-of-the-form-p-q-2}{%
\subsubsection{\texorpdfstring{To use a given of the form
\texttt{P\ ↔\ Q}:}{To use a given of the form P ↔ Q:}}\label{to-use-a-given-of-the-form-p-q-2}}

\begin{ind}
Treat this as two separate givens: \texttt{P\ →\ Q}, and
\texttt{Q\ →\ P}.

\end{ind}

The methods for using these strategies in Lean are similar to those we
used above for conjunctions. If we have \texttt{h1\ :\ P\ →\ Q} and
\texttt{h2\ :\ Q\ →\ P}, then \texttt{Iff.intro\ h1\ h2} is a proof of
\texttt{P\ ↔\ Q}. Thus, if the goal is \texttt{P\ ↔\ Q}, then the tactic
\texttt{apply\ Iff.intro\ \_\ \_} will convert this into two separate
goals, \texttt{P\ →\ Q} and \texttt{Q\ →\ P}. Once again, you can fill
in one of these blanks if you already have a proof of either
\texttt{P\ →\ Q} or \texttt{Q\ →\ P}, and you can leave out any blanks
at the end of the tactic. If you have a given \texttt{h\ :\ P\ ↔\ Q},
then \texttt{h.ltr} is a proof of the left-to-right direction of the
biconditional, \texttt{P\ →\ Q}, and \texttt{h.rtl} is a proof of the
right-to-left direction, \texttt{Q\ →\ P}.

Let's try these strategies out in an example.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (P Q : Pred U)}
\NormalTok{    (h1 : ∀ (x : U), P x ↔ Q x) :}
\NormalTok{    (∃ (x : U), P x) ↔ ∃ (x : U), Q x := }\KeywordTok{by}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{P Q }\NormalTok{: Pred U}
\InformationTok{h1 }\NormalTok{: ∀ (x : U), P x ↔ Q x}
\NormalTok{⊢ (∃ (x : U), P x) ↔}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  ∃ (x : U), Q x}
\end{Highlighting}
\end{Shaded}

\end{outpt}

The goal is a biconditional statement, so we begin with the tactic
\texttt{apply\ Iff.intro}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (P Q : Pred U)}
\NormalTok{    (h1 : ∀ (x : U), P x ↔ Q x) :}
\NormalTok{    (∃ (x : U), P x) ↔ ∃ (x : U), Q x := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ mp}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{P Q }\NormalTok{: Pred U}
\InformationTok{h1 }\NormalTok{: ∀ (x : U), P x ↔ Q x}
\NormalTok{⊢ (∃ (x : U), P x) →}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  ∃ (x : U), Q x}
\RegionMarkerTok{case}\NormalTok{ mpr}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{P Q }\NormalTok{: Pred U}
\InformationTok{h1 }\NormalTok{: ∀ (x : U), P x ↔ Q x}
\NormalTok{⊢ (∃ (x : U), Q x) →}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  ∃ (x : U), P x}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Once again, we have two goals. (The case labels this time aren't very
intuitive; ``mp'' stands for ``modus ponens'' and ``mpr'' stands for
``modus ponens reverse''.) Whenever we have multiple goals, we'll use
the bulleted-and-indented style introduced in the last example. As in
\emph{HTPI}, we'll label the proofs of the two goals with \texttt{(→)}
and \texttt{(←)}, representing the two directions of the biconditional
symbol \texttt{↔}. (You can type \texttt{←} in VS Code by typing
\texttt{\textbackslash{}l}, short for ``left''.) The first goal is a
conditional statement, so we assume the antecedent.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (P Q : Pred U)}
\NormalTok{    (h1 : ∀ (x : U), P x ↔ Q x) :}
\NormalTok{    (∃ (x : U), P x) ↔ ∃ (x : U), Q x := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h2 : ∃ (x : U), P x}
    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\NormalTok{  · }\CommentTok{{-}{-} (←)}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ mp}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{P Q }\NormalTok{: Pred U}
\InformationTok{h1 }\NormalTok{: ∀ (x : U), P x ↔ Q x}
\InformationTok{h2 }\NormalTok{: ∃ (x : U), P x}
\NormalTok{⊢ ∃ (x : U), Q x}
\end{Highlighting}
\end{Shaded}

\end{outpt}

As usual, when we have an existential given, we use it right away.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (P Q : Pred U)}
\NormalTok{    (h1 : ∀ (x : U), P x ↔ Q x) :}
\NormalTok{    (∃ (x : U), P x) ↔ ∃ (x : U), Q x := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h2 : ∃ (x : U), P x}
    \KeywordTok{obtain}\NormalTok{ (u : U) (h3 : P u) }\KeywordTok{from}\NormalTok{ h2}
    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\NormalTok{  · }\CommentTok{{-}{-} (←)}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ mp}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{P Q }\NormalTok{: Pred U}
\InformationTok{h1 }\NormalTok{: ∀ (x : U), P x ↔ Q x}
\InformationTok{h2 }\NormalTok{: ∃ (x : U), P x}
\InformationTok{u }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: P u}
\NormalTok{⊢ ∃ (x : U), Q x}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Now that we have an object of type \texttt{U} in the tactic state, we
can use \texttt{h1} by applying universal instantiation.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (P Q : Pred U)}
\NormalTok{    (h1 : ∀ (x : U), P x ↔ Q x) :}
\NormalTok{    (∃ (x : U), P x) ↔ ∃ (x : U), Q x := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h2 : ∃ (x : U), P x}
    \KeywordTok{obtain}\NormalTok{ (u : U) (h3 : P u) }\KeywordTok{from}\NormalTok{ h2}
    \KeywordTok{have}\NormalTok{ h4 : P u ↔ Q u := h1 u}
    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\NormalTok{  · }\CommentTok{{-}{-} (←)}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ mp}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{P Q }\NormalTok{: Pred U}
\InformationTok{h1 }\NormalTok{: ∀ (x : U), P x ↔ Q x}
\InformationTok{h2 }\NormalTok{: ∃ (x : U), P x}
\InformationTok{u }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: P u}
\InformationTok{h4 }\NormalTok{: P u ↔ Q u}
\NormalTok{⊢ ∃ (x : U), Q x}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Looking at \texttt{h3} and \texttt{h4}, we can now see that we will be
able to complete the proof if we assign the value \texttt{u} to
\texttt{x} in the goal. So our next step is the tactic
\texttt{apply\ Exists.intro\ u}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (P Q : Pred U)}
\NormalTok{    (h1 : ∀ (x : U), P x ↔ Q x) :}
\NormalTok{    (∃ (x : U), P x) ↔ ∃ (x : U), Q x := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h2 : ∃ (x : U), P x}
    \KeywordTok{obtain}\NormalTok{ (u : U) (h3 : P u) }\KeywordTok{from}\NormalTok{ h2}
    \KeywordTok{have}\NormalTok{ h4 : P u ↔ Q u := h1 u}
    \KeywordTok{apply}\NormalTok{ Exists.intro u}
    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\NormalTok{  · }\CommentTok{{-}{-} (←)}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ mp}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{P Q }\NormalTok{: Pred U}
\InformationTok{h1 }\NormalTok{: ∀ (x : U), P x ↔ Q x}
\InformationTok{h2 }\NormalTok{: ∃ (x : U), P x}
\InformationTok{u }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: P u}
\InformationTok{h4 }\NormalTok{: P u ↔ Q u}
\NormalTok{⊢ Q u}
\end{Highlighting}
\end{Shaded}

\end{outpt}

To complete the proof, we use the left-to-right direction of
\texttt{h4}. We have \texttt{h4.ltr\ :\ P\ u\ →\ Q\ u} and
\texttt{h3\ :\ P\ u}, so by modus ponens, \texttt{h4.ltr\ h3} proves the
goal \texttt{Q\ u}. Once we enter this step, Lean indicates that the
left-to-right proof is complete, and we can position the cursor below
the right-to-left bullet to see the tactic state for the second half of
the proof.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (P Q : Pred U)}
\NormalTok{    (h1 : ∀ (x : U), P x ↔ Q x) :}
\NormalTok{    (∃ (x : U), P x) ↔ ∃ (x : U), Q x := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h2 : ∃ (x : U), P x}
    \KeywordTok{obtain}\NormalTok{ (u : U) (h3 : P u) }\KeywordTok{from}\NormalTok{ h2}
    \KeywordTok{have}\NormalTok{ h4 : P u ↔ Q u := h1 u}
    \KeywordTok{apply}\NormalTok{ Exists.intro u}
    \KeywordTok{show}\NormalTok{ Q u }\KeywordTok{from}\NormalTok{ h4.ltr h3}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} (←)}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ mpr}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{P Q }\NormalTok{: Pred U}
\InformationTok{h1 }\NormalTok{: ∀ (x : U), P x ↔ Q x}
\NormalTok{⊢ (∃ (x : U), Q x) →}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  ∃ (x : U), P x}
\end{Highlighting}
\end{Shaded}

\end{outpt}

The second half of the proof is similar to the first. We begin by
assuming \texttt{h2\ :\ ∃\ (x\ :\ U),\ Q\ x}, and then we use that
assumption to obtain \texttt{u\ :\ U} and \texttt{h3\ :\ Q\ u}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (P Q : Pred U)}
\NormalTok{    (h1 : ∀ (x : U), P x ↔ Q x) :}
\NormalTok{    (∃ (x : U), P x) ↔ ∃ (x : U), Q x := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h2 : ∃ (x : U), P x}
    \KeywordTok{obtain}\NormalTok{ (u : U) (h3 : P u) }\KeywordTok{from}\NormalTok{ h2}
    \KeywordTok{have}\NormalTok{ h4 : P u ↔ Q u := h1 u}
    \KeywordTok{apply}\NormalTok{ Exists.intro u}
    \KeywordTok{show}\NormalTok{ Q u }\KeywordTok{from}\NormalTok{ h4.ltr h3}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} (←)}
    \KeywordTok{assume}\NormalTok{ h2 : ∃ (x : U), Q x}
    \KeywordTok{obtain}\NormalTok{ (u : U) (h3 : Q u) }\KeywordTok{from}\NormalTok{ h2}
    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ mpr}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{P Q }\NormalTok{: Pred U}
\InformationTok{h1 }\NormalTok{: ∀ (x : U), P x ↔ Q x}
\InformationTok{h2 }\NormalTok{: ∃ (x : U), Q x}
\InformationTok{u }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: Q u}
\NormalTok{⊢ ∃ (x : U), P x}
\end{Highlighting}
\end{Shaded}

\end{outpt}

We can actually shorten the proof by packing a lot into a single step.
See if you can figure out the last line of the completed proof below;
we'll give an explanation after the proof.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (P Q : Pred U)}
\NormalTok{    (h1 : ∀ (x : U), P x ↔ Q x) :}
\NormalTok{    (∃ (x : U), P x) ↔ ∃ (x : U), Q x := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h2 : ∃ (x : U), P x}
    \KeywordTok{obtain}\NormalTok{ (u : U) (h3 : P u) }\KeywordTok{from}\NormalTok{ h2}
    \KeywordTok{have}\NormalTok{ h4 : P u ↔ Q u := h1 u}
    \KeywordTok{apply}\NormalTok{ Exists.intro u}
    \KeywordTok{show}\NormalTok{ Q u }\KeywordTok{from}\NormalTok{ h4.ltr h3}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} (←)}
    \KeywordTok{assume}\NormalTok{ h2 : ∃ (x : U), Q x}
    \KeywordTok{obtain}\NormalTok{ (u : U) (h3 : Q u) }\KeywordTok{from}\NormalTok{ h2}
    \KeywordTok{show}\NormalTok{ ∃ (x : U), P x }\KeywordTok{from}\NormalTok{ Exists.intro u ((h1 u).rtl h3)}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

To understand the last step, start with the fact that \texttt{h1\ u} is
a proof of \texttt{P\ u\ ↔\ Q\ u}. Therefore \texttt{(h1\ u).rtl} is a
proof of \texttt{Q\ u\ →\ P\ u}, so by modus ponens,
\texttt{(h1\ u).rtl\ h3} is a proof of \texttt{P\ u}. It follows that
\texttt{Exists.intro\ u\ ((h1\ u).rtl\ h3)} is a proof of
\texttt{∃\ (x\ :\ U),\ P\ x}, which was the goal.

There is one more style of reasoning that is sometimes used in proofs of
biconditional statements. It is illustrated in Example 3.4.5 of
\emph{HTPI}. Here is that theorem, as it is presented in \emph{HTPI}
(\emph{HTPI} p.~137).

\begin{thm}
Suppose \(A\), \(B\), and \(C\) are sets. Then
\(A \cap (B \setmin C) = (A \cap B) \setmin C\).

\end{thm}

\begin{proof}

Let \(x\) be arbitrary. Then \begin{align*}
x \in A \cap (B \setmin C) &\text{ iff } x \in A \wedge x \in B \setmin C\\
&\text{ iff } x \in A \wedge x \in B \wedge x \notin C\\
&\text{ iff } x \in (A \cap B) \wedge x \notin C\\
&\text{ iff } x \in (A \cap B) \setmin C.
\end{align*} Thus,
\(\forall x(x \in A \cap (B \setmin C) \leftrightarrow x \in (A \cap B) \setmin C)\),
so \(A \cap (B \setmin C) = (A \cap B) \setmin C\). \excl{~□}\qedhere

\end{proof}

This proof is based on a fundamental principle of set theory that says
that if two sets have exactly the same elements, then they are equal.
This principle is called the \emph{axiom of extensionality}, and it is
what justifies the inference, in the last sentence, from
\(\forall x(x \in A \cap (B \setmin C) \leftrightarrow x \in (A \cap B) \setmin C)\)
to \(A \cap (B \setmin C) = (A \cap B) \setmin C\).

The heart of the proof is a string of equivalences that, taken together,
establish the biconditional statement
\(x \in A \cap (B \setmin C) \leftrightarrow x \in (A \cap B) \setmin C\).
One can also use this technique to prove a biconditional statement in
Lean. This time we'll simply present the complete proof first, and then
explain it afterwards.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_4\_5 (U : }\KeywordTok{Type}\NormalTok{)}
\NormalTok{    (A B C : Set U) : A ∩ (B \textbackslash{} C) = (A ∩ B) \textbackslash{} C := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Set.ext}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{show}\NormalTok{ x ∈ A ∩ (B \textbackslash{} C) ↔ x ∈ (A ∩ B) \textbackslash{} C }\KeywordTok{from}
    \KeywordTok{calc}\NormalTok{ x ∈ A ∩ (B \textbackslash{} C)}
\NormalTok{      \_ ↔ x ∈ A ∧ (x ∈ B ∧ x ∉ C) := Iff.refl \_}
\NormalTok{      \_ ↔ (x ∈ A ∧ x ∈ B) ∧ x ∉ C := and\_assoc.symm}
\NormalTok{      \_ ↔ x ∈ (A ∩ B) \textbackslash{} C := Iff.refl \_}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

The name of the axiom of extensionality in Lean is \texttt{Set.ext}, and
it is applied in the first step of the Lean proof. As usual, the
\texttt{apply} tactic works backwards from the goal. In other words,
after the first line of the proof, the goal is
\texttt{∀\ (x\ :\ U),\ x\ ∈\ A\ ∩\ (B\ \textbackslash{}\ C)\ ↔\ x\ ∈\ (A\ ∩\ B)\ \textbackslash{}\ C},
because by \texttt{Set.ext}, the conclusion of the theorem would follow
from this statement. The rest of the proof then proves this goal by
introducing an arbitrary \texttt{x} of type \texttt{U} and then proving
the biconditional by stringing together several equivalences, exactly as
in the \emph{HTPI} proof.

The proof of the biconditional is called a \emph{calculational proof},
and it is introduced by the keyword \texttt{calc}. The calculational
proof consists of a string of biconditional statements, each of which is
provided with a proof. You can think of the underscore on the left side
of each biconditional as standing for the right side of the previous
biconditional (or, in the case of the first biconditional, the statement
after \texttt{calc}).

The proofs of the individual biconditionals in the calculational proof
require some explanation. Lean has a large library of theorems that it
knows, and you can use those theorems in your proofs. In particular,
\texttt{Iff.refl} and \texttt{and\_assoc} are names of theorems in
Lean's library. You can find out what any theorem says by using the Lean
command \texttt{\#check}. (Commands that ask Lean for a response
generally start with the character \texttt{\#}.) If you type
\texttt{\#check\ Iff.refl} in a Lean file, you will see Lean's response
in the Infoview pane: \texttt{Iff.refl\ (a\ :\ Prop)\ :\ a\ ↔\ a}. What
this tells us is that Lean already knows the theorem

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Iff.refl (a : }\KeywordTok{Prop}\NormalTok{) : a ↔ a}
\end{Highlighting}
\end{Shaded}

(This theorem says that ``iff'' has a property called
\emph{reflexivity}; we'll discuss reflexivity in Chapter 4.) When
variables are declared in the statement of a theorem, it is understood
that they can stand for anything of the appropriate type (see Section
3.1 of \emph{HTPI}). Thus, the theorem \texttt{Iff.refl} can be thought
of as establishing the truth of the statement
\texttt{∀\ (a\ :\ Prop),\ a\ ↔\ a}. In fact, you can get Lean to report
the meaning of the theorem in this form with the command
\texttt{\#check\ @Iff.refl}. What this means is that, in any proof, Lean
lets you treat \texttt{Iff.refl} as a proof of the statement
\texttt{∀\ (a\ :\ Prop),\ a\ ↔\ a}. Thus, by universal instantiation,
for any proposition \texttt{a}, Lean will recognize \texttt{Iff.refl\ a}
as a proof of \texttt{a\ ↔\ a}. This is used to justify the first
biconditional in the calculational proof.

But wait! The first biconditional in the calculational proof is
\texttt{x\ ∈\ A\ ∩\ (B\ \textbackslash{}\ C)\ ↔\ x\ ∈\ A\ ∧\ (x\ ∈\ B\ ∧\ x\ ∉\ C)},
which does not have the form \texttt{a\ ↔\ a}. How can it be justified
by the theorem \texttt{Iff.refl}? Recall that Lean doesn't need to be
told to write out definitions of mathematical notation; it does that
automatically. When the definitions of the set theory notation are
written out, the first biconditional in the calculational proof becomes
\texttt{x\ ∈\ A\ ∧\ (x\ ∈\ B\ ∧\ x\ ∉\ C)\ ↔\ x\ ∈\ A\ ∧\ (x\ ∈\ B\ ∧\ x\ ∉\ C)},
which \emph{does} have the form \texttt{a\ ↔\ a}, so it can be proven
with the term-mode proof \texttt{Iff.refl\ \_}. Note that we are using
an underscore here to ask Lean to figure out what to plug in for
\texttt{a}. This saves us the trouble of writing out the full term-mode
proof, which would be
\texttt{Iff.refl\ (x\ ∈\ A\ ∧\ (x\ ∈\ B\ ∧\ x\ ∉\ C))}. The lesson of
this example is that the theorem \texttt{Iff.refl} is more powerful than
it looks. Not only can we use \texttt{Iff.refl\ \_} to prove statements
of the form \texttt{a\ ↔\ a}, we can also use it to prove statements of
the form \texttt{a\ ↔\ a\textquotesingle{}}, if \texttt{a} and
\texttt{a\textquotesingle{}} reduce to the same thing when definitions
are filled in. We say in this case that \texttt{a} and
\texttt{a\textquotesingle{}} are \emph{definitionally equal}. This
explains the third line of the calculational proof, which is also
justified by the proof \texttt{Iff.refl\ \_}.

The second line uses the theorem \texttt{and\_assoc}. If you type
\texttt{\#check\ and\_assoc}, you will get this response from Lean:

\begin{ind}

\begin{verbatim}
and_assoc {a b c : Prop} : (a ∧ b) ∧ c ↔ a ∧ b ∧ c
\end{verbatim}

\end{ind}

Once again, it is understood that the variables \texttt{a}, \texttt{b},
and \texttt{c} can stand for any propositions, as you can see by giving
the command \texttt{\#check\ @and\_assoc}. This generates the response

\begin{ind}

\begin{verbatim}
@and_assoc : ∀ {a b c : Prop}, (a ∧ b) ∧ c ↔ a ∧ b ∧ c
\end{verbatim}

\end{ind}

which is shorthand for

\begin{ind}

\begin{verbatim}
@and_assoc : ∀ {a : Prop}, ∀ {b : Prop}, ∀ {c : Prop},
              (a ∧ b) ∧ c ↔ a ∧ (b ∧ c)
\end{verbatim}

\end{ind}

Recall that the curly braces indicate that \texttt{a}, \texttt{b}, and
\texttt{c} are implicit arguments, and that Lean groups the logical
connectives to the right, which means that it interprets
\texttt{a\ ∧\ b\ ∧\ c} as \texttt{a\ ∧\ (b\ ∧\ c)}. This is the
associative law for ``and'' (see Section 1.2 of \emph{HTPI}). Since
\texttt{a}, \texttt{b}, and \texttt{c} are implicit, Lean will recognize
\texttt{and\_assoc} as a proof of any statement of the form
\texttt{(a\ ∧\ b)\ ∧\ c\ ↔\ a\ ∧\ (b\ ∧\ c)}, where \texttt{a},
\texttt{b}, and \texttt{c} can be replaced with any propositions. Lean
doesn't need to be told what propositions are being used as \texttt{a},
\texttt{b}, and \texttt{c}; it will figure that out for itself.
Unfortunately, the second biconditional in the calculational proof is
\texttt{x\ ∈\ A\ ∧\ (x\ ∈\ B\ ∧\ x\ ∉\ C)\ ↔\ (x\ ∈\ A\ ∧\ x\ ∈\ B)\ ∧\ x\ ∉\ C},
which has the form \texttt{a\ ∧\ (b\ ∧\ c)\ ↔\ (a\ ∧\ b)\ ∧\ c}, not
\texttt{(a\ ∧\ b)\ ∧\ c\ ↔\ a\ ∧\ (b\ ∧\ c)}. (Notice that the first of
these biconditionals is the same as the second except that the left and
right sides have been swapped.) To account for this discrepancy, we use
the fact that if \texttt{h} is a proof of any biconditional
\texttt{P\ ↔\ Q}, then \texttt{h.symm} is a proof of \texttt{Q\ ↔\ P}.
Thus \texttt{and\_assoc.symm} proves the second biconditional in the
calculational proof. (By the way, the \emph{HTPI} proof avoids any
mention of the associativity of ``and'' by simply leaving out
parentheses in the conjunction
\(x \in A \wedge x \in B \wedge x \notin C\). As explained in Section
1.2 of \emph{HTPI}, this represents an implicit use of the associativity
of ``and.'')

You can get a better understanding of the first step of our last proof
by typing \texttt{\#check\ @Set.ext}. The result is

\begin{ind}

\begin{verbatim}
@Set.ext : ∀ {α : Type u_1} {a b : Set α},
            (∀ (x : α), x ∈ a ↔ x ∈ b) → a = b
\end{verbatim}

\end{ind}

which is shorthand for

\begin{ind}

\begin{verbatim}
@Set.ext : ∀ {α : Type u_1}, ∀ {a : Set α}, ∀ {b : Set α},
            (∀ (x : α), x ∈ a ↔ x ∈ b) → a = b
\end{verbatim}

\end{ind}

Ignoring the \texttt{u\_1}, whose significance won't be important to us,
this means that \texttt{Set.ext} can be used to prove any statement of
the form \texttt{(∀\ (x\ :\ α),\ x\ ∈\ a\ ↔\ x\ ∈\ b)\ →\ a\ =\ b},
where \texttt{α} can be replaced by any type and \texttt{a} and
\texttt{b} can be replaced by any sets of objects of type \texttt{α}.
Make sure you understand how this explains the effect of the tactic
\texttt{apply\ Set.ext} in the first step of our last proof. Almost all
of our proofs that two sets are equal will start with
\texttt{apply\ Set.ext}.

Notice that in Lean's responses to both \texttt{\#check\ @and\_assoc}
and \texttt{\#check\ @Set.ext}, multiple universal quantifiers in a row
were grouped together and written as a single universal quantifier
followed by a list of variables (with types). Lean allows this
notational shorthand for any sequence of consecutive quantifiers, as
long as they are all of the same kind (all existential or all
universal), and we will use this notation from now on.

\hypertarget{exercises-2}{%
\subsection{Exercises}\label{exercises-2}}

\begin{numex}{1}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_4\_2 (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U)}
\NormalTok{    (h1 : A ⊆ B) (h2 : A ⊆ C) : A ⊆ B ∩ C := }\KeywordTok{by}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{2}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_4\_4 (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U)}
\NormalTok{    (h1 : A ⊆ B) (h2 : A ⊈ C) : B ⊈ C := }\KeywordTok{by}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{3}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_3\_16 (U : }\KeywordTok{Type}\NormalTok{) (B : Set U)}
\NormalTok{    (F : Set (Set U)) : F ⊆ 𝒫 B → ⋃₀ F ⊆ B := }\KeywordTok{by}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{4}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_3\_17 (U : }\KeywordTok{Type}\NormalTok{) (F G : Set (Set U))}
\NormalTok{    (h1 : ∀ (A : Set U), A ∈ F → ∀ (B : Set U), B ∈ G → A ⊆ B) :}
\NormalTok{    ⋃₀ F ⊆ ⋂₀ G := }\KeywordTok{by}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{5}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_4\_7 (U : }\KeywordTok{Type}\NormalTok{) (A B : Set U) :}
\NormalTok{    𝒫 (A ∩ B) = 𝒫 A ∩ 𝒫 B := }\KeywordTok{by}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{6}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_4\_17 (U : }\KeywordTok{Type}\NormalTok{) (A : Set U) : A = ⋃₀ (𝒫 A) := }\KeywordTok{by}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{7}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_4\_18a (U : }\KeywordTok{Type}\NormalTok{) (F G : Set (Set U)) :}
\NormalTok{    ⋃₀ (F ∩ G) ⊆ (⋃₀ F) ∩ (⋃₀ G) := }\KeywordTok{by}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{8}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_4\_19 (U : }\KeywordTok{Type}\NormalTok{) (F G : Set (Set U)) :}
\NormalTok{    (⋃₀ F) ∩ (⋃₀ G) ⊆ ⋃₀ (F ∩ G) ↔}
\NormalTok{      ∀ (A B : Set U), A ∈ F → B ∈ G → A ∩ B ⊆ ⋃₀ (F ∩ G) := }\KeywordTok{by}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{numex}

\hypertarget{proofs-involving-disjunctions}{%
\section{3.5. Proofs Involving
Disjunctions}\label{proofs-involving-disjunctions}}

A common proof method for dealing with givens or goals that are
disjunctions is \emph{proof by cases}. Here's how it works (\emph{HTPI}
p.~143).

\hypertarget{to-use-a-given-of-the-form-p-q-3}{%
\subsubsection{\texorpdfstring{To use a given of the form
\texttt{P\ ∨\ Q}:}{To use a given of the form P ∨ Q:}}\label{to-use-a-given-of-the-form-p-q-3}}

\begin{ind}
Break your proof into cases. For case 1, assume that \texttt{P} is true
and use this assumption to prove the goal. For case 2, assume that
\texttt{Q} is true and prove the goal.

\end{ind}

In Lean, you can break a proof into cases by using the
\texttt{by\_cases} tactic. If you have a given \texttt{h\ :\ P\ ∨\ Q},
then the tactic \texttt{by\_cases\ on\ h} will break your proof into two
cases. For the first case, the given \texttt{h} will be changed to
\texttt{h\ :\ P}, and for the second, it will be changed to
\texttt{h\ :\ Q}; the goal for both cases will be the same as the
original goal. Thus, the effect of the \texttt{by\_cases\ on\ h} tactic
is as follows:

\begin{bef}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{ ⋮}
\InformationTok{h }\NormalTok{: P ∨ Q}
\NormalTok{⊢ goal}
\end{Highlighting}
\end{Shaded}

\end{bef}

\begin{aft}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ Case\_1}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{ ⋮}
\InformationTok{h }\NormalTok{: P}
\NormalTok{⊢ goal}
\RegionMarkerTok{case}\NormalTok{ Case\_2}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{ ⋮}
\InformationTok{h }\NormalTok{: Q}
\NormalTok{⊢ goal}
\end{Highlighting}
\end{Shaded}

\end{aft}

Notice that the original given \texttt{h\ :\ P\ ∨\ Q} gets
\emph{replaced} by \texttt{h\ :\ P} in case 1 and \texttt{h\ :\ Q} in
case 2. This is usually what is most convenient, but if you write
\texttt{by\_cases\ on\ h\ with\ h1}, then the original given \texttt{h}
will be preserved, and new givens \texttt{h1\ :\ P} and
\texttt{h1\ :\ Q} will be added to cases 1 and 2, respectively. If you
want different names for the new givens in the two cases, then use
\texttt{by\_cases\ on\ h\ with\ h1,\ h2} to add the new given
\texttt{h1\ :\ P} in case 1 and \texttt{h2\ :\ Q} in case 2.

You can follow \texttt{by\_cases\ on} with any proof of a disjunction,
even if that proof is not just a single identifier. In that cases you
will want to add \texttt{with} to specify the identifier or identifiers
to be used for the new assumptions in the two cases. Another variant is
that you can use the tactic \texttt{by\_cases\ h\ :\ P} to break your
proof into two cases, with the new assumptions being \texttt{h\ :\ P} in
case 1 and \texttt{h\ :\ ¬P} in case 2. In other words, the effect of
\texttt{by\_cases\ h\ :\ P} is the same as adding the new given
\texttt{h\ :\ P\ ∨\ ¬P} (which, of course, is a tautology) and then
using the tactic \texttt{by\_cases\ on\ h}.

There are several introduction rules that you can use in Lean to prove a
goal of the form \texttt{P\ ∨\ Q}. If you have \texttt{h\ :\ P}, then
Lean will accept \texttt{Or.intro\_left\ Q\ h} as a proof of
\texttt{P\ ∨\ Q}. In most situations Lean can infer the proposition
\texttt{Q} from context, and in that case you can use the shorter form
\texttt{Or.inl\ h} as a proof of \texttt{P\ ∨\ Q}. You can see the
difference between \texttt{Or.intro\_left} and \texttt{Or.inl} by using
the \texttt{\#check} command:

\begin{ind}

\begin{verbatim}
@Or.intro_left : ∀ {a : Prop} (b : Prop), a → a ∨ b

@Or.inl : ∀ {a b : Prop}, a → a ∨ b
\end{verbatim}

\end{ind}

Notice that \texttt{b} is an implicit argument in \texttt{Or.inl}, but
not in \texttt{Or.intro\_left}.

Similarly, if you have \texttt{h\ :\ Q}, then
\texttt{Or.intro\_right\ P\ h} is a proof of \texttt{P\ ∨\ Q}. In most
situations Lean can infer \texttt{P} from context, and you can use the
shorter form \texttt{Or.inr\ h}.

Often, when your goal has the form \texttt{P\ ∨\ Q}, you will be unable
to prove \texttt{P}, and also unable to prove \texttt{Q}. Proof by cases
can help in that situation as well (\emph{HTPI} p.~145).

\hypertarget{to-prove-a-goal-of-the-form-p-q-3}{%
\subsubsection{\texorpdfstring{To prove a goal of the form
\texttt{P\ ∨\ Q}:}{To prove a goal of the form P ∨ Q:}}\label{to-prove-a-goal-of-the-form-p-q-3}}

\begin{ind}
Break your proof into cases. In each case, either prove \texttt{P} or
prove \texttt{Q}.

\end{ind}

Example 3.5.2 from \emph{HTPI} illustrates these strategies:

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_5\_2}
\NormalTok{    (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) :}
\NormalTok{    A \textbackslash{} (B \textbackslash{} C) ⊆ (A \textbackslash{} B) ∪ C := }\KeywordTok{by}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\NormalTok{⊢ A \textbackslash{} (B \textbackslash{} C) ⊆ A \textbackslash{} B ∪ C}
\end{Highlighting}
\end{Shaded}

\end{outpt}

The \texttt{define} tactic would rewrite the goal as
\texttt{∀\ ⦃a\ :\ U⦄,\ a\ ∈\ A\ \textbackslash{}\ (B\ \textbackslash{}\ C)\ →\ a\ ∈\ A\ \textbackslash{}\ B\ ∪\ C},
which suggests that our next two tactics should be \texttt{fix\ x\ :\ U}
and
\texttt{assume\ h1\ :\ x\ ∈\ A\ \textbackslash{}\ (B\ \textbackslash{}\ C)}.
But as we have seen before, if you know what the result of the
\texttt{define} tactic is going to be, then there is usually no need to
use it. After introducing \texttt{x} as an arbitrary element of
\texttt{A\ \textbackslash{}\ (B\ \textbackslash{}\ C)}, we write out the
definitions of our new given and goal to help guide our next strategy
choice:

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_5\_2}
\NormalTok{    (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) :}
\NormalTok{    A \textbackslash{} (B \textbackslash{} C) ⊆ (A \textbackslash{} B) ∪ C := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{assume}\NormalTok{ h1 : x ∈ A \textbackslash{} (B \textbackslash{} C)}
  \KeywordTok{define}\NormalTok{; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{x }\NormalTok{: U}
\InformationTok{h1 }\NormalTok{: x ∈ A ∧ ¬x ∈ B \textbackslash{} C}
\NormalTok{⊢ x ∈ A \textbackslash{} B ∨ x ∈ C}
\end{Highlighting}
\end{Shaded}

\end{outpt}

The goal is now a disjunction, which suggests that proof by cases might
be helpful. But what cases should we use? The key is to look at the
meaning of the right half of the given \texttt{h1}. The meaning of
\texttt{¬x\ ∈\ B\ \textbackslash{}\ C} is
\texttt{¬(x\ ∈\ B\ ∧\ x\ ∉\ C)}, which, by one of the De Morgan laws, is
equivalent to \texttt{x\ ∉\ B\ ∨\ x\ ∈\ C}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_5\_2}
\NormalTok{    (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) :}
\NormalTok{    A \textbackslash{} (B \textbackslash{} C) ⊆ (A \textbackslash{} B) ∪ C := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{assume}\NormalTok{ h1 : x ∈ A \textbackslash{} (B \textbackslash{} C)}
  \KeywordTok{define}\NormalTok{; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
  \KeywordTok{have}\NormalTok{ h2 : ¬x ∈ B \textbackslash{} C := h1.right}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2; }\KeywordTok{demorgan} \KeywordTok{at}\NormalTok{ h2}
            \CommentTok{{-}{-}h2 : ¬x ∈ B ∨ x ∈ C}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{x }\NormalTok{: U}
\InformationTok{h1 }\NormalTok{: x ∈ A ∧ ¬x ∈ B \textbackslash{} C}
\InformationTok{h2 }\NormalTok{: ¬x ∈ B ∨ x ∈ C}
\NormalTok{⊢ x ∈ A \textbackslash{} B ∨ x ∈ C}
\end{Highlighting}
\end{Shaded}

\end{outpt}

The new given \texttt{h2} is now a disjunction, which suggests what
cases we should use:

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_5\_2}
\NormalTok{    (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) :}
\NormalTok{    A \textbackslash{} (B \textbackslash{} C) ⊆ (A \textbackslash{} B) ∪ C := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{assume}\NormalTok{ h1 : x ∈ A \textbackslash{} (B \textbackslash{} C)}
  \KeywordTok{define}\NormalTok{; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
  \KeywordTok{have}\NormalTok{ h2 : ¬x ∈ B \textbackslash{} C := h1.right}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2; }\KeywordTok{demorgan} \KeywordTok{at}\NormalTok{ h2}
            \CommentTok{{-}{-}h2 : ¬x ∈ B ∨ x ∈ C}
  \KeywordTok{by\_cases} \KeywordTok{on}\NormalTok{ h2}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ Case\_1}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{x }\NormalTok{: U}
\InformationTok{h1 }\NormalTok{: x ∈ A ∧ ¬x ∈ B \textbackslash{} C}
\InformationTok{h2 }\NormalTok{: ¬x ∈ B}
\NormalTok{⊢ x ∈ A \textbackslash{} B ∨ x ∈ C}
\RegionMarkerTok{case}\NormalTok{ Case\_2}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{x }\NormalTok{: U}
\InformationTok{h1 }\NormalTok{: x ∈ A ∧ ¬x ∈ B \textbackslash{} C}
\InformationTok{h2 }\NormalTok{: x ∈ C}
\NormalTok{⊢ x ∈ A \textbackslash{} B ∨ x ∈ C}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Of course, now that we have two goals, we will introduce bullets
labeling the two parts of the proof as case 1 and case 2. Looking at the
givens \texttt{h1} and \texttt{h2} in both cases, it is not hard to see
that we should be able to prove \texttt{x\ ∈\ A\ \textbackslash{}\ B} in
case 1 and \texttt{x\ ∈\ C} in case 2. Thus, in case 1 we will be able
to give a proof of the goal that has the form \texttt{Or.inl\ \_}, where
the blank will be filled in with a proof of
\texttt{x\ ∈\ A\ \textbackslash{}\ B}, and in case 2 we can use
\texttt{Or.inr\ \_}, filling in the blank with a proof of
\texttt{x\ ∈\ C}. This suggests that we should use the tactics
\texttt{apply\ Or.inl} in case 1 and \texttt{apply\ Or.inr} in case 2.
Focusing first on case 1, we get:

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_5\_2}
\NormalTok{    (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) :}
\NormalTok{    A \textbackslash{} (B \textbackslash{} C) ⊆ (A \textbackslash{} B) ∪ C := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{assume}\NormalTok{ h1 : x ∈ A \textbackslash{} (B \textbackslash{} C)}
  \KeywordTok{define}\NormalTok{; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
  \KeywordTok{have}\NormalTok{ h2 : ¬x ∈ B \textbackslash{} C := h1.right}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2; }\KeywordTok{demorgan} \KeywordTok{at}\NormalTok{ h2}
            \CommentTok{{-}{-}h2 : ¬x ∈ B ∨ x ∈ C}
  \KeywordTok{by\_cases} \KeywordTok{on}\NormalTok{ h2}
\NormalTok{  · }\CommentTok{{-}{-} Case 1. h2 : ¬x ∈ B}
    \KeywordTok{apply}\NormalTok{ Or.inl}
    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\NormalTok{  · }\CommentTok{{-}{-} Case 2. h2 : x ∈ C}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ Case\_1.h}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{x }\NormalTok{: U}
\InformationTok{h1 }\NormalTok{: x ∈ A ∧ ¬x ∈ B \textbackslash{} C}
\InformationTok{h2 }\NormalTok{: ¬x ∈ B}
\NormalTok{⊢ x ∈ A \textbackslash{} B}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Notice that the tactic \texttt{apply\ Or.inl} has changed the goal for
case 1 to the left half of the original goal,
\texttt{x\ ∈\ A\ \textbackslash{}\ B}. Since this means
\texttt{x\ ∈\ A\ ∧\ x\ ∉\ B}, we can complete case 1 by combining
\texttt{h1.left} with \texttt{h2}, and then we can move on to case 2.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_5\_2}
\NormalTok{    (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) :}
\NormalTok{    A \textbackslash{} (B \textbackslash{} C) ⊆ (A \textbackslash{} B) ∪ C := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{assume}\NormalTok{ h1 : x ∈ A \textbackslash{} (B \textbackslash{} C)}
  \KeywordTok{define}\NormalTok{; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
  \KeywordTok{have}\NormalTok{ h2 : ¬x ∈ B \textbackslash{} C := h1.right}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2; }\KeywordTok{demorgan} \KeywordTok{at}\NormalTok{ h2}
            \CommentTok{{-}{-}h2 : ¬x ∈ B ∨ x ∈ C}
  \KeywordTok{by\_cases} \KeywordTok{on}\NormalTok{ h2}
\NormalTok{  · }\CommentTok{{-}{-} Case 1. h2 : ¬x ∈ B}
    \KeywordTok{apply}\NormalTok{ Or.inl}
    \KeywordTok{show}\NormalTok{ x ∈ A \textbackslash{} B }\KeywordTok{from}\NormalTok{ And.intro h1.left h2}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Case 2. h2 : x ∈ C}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ Case\_2}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{x }\NormalTok{: U}
\InformationTok{h1 }\NormalTok{: x ∈ A ∧ ¬x ∈ B \textbackslash{} C}
\InformationTok{h2 }\NormalTok{: x ∈ C}
\NormalTok{⊢ x ∈ A \textbackslash{} B ∨ x ∈ C}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Case 2 is similar, using \texttt{Or.inr} and \texttt{h2}

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_5\_2}
\NormalTok{    (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) :}
\NormalTok{    A \textbackslash{} (B \textbackslash{} C) ⊆ (A \textbackslash{} B) ∪ C := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{assume}\NormalTok{ h1 : x ∈ A \textbackslash{} (B \textbackslash{} C)}
  \KeywordTok{define}\NormalTok{; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
  \KeywordTok{have}\NormalTok{ h2 : ¬x ∈ B \textbackslash{} C := h1.right}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2; }\KeywordTok{demorgan} \KeywordTok{at}\NormalTok{ h2}
            \CommentTok{{-}{-}h2 : ¬x ∈ B ∨ x ∈ C}
  \KeywordTok{by\_cases} \KeywordTok{on}\NormalTok{ h2}
\NormalTok{  · }\CommentTok{{-}{-} Case 1. h2 : ¬x ∈ B}
    \KeywordTok{apply}\NormalTok{ Or.inl}
    \KeywordTok{show}\NormalTok{ x ∈ A \textbackslash{} B }\KeywordTok{from}\NormalTok{ And.intro h1.left h2}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Case 2. h2 : x ∈ C}
    \KeywordTok{apply}\NormalTok{ Or.inr}
    \KeywordTok{show}\NormalTok{ x ∈ C }\KeywordTok{from}\NormalTok{ h2}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialStringTok{No}\InformationTok{ }\SpecialStringTok{goals}
\end{Highlighting}
\end{Shaded}

\end{outpt}

There is a second strategy that is often useful to prove a goal of the
form \texttt{P\ ∨\ Q}. It is motivated by the fact that \texttt{P\ ∨\ Q}
is equivalent to both \texttt{¬P\ →\ Q} and \texttt{¬Q\ →\ P}
(\emph{HTPI} p.~147).

\hypertarget{to-prove-a-goal-of-the-form-p-q-4}{%
\subsubsection{\texorpdfstring{To prove a goal of the form
\texttt{P\ ∨\ Q}:}{To prove a goal of the form P ∨ Q:}}\label{to-prove-a-goal-of-the-form-p-q-4}}

\begin{ind}
Assume that \texttt{P} is false and prove \texttt{Q}, or assume that
\texttt{Q} is false and prove \texttt{P}.

\end{ind}

If your goal is \texttt{P\ ∨\ Q}, then the Lean tactic
\texttt{or\_left\ with\ h} will add the new given \texttt{h\ :\ ¬Q} to
the tactic state and set the goal to be \texttt{P}, and
\texttt{or\_right\ with\ h} will add \texttt{h\ :\ ¬P} to the tactic
state and set the goal to be \texttt{Q}. For example, here is the effect
of the tactic \texttt{or\_left\ with\ h}:

\begin{bef}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{ ⋮}
\NormalTok{⊢ P ∨ Q}
\end{Highlighting}
\end{Shaded}

\end{bef}

\begin{aft}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{ ⋮}
\InformationTok{h }\NormalTok{: ¬Q}
\NormalTok{⊢ P}
\end{Highlighting}
\end{Shaded}

\end{aft}

Notice that \texttt{or\_left} and \texttt{or\_right} have the same
effect as \texttt{apply\ Or.inl} and \texttt{apply\ Or.inr}, except that
each adds a new given to the tactic state. Sometimes you can tell in
advance that you won't need the extra given, and in that case the
tactics \texttt{apply\ Or.inl} and \texttt{apply\ Or.inr} can be useful.
For example, that was the case in the example above. But if you think
the extra given might be useful, you are better off using
\texttt{or\_left} or \texttt{or\_right}. Here's an example illustrating
this.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U)}
\NormalTok{    (h1 : A \textbackslash{} B ⊆ C) : A ⊆ B ∪ C := }\KeywordTok{by}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: A \textbackslash{} B ⊆ C}
\NormalTok{⊢ A ⊆ B ∪ C}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Of course, we begin by letting \texttt{x} be an arbitrary element of
\texttt{A}. Writing out the meaning of the new goal shows that it is a
disjunction.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U)}
\NormalTok{    (h1 : A \textbackslash{} B ⊆ C) : A ⊆ B ∪ C := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{assume}\NormalTok{ h2 : x ∈ A}
  \KeywordTok{define}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: A \textbackslash{} B ⊆ C}
\InformationTok{x }\NormalTok{: U}
\InformationTok{h2 }\NormalTok{: x ∈ A}
\NormalTok{⊢ x ∈ B ∨ x ∈ C}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Looking at the givens \texttt{h1} and \texttt{h2}, we see that if we
assume \texttt{x\ ∉\ B}, then we should be able to prove
\texttt{x\ ∈\ C}. This suggests that we should use the
\texttt{or\_right} tactic.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U)}
\NormalTok{    (h1 : A \textbackslash{} B ⊆ C) : A ⊆ B ∪ C := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{assume}\NormalTok{ h2 : x ∈ A}
  \KeywordTok{define}
  \KeywordTok{or\_right} \KeywordTok{with}\NormalTok{ h3}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: A \textbackslash{} B ⊆ C}
\InformationTok{x }\NormalTok{: U}
\InformationTok{h2 }\NormalTok{: x ∈ A}
\InformationTok{h3 }\NormalTok{: ¬x ∈ B}
\NormalTok{⊢ x ∈ C}
\end{Highlighting}
\end{Shaded}

\end{outpt}

We can now complete the proof. Notice that \texttt{h1\ \_} will be a
proof of the goal \texttt{x\ ∈\ C}, if we can fill in the blank with a
proof of \texttt{x\ ∈\ A\ \textbackslash{}\ B}. Since
\texttt{x\ ∈\ A\ \textbackslash{}\ B} means
\texttt{x\ ∈\ A\ ∧\ ¬x\ ∈\ B}, we can prove it with the expression
\texttt{And.intro\ h2\ h3}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U)}
\NormalTok{    (h1 : A \textbackslash{} B ⊆ C) : A ⊆ B ∪ C := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{assume}\NormalTok{ h2 : x ∈ A}
  \KeywordTok{define}
  \KeywordTok{or\_right} \KeywordTok{with}\NormalTok{ h3}
  \KeywordTok{show}\NormalTok{ x ∈ C }\KeywordTok{from}\NormalTok{ h1 (And.intro h2 h3)}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialStringTok{No}\InformationTok{ }\SpecialStringTok{goals}
\end{Highlighting}
\end{Shaded}

\end{outpt}

The fact that \texttt{P\ ∨\ Q} is equivalent to both \texttt{¬P\ →\ Q}
and \texttt{¬Q\ →\ P} also suggests another strategy for using a given
that is a disjunction (\emph{HTPI} p.~149).

\hypertarget{to-use-a-given-of-the-form-p-q-4}{%
\subsubsection{\texorpdfstring{To use a given of the form
\texttt{P\ ∨\ Q}:}{To use a given of the form P ∨ Q:}}\label{to-use-a-given-of-the-form-p-q-4}}

\begin{ind}
If you are also given \texttt{¬P}, or you can prove that \texttt{P} is
false, then you can use this given to conclude that \texttt{Q} is true.
Similarly, if you are given \texttt{¬Q} or can prove that \texttt{Q} is
false, then you can conclude that \texttt{P} is true.

\end{ind}

This strategy is a rule of inference called \emph{disjunctive
syllogism}, and the tactic for using this strategy in Lean is called
\texttt{disj\_syll}. If you have \texttt{h1\ :\ P\ ∨\ Q} and
\texttt{h2\ :\ ¬P}, then the tactic \texttt{disj\_syll\ h1\ h2} will
change \texttt{h1} to \texttt{h1\ :\ Q}; if instead you have
\texttt{h2\ :\ ¬Q}, then \texttt{disj\_syll\ h1\ h2} will change
\texttt{h1} to \texttt{h1\ :\ P}. Notice that, as with the
\texttt{by\_cases} tactic, the given \texttt{h1} gets \emph{replaced}
with the conclusion of the rule. The tactic
\texttt{disj\_syll\ h1\ h2\ with\ h3} will preserve the original
\texttt{h1} and introduce the conclusion as a new given with the
identifier \texttt{h3}. Also, as with the \texttt{by\_cases} tactic,
either \texttt{h1} or \texttt{h2} can be a complex proof rather than
simply an identifier (although in that case it must be enclosed in
parentheses, so that Lean can tell where \texttt{h1} ends and
\texttt{h2} begins). The only requirement is that \texttt{h1} must be a
proof of a disjunction, and \texttt{h2} must be a proof of the negation
of one side of the disjunction. If \texttt{h1} is not simply an
identifier, then you will want to use \texttt{with} to specify the
identifier to be used for the conclusion of the rule.

Here's an example illustrating the use of the disjunctive syllogism
rule.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}
\NormalTok{    (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) (h1 : A ⊆ B ∪ C)}
\NormalTok{    (h2 : ¬∃ (x : U), x ∈ A ∩ B) : A ⊆ C := }\KeywordTok{by}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: A ⊆ B ∪ C}
\InformationTok{h2 }\NormalTok{: ¬∃ (x : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  x ∈ A ∩ B}
\NormalTok{⊢ A ⊆ C}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Of course, we begin by introducing an arbitrary element of \texttt{A}.
We also rewrite \texttt{h2} as an equivalent positive statement.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}
\NormalTok{    (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) (h1 : A ⊆ B ∪ C)}
\NormalTok{    (h2 : ¬∃ (x : U), x ∈ A ∩ B) : A ⊆ C := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ a : U}
  \KeywordTok{assume}\NormalTok{ h3 : a ∈ A}
  \KeywordTok{quant\_neg} \KeywordTok{at}\NormalTok{ h2}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: A ⊆ B ∪ C}
\InformationTok{h2 }\NormalTok{: ∀ (x : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  ¬x ∈ A ∩ B}
\InformationTok{a }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: a ∈ A}
\NormalTok{⊢ a ∈ C}
\end{Highlighting}
\end{Shaded}

\end{outpt}

We can now make two inferences by combining \texttt{h1} with \texttt{h3}
and by applying \texttt{h2} to \texttt{a}. To see how to use the
inferred statements, we write out their definitions, and since one of
them is a negative statement, we reexpress it as an equivalent positive
statement.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}
\NormalTok{    (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) (h1 : A ⊆ B ∪ C)}
\NormalTok{    (h2 : ¬∃ (x : U), x ∈ A ∩ B) : A ⊆ C := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ a : U}
  \KeywordTok{assume}\NormalTok{ h3 : a ∈ A}
  \KeywordTok{quant\_neg} \KeywordTok{at}\NormalTok{ h2}
  \KeywordTok{have}\NormalTok{ h4 : a ∈ B ∪ C := h1 h3}
  \KeywordTok{have}\NormalTok{ h5 : a ∉ A ∩ B := h2 a}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h4}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h5; }\KeywordTok{demorgan} \KeywordTok{at}\NormalTok{ h5}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: A ⊆ B ∪ C}
\InformationTok{h2 }\NormalTok{: ∀ (x : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  ¬x ∈ A ∩ B}
\InformationTok{a }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: a ∈ A}
\InformationTok{h4 }\NormalTok{: a ∈ B ∨ a ∈ C}
\InformationTok{h5 }\NormalTok{: ¬a ∈ A ∨ ¬a ∈ B}
\NormalTok{⊢ a ∈ C}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Both \texttt{h4} and \texttt{h5} are disjunctions, and looking at
\texttt{h3} we see that the disjunctive syllogism rule can be applied.
From \texttt{h3} and \texttt{h5} we can draw the conclusion
\texttt{¬a\ ∈\ B}, and then combining that conclusion with \texttt{h4}
we can infer \texttt{a\ ∈\ C}. Since that is the goal, we are done.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}
\NormalTok{    (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) (h1 : A ⊆ B ∪ C)}
\NormalTok{    (h2 : ¬∃ (x : U), x ∈ A ∩ B) : A ⊆ C := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ a : U}
  \KeywordTok{assume}\NormalTok{ h3 : a ∈ A}
  \KeywordTok{quant\_neg} \KeywordTok{at}\NormalTok{ h2}
  \KeywordTok{have}\NormalTok{ h4 : a ∈ B ∪ C := h1 h3}
  \KeywordTok{have}\NormalTok{ h5 : a ∉ A ∩ B := h2 a}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h4}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h5; }\KeywordTok{demorgan} \KeywordTok{at}\NormalTok{ h5}
  \KeywordTok{disj\_syll}\NormalTok{ h5 h3  }\CommentTok{{-}{-}h5 : ¬a ∈ B}
  \KeywordTok{disj\_syll}\NormalTok{ h4 h5  }\CommentTok{{-}{-}h4 : a ∈ C}
  \KeywordTok{show}\NormalTok{ a ∈ C }\KeywordTok{from}\NormalTok{ h4}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialStringTok{No}\InformationTok{ }\SpecialStringTok{goals}
\end{Highlighting}
\end{Shaded}

\end{outpt}

We're going to redo the last example, to illustrate another useful
technique in Lean. We start with some of the same steps as before.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}
\NormalTok{    (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) (h1 : A ⊆ B ∪ C)}
\NormalTok{    (h2 : ¬∃ (x : U), x ∈ A ∩ B) : A ⊆ C := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ a : U}
  \KeywordTok{assume}\NormalTok{ h3 : a ∈ A}
  \KeywordTok{have}\NormalTok{ h4 : a ∈ B ∪ C := h1 h3}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h4}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: A ⊆ B ∪ C}
\InformationTok{h2 }\NormalTok{: ¬∃ (x : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  x ∈ A ∩ B}
\InformationTok{a }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: a ∈ A}
\InformationTok{h4 }\NormalTok{: a ∈ B ∨ a ∈ C}
\NormalTok{⊢ a ∈ C}
\end{Highlighting}
\end{Shaded}

\end{outpt}

At this point, you might see a possible route to the goal: from
\texttt{h2} and \texttt{h3} we should be able to prove that
\texttt{a\ ∉\ B}, and then, combining that with \texttt{h4} by the
disjunctive syllogism rule, we should be able to deduce the goal
\texttt{a\ ∈\ C}. Let's try writing the proof that way.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{??}\AnnotationTok{example}\SpecialCharTok{::}
\NormalTok{    (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) (h1 : A ⊆ B ∪ C)}
\NormalTok{    (h2 : ¬∃ (x : U), x ∈ A ∩ B) : A ⊆ C := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ a : U}
  \KeywordTok{assume}\NormalTok{ h3 : a ∈ A}
  \KeywordTok{have}\NormalTok{ h4 : a ∈ B ∪ C := h1 h3}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h4}
  \KeywordTok{have}\NormalTok{ h5 : a ∉ B := }\ConstantTok{sorry}
  \KeywordTok{disj\_syll}\NormalTok{ h4 h5  }\CommentTok{{-}{-}h4 : a ∈ C}
  \KeywordTok{show}\NormalTok{ a ∈ C }\KeywordTok{from}\NormalTok{ h4}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialStringTok{No}\InformationTok{ }\SpecialStringTok{goals}
\end{Highlighting}
\end{Shaded}

\end{outpt}

We have introduced a new idea in this proof. The justification we have
given for introducing \texttt{h5\ :\ a\ ∉\ B} is \texttt{sorry}. You
might think of this as meaning ``Sorry, I'm not going to give a
justification for this statement, but please accept it anyway.'' Of
course, this is cheating; in a complete proof, every step must be
justified. Lean accepts \texttt{sorry} as a proof of any statement, but
it displays it in red to warn you that you're cheating. It also puts a
brown squiggle under the keyword \texttt{example} and it puts the
message
\texttt{declaration\ uses\ \textquotesingle{}sorry\textquotesingle{}} in
the Infoview, to warn you that, although the proof has reached the goal,
it is not fully justified.

Although writing the proof this way is cheating, it is a convenient way
to see that our plan of attack for this proof is reasonable. Lean has
accepted the proof, except for the warning that we have used
\texttt{sorry}. So now we know that if we go back and replace
\texttt{sorry} with a proof of \texttt{a\ ∉\ B}, then we will have a
complete proof.

The proof of \texttt{a\ ∉\ B} is hard enough that it is easier to do it
in tactic mode rather than term mode. So we will begin the proof as we
always do for tactic-mode proofs: we replace \texttt{sorry} with
\texttt{by}, leave a blank line, and then put \texttt{done}, indented
further than the surrounding text. When we put the cursor on the blank
line before \texttt{done}, we see the tactic state for our ``proof
within a proof.''

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}
\NormalTok{    (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) (h1 : A ⊆ B ∪ C)}
\NormalTok{    (h2 : ¬∃ (x : U), x ∈ A ∩ B) : A ⊆ C := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ a : U}
  \KeywordTok{assume}\NormalTok{ h3 : a ∈ A}
  \KeywordTok{have}\NormalTok{ h4 : a ∈ B ∪ C := h1 h3}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h4}
  \KeywordTok{have}\NormalTok{ h5 : a ∉ B := }\KeywordTok{by}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{disj\_syll}\NormalTok{ h4 h5  }\CommentTok{{-}{-}h4 : a ∈ C}
  \KeywordTok{show}\NormalTok{ a ∈ C }\KeywordTok{from}\NormalTok{ h4}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: A ⊆ B ∪ C}
\InformationTok{h2 }\NormalTok{: ¬∃ (x : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  x ∈ A ∩ B}
\InformationTok{a }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: a ∈ A}
\InformationTok{h4 }\NormalTok{: a ∈ B ∨ a ∈ C}
\NormalTok{⊢ ¬a ∈ B}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Note that \texttt{h5\ :\ a\ ∉\ B} is not a given in the tactic state,
because we have not yet justified it; in fact, \texttt{¬a\ ∈\ B} is the
goal. This goal is a negative statement, and \texttt{h2} is also
negative. This suggests that we could try using proof by contradiction,
achieving the contradiction by contradicting \texttt{h2}. So we use the
tactic \texttt{contradict\ h2\ with\ h6}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}
\NormalTok{    (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) (h1 : A ⊆ B ∪ C)}
\NormalTok{    (h2 : ¬∃ (x : U), x ∈ A ∩ B) : A ⊆ C := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ a : U}
  \KeywordTok{assume}\NormalTok{ h3 : a ∈ A}
  \KeywordTok{have}\NormalTok{ h4 : a ∈ B ∪ C := h1 h3}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h4}
  \KeywordTok{have}\NormalTok{ h5 : a ∉ B := }\KeywordTok{by}
    \KeywordTok{contradict}\NormalTok{ h2 }\KeywordTok{with}\NormalTok{ h6}
    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{disj\_syll}\NormalTok{ h4 h5  }\CommentTok{{-}{-}h4 : a ∈ C}
  \KeywordTok{show}\NormalTok{ a ∈ C }\KeywordTok{from}\NormalTok{ h4}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: A ⊆ B ∪ C}
\InformationTok{h2 }\NormalTok{: ¬∃ (x : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  x ∈ A ∩ B}
\InformationTok{a }\NormalTok{: U}
\InformationTok{h3 }\NormalTok{: a ∈ A}
\InformationTok{h4 }\NormalTok{: a ∈ B ∨ a ∈ C}
\InformationTok{h6 }\NormalTok{: a ∈ B}
\NormalTok{⊢ ∃ (x : U), x ∈ A ∩ B}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Looking at \texttt{h3} and \texttt{h6}, we see that the right value to
plug in for \texttt{x} in the goal is \texttt{a}. In fact,
\texttt{Exists.intro\ a\ \_} will prove the goal, if we can fill in the
blank with a proof of \texttt{a\ ∈\ A\ ∩\ B}. Since this means
\texttt{a\ ∈\ A\ ∧\ a\ ∈\ B}, we can prove it with
\texttt{And.intro\ h3\ h6}. Thus, we can complete the proof in one more
step:

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}
\NormalTok{    (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) (h1 : A ⊆ B ∪ C)}
\NormalTok{    (h2 : ¬∃ (x : U), x ∈ A ∩ B) : A ⊆ C := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ a : U}
  \KeywordTok{assume}\NormalTok{ h3 : a ∈ A}
  \KeywordTok{have}\NormalTok{ h4 : a ∈ B ∪ C := h1 h3}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h4}
  \KeywordTok{have}\NormalTok{ h5 : a ∉ B := }\KeywordTok{by}
    \KeywordTok{contradict}\NormalTok{ h2 }\KeywordTok{with}\NormalTok{ h6}
    \KeywordTok{show}\NormalTok{ ∃ (x : U), x ∈ A ∩ B }\KeywordTok{from}
\NormalTok{      Exists.intro a (And.intro h3 h6)}
    \KeywordTok{done}
  \KeywordTok{disj\_syll}\NormalTok{ h4 h5  }\CommentTok{{-}{-}h4 : a ∈ C}
  \KeywordTok{show}\NormalTok{ a ∈ C }\KeywordTok{from}\NormalTok{ h4}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialStringTok{No}\InformationTok{ }\SpecialStringTok{goals}
\end{Highlighting}
\end{Shaded}

\end{outpt}

The red squiggle has disappeared from the word \texttt{done}, indicating
that the proof is complete.

It was not really necessary for us to use \texttt{sorry} when writing
this proof. We could have simply written the steps in order, exactly as
they appear above. Any time you use the \texttt{have} tactic with a
conclusion that is difficult to justify, you have a choice. You can
establish the \texttt{have} with \texttt{sorry}, complete the proof, and
then return and fill in a justification for the \texttt{have}, as we did
in the example above. Or, you can justify the \texttt{have} right away
by typing \texttt{by} after \texttt{:=} and then plunging into the
``proof within in a proof.'' Once you complete the inner proof, you can
continue with the original proof.

And in case you were wondering: yes, if the inner proof uses the
\texttt{have} tactic with a statement that is hard to justify, then you
can write a ``proof within a proof within a proof''!

\hypertarget{exercises-3}{%
\subsection{Exercises}\label{exercises-3}}

In each case, replace \texttt{sorry} with a proof.

\begin{numex}{1}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_5\_2 (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) :}
\NormalTok{    (A ∪ B) \textbackslash{} C ⊆ A ∪ (B \textbackslash{} C) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{2}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_5\_5 (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U)}
\NormalTok{    (h1 : A ∩ C ⊆ B ∩ C) (h2 : A ∪ C ⊆ B ∪ C) : A ⊆ B := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{3}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_5\_7 (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) :}
\NormalTok{    A ∪ C ⊆ B ∪ C ↔ A \textbackslash{} C ⊆ B \textbackslash{} C := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{4}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_5\_8 (U : }\KeywordTok{Type}\NormalTok{) (A B : Set U) :}
\NormalTok{    𝒫 A ∪ 𝒫 B ⊆ 𝒫 (A ∪ B) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{5}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_5\_17b (U : }\KeywordTok{Type}\NormalTok{) (F : Set (Set U)) (B : Set U) :}
\NormalTok{    B ∪ (⋂₀ F) = \{ x : U | ∀ (A : Set U), A ∈ F → x ∈ B ∪ A \} := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{6}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_5\_18 (U : }\KeywordTok{Type}\NormalTok{) (F G H : Set (Set U))}
\NormalTok{    (h1 : ∀ (A : Set U), A ∈ F → ∀ (B : Set U), B ∈ G → A ∪ B ∈ H) :}
\NormalTok{    ⋂₀ H ⊆ (⋂₀ F) ∪ (⋂₀ G) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{7}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_5\_24a (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) :}
\NormalTok{    (A ∪ B) △ C ⊆ (A △ C) ∪ (B △ C) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\hypertarget{existence-and-uniqueness-proofs}{%
\section{3.6. Existence and Uniqueness
Proofs}\label{existence-and-uniqueness-proofs}}

Recall that \texttt{∃!\ (x\ :\ U),\ P\ x} means that there is exactly
one \texttt{x} of type \texttt{U} such that \texttt{P\ x} is true. One
way to deal with a given or goal of this form is to use the
\texttt{define} tactic to rewrite it as the equivalent statement
\texttt{∃\ (x\ :\ U),\ P\ x\ ∧\ ∀\ (x\_1\ :\ U),\ P\ x\_1\ →\ x\_1\ =\ x}.
You can then apply techniques discussed previously in this chapter.
However, there are also proof techniques, and corresponding Lean
tactics, for working directly with givens and goals of this form.

Often a goal of the form \texttt{∃!\ (x\ :\ U),\ P\ x} is proven by
using the following strategy. This is a slight rephrasing of the
strategy presented in \emph{HTPI}. The rephrasing is based on the fact
that for any propositions \texttt{A}, \texttt{B}, and \texttt{C},
\texttt{A\ ∧\ B\ →\ C} is equivalent to \texttt{A\ →\ B\ →\ C} (you can
check this equivalence by making a truth table). The second of these
statements is usually easier to work with in Lean than the first one, so
we will often rephrase statements that have the form
\texttt{A\ ∧\ B\ →\ C} as \texttt{A\ →\ B\ →\ C}. To see why the second
statement is easier to use, suppose that you have givens
\texttt{hA\ :\ A} and \texttt{hB\ :\ B}. If you also have
\texttt{h\ :\ A\ →\ B\ →\ C}, then \texttt{h\ hA} is a proof of
\texttt{B\ →\ C}, and therefore \texttt{h\ hA\ hB} is a proof of
\texttt{C}. If instead you had
\texttt{h\textquotesingle{}\ :\ (A\ ∧\ B)\ →\ C}, then to prove
\texttt{C} you would have to write
\texttt{h\textquotesingle{}\ (And.intro\ hA\ hB)}, which is a bit less
convenient.

With that preparation, here is our strategy for proving statements of
the form \texttt{∃!\ (x\ :\ U),\ P\ x} (\emph{HTPI} pp.~156--157).

\hypertarget{to-prove-a-goal-of-the-form-x-u-p-x-2}{%
\subsubsection{\texorpdfstring{To prove a goal of the form
\texttt{∃!\ (x\ :\ U),\ P\ x}:}{To prove a goal of the form ∃! (x : U), P x:}}\label{to-prove-a-goal-of-the-form-x-u-p-x-2}}

\begin{ind}
Prove \texttt{∃\ (x\ :\ U),\ P\ x} and
\texttt{∀\ (x\_1\ x\_2\ :\ U),\ P\ x\_1\ →\ P\ x\_2\ →\ x\_1\ =\ x\_2}.
The first of these goals says that there exists an \texttt{x} such that
\texttt{P\ x} is true, and the second says that it is unique. The two
parts of the proof are therefore sometimes labeled \emph{existence} and
\emph{uniqueness}.

\end{ind}

To apply this strategy in a Lean proof, we use the tactic
\texttt{exists\_unique}. We'll illustrate this with the theorem from
Example 3.6.2 in \emph{HTPI}. Here's how that theorem and its proof are
presented in \emph{HTPI} (\emph{HTPI} pp.~157--158):

\begin{thm}
There is a unique set \(A\) such that for every set \(B\),
\(A \cup B = B\).

\end{thm}

\begin{proof}

Existence: Clearly \(\forall B(\varnothing \cup B = B)\), so
\(\varnothing\) has the required property.

Uniqueness: Suppose \(\forall B(C \cup B = B)\) and
\(\forall B(D \cup B = B)\). Applying the first of these assumptions to
\(D\) we see that \(C \cup D = D\), and applying the second to \(C\) we
get \(D \cup C = C\). But clearly \(C \cup D = D \cup C\), so \(C = D\).
\excl{~□}\qedhere

\end{proof}

You will notice that there are two statements in this proof that are
described as ``clearly'' true. This brings up one of the difficulties
with proving theorems in Lean: things that are clear to \emph{us} are
not necessarily clear to \emph{Lean}! There are two ways to deal with
such ``clear'' statements. The first is to see if the statement is in
the library of theorems that Lean knows. The second is to prove the
statement as a preliminary theorem that can then be used in the proof of
our main theorem. We'll take the second approach here, since proving
these ``clear'' facts will give us more practice with Lean proofs, but
later we'll have more to say about searching for statements in Lean's
theorem library.

The first theorem we need says that for every set \texttt{B},
\texttt{∅\ ∪\ B\ =\ B}, and it brings up a subtle issue: in Lean, the
symbol \texttt{∅} is ambiguous! The reason for this is Lean's strict
typing rules. For each type \texttt{U}, there is an empty set of type
\texttt{Set\ U}. There is, for example, the set of type
\texttt{Set\ Nat} that contains no natural numbers, and also the set of
type \texttt{Set\ Real} that contains no real numbers. To Lean, these
are different sets, because they have different types. Which one does
the symbol \texttt{∅} denote? The answer will be different in different
contexts. Lean can often figure out from context which empty set you
have in mind, but if it can't, then you have to tell it explicitly by
writing \texttt{(∅\ :\ Set\ U)} rather than \texttt{∅}. Fortunately, in
our theorems Lean is able to figure out which empty set we have in mind.

With that preparation, we are ready to prove our first preliminary
theorem. Since the goal is an equation between sets, our first step is
to use the tactic \texttt{apply\ Set.ext}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ empty\_union \{U : }\KeywordTok{Type}\NormalTok{\} (B : Set U) :}
\NormalTok{    ∅ ∪ B = B := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Set.ext}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ h}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{B }\NormalTok{: Set U}
\NormalTok{⊢ ∀ (x : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  x ∈ ∅ ∪ B ↔ x ∈ B}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Based on the form of the goal, our next two tactics should be
\texttt{fix\ x\ :\ U} and \texttt{apply\ Iff.intro}. This leaves us with
two goals, corresponding to the two directions of the biconditional, but
we'll focus first on just the left-to-right direction.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ empty\_union \{U : }\KeywordTok{Type}\NormalTok{\} (B : Set U) :}
\NormalTok{    ∅ ∪ B = B := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Set.ext}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\NormalTok{  · }\CommentTok{{-}{-} (←)}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ h.mp}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{B }\NormalTok{: Set U}
\InformationTok{x }\NormalTok{: U}
\NormalTok{⊢ x ∈ ∅ ∪ B → x ∈ B}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Of course, our next step is to assume \texttt{x\ ∈\ ∅\ ∪\ B}. To help us
see how to move forward, we also write out the definition of this
assumption.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ empty\_union \{U : }\KeywordTok{Type}\NormalTok{\} (B : Set U) :}
\NormalTok{    ∅ ∪ B = B := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Set.ext}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h1 : x ∈ ∅ ∪ B}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\NormalTok{  · }\CommentTok{{-}{-} (←)}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ h.mp}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{B }\NormalTok{: Set U}
\InformationTok{x }\NormalTok{: U}
\InformationTok{h1 }\NormalTok{: x ∈ ∅ ∨ x ∈ B}
\NormalTok{⊢ x ∈ B}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Now you should see a way to complete the proof: the statement
\texttt{x\ ∈\ ∅} is false, so we should be able to apply the disjunctive
syllogism rule to \texttt{h1} to infer the goal \texttt{x\ ∈\ B}. To
carry out this plan, we'll first have to prove \texttt{x\ ∉\ ∅}. We'll
use the \texttt{have} tactic, and since there's no obvious term-mode
proof to justify it, we'll try a tactic-mode proof.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ empty\_union \{U : }\KeywordTok{Type}\NormalTok{\} (B : Set U) :}
\NormalTok{    ∅ ∪ B = B := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Set.ext}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h1 : x ∈ ∅ ∪ B}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
    \KeywordTok{have}\NormalTok{ h2 : x ∉ ∅ := }\KeywordTok{by}

      \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\NormalTok{  · }\CommentTok{{-}{-} (←)}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{B }\NormalTok{: Set U}
\InformationTok{x }\NormalTok{: U}
\InformationTok{h1 }\NormalTok{: x ∈ ∅ ∨ x ∈ B}
\NormalTok{⊢ ¬x ∈ ∅}
\end{Highlighting}
\end{Shaded}

\end{outpt}

The goal for our ``proof within a proof'' is a negative statement, so
proof by contradiction seems like a good start.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ empty\_union \{U : }\KeywordTok{Type}\NormalTok{\} (B : Set U) :}
\NormalTok{    ∅ ∪ B = B := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Set.ext}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h1 : x ∈ ∅ ∪ B}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
    \KeywordTok{have}\NormalTok{ h2 : x ∉ ∅ := }\KeywordTok{by}
      \KeywordTok{by\_contra}\NormalTok{ h3}
      \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\NormalTok{  · }\CommentTok{{-}{-} (←)}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{B }\NormalTok{: Set U}
\InformationTok{x }\NormalTok{: U}
\InformationTok{h1 }\NormalTok{: x ∈ ∅ ∨ x ∈ B}
\InformationTok{h3 }\NormalTok{: x ∈ ∅}
\NormalTok{⊢ False}
\end{Highlighting}
\end{Shaded}

\end{outpt}

To see how to use the new assumption \texttt{h3}, we use the tactic
\texttt{define\ at\ h3}. The definition Lean gives for the statement
\texttt{x\ ∈\ ∅} is \texttt{False}. In other words, Lean knows that, by
the definition of \texttt{∅}, the statement \texttt{x\ ∈\ ∅} is false.
Since \texttt{False} is our goal, this completes the inner proof, and we
can return to the main proof.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ empty\_union \{U : }\KeywordTok{Type}\NormalTok{\} (B : Set U) :}
\NormalTok{    ∅ ∪ B = B := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Set.ext}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h1 : x ∈ ∅ ∪ B}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
    \KeywordTok{have}\NormalTok{ h2 : x ∉ ∅ := }\KeywordTok{by}
      \KeywordTok{by\_contra}\NormalTok{ h3}
      \KeywordTok{define} \KeywordTok{at}\NormalTok{ h3  }\CommentTok{{-}{-}h3 : False}
      \KeywordTok{show}\NormalTok{ False }\KeywordTok{from}\NormalTok{ h3}
      \KeywordTok{done}
    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\NormalTok{  · }\CommentTok{{-}{-} (←)}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ h.mp}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{B }\NormalTok{: Set U}
\InformationTok{x }\NormalTok{: U}
\InformationTok{h1 }\NormalTok{: x ∈ ∅ ∨ x ∈ B}
\InformationTok{h2 }\NormalTok{: ¬x ∈ ∅}
\NormalTok{⊢ x ∈ B}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Now that we have established the claim \texttt{h2\ :\ ¬x\ ∈\ ∅}, we can
apply the disjunctive syllogism rule to \texttt{h1} and \texttt{h2} to
reach the goal. This completes the left-to-right direction of the
biconditional proof, so we move on to the right-to-left direction.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ empty\_union \{U : }\KeywordTok{Type}\NormalTok{\} (B : Set U) :}
\NormalTok{    ∅ ∪ B = B := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Set.ext}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h1 : x ∈ ∅ ∪ B}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
    \KeywordTok{have}\NormalTok{ h2 : x ∉ ∅ := }\KeywordTok{by}
      \KeywordTok{by\_contra}\NormalTok{ h3}
      \KeywordTok{define} \KeywordTok{at}\NormalTok{ h3  }\CommentTok{{-}{-}h3 : False}
      \KeywordTok{show}\NormalTok{ False }\KeywordTok{from}\NormalTok{ h3}
      \KeywordTok{done}
    \KeywordTok{disj\_syll}\NormalTok{ h1 h2  }\CommentTok{{-}{-}h1 : x ∈ B}
    \KeywordTok{show}\NormalTok{ x ∈ B }\KeywordTok{from}\NormalTok{ h1}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} (←)}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ h.mpr}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{B }\NormalTok{: Set U}
\InformationTok{x }\NormalTok{: U}
\NormalTok{⊢ x ∈ B → x ∈ ∅ ∪ B}
\end{Highlighting}
\end{Shaded}

\end{outpt}

This direction of the biconditional proof is easier: once we introduce
the assumption \texttt{h1\ :\ x\ ∈\ B}, our goal will be
\texttt{x\ ∈\ ∅\ ∪\ B}, which means \texttt{x\ ∈\ ∅\ ∨\ x\ ∈\ B}, and we
can prove it with the proof \texttt{Or.inr\ h1}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ empty\_union \{U : }\KeywordTok{Type}\NormalTok{\} (B : Set U) :}
\NormalTok{    ∅ ∪ B = B := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Set.ext}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h1 : x ∈ ∅ ∪ B}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
    \KeywordTok{have}\NormalTok{ h2 : x ∉ ∅ := }\KeywordTok{by}
      \KeywordTok{by\_contra}\NormalTok{ h3}
      \KeywordTok{define} \KeywordTok{at}\NormalTok{ h3  }\CommentTok{{-}{-}h3 : False}
      \KeywordTok{show}\NormalTok{ False }\KeywordTok{from}\NormalTok{ h3}
      \KeywordTok{done}
    \KeywordTok{disj\_syll}\NormalTok{ h1 h2  }\CommentTok{{-}{-}h1 : x ∈ B}
    \KeywordTok{show}\NormalTok{ x ∈ B }\KeywordTok{from}\NormalTok{ h1}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} (←)}
    \KeywordTok{assume}\NormalTok{ h1 : x ∈ B}
    \KeywordTok{show}\NormalTok{ x ∈ ∅ ∪ B }\KeywordTok{from}\NormalTok{ Or.inr h1}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialStringTok{No}\InformationTok{ }\SpecialStringTok{goals}
\end{Highlighting}
\end{Shaded}

\end{outpt}

The second fact that was called ``clear'' in the proof from Example
3.6.2 was the equation \texttt{C\ ∪\ D\ =\ D\ ∪\ C}. This looks like an
instance of the commutativity of the union operator. Let's prove that
union is commutative.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ union\_comm \{U : }\KeywordTok{Type}\NormalTok{\} (X Y : Set U) :}
\NormalTok{    X ∪ Y = Y ∪ X := }\KeywordTok{by}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{X Y }\NormalTok{: Set U}
\NormalTok{⊢ X ∪ Y = Y ∪ X}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Once again, we begin with \texttt{apply\ Set.ext}, which converts the
goal to \texttt{∀\ (x\ :\ U),\ x\ ∈\ X\ ∪\ Y\ ↔\ x\ ∈\ Y\ ∪\ X}, and
then \texttt{fix\ x\ :\ U}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ union\_comm \{U : }\KeywordTok{Type}\NormalTok{\} (X Y : Set U) :}
\NormalTok{    X ∪ Y = Y ∪ X := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Set.ext}
  \KeywordTok{fix}\NormalTok{ x : U}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ h}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{X Y }\NormalTok{: Set U}
\InformationTok{x }\NormalTok{: U}
\NormalTok{⊢ x ∈ X ∪ Y ↔ x ∈ Y ∪ X}
\end{Highlighting}
\end{Shaded}

\end{outpt}

To understand the goal better, we'll write out the definitions of the
two sides of the biconditional. We use an extension of the
\texttt{define} tactic that allows us to write out the definition of
just a part of a given or the goal. The tactic
\texttt{define\ :\ x\ ∈\ X\ ∪\ Y} will replace \texttt{x\ ∈\ X\ ∪\ Y}
with its definition wherever it appears in the goal, and then
\texttt{define\ :\ x\ ∈\ Y\ ∪\ X} will replace \texttt{x\ ∈\ Y\ ∪\ X}
with its definition. (Note that \texttt{define\ :\ X\ ∪\ Y} produces a
result that is not as useful. It is usually best to define a complete
statement rather than just a part of a statement. As usual, you can add
\texttt{at} to do the replacements in a given rather than the goal.)

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ union\_comm \{U : }\KeywordTok{Type}\NormalTok{\} (X Y : Set U) :}
\NormalTok{    X ∪ Y = Y ∪ X := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Set.ext}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{define}\NormalTok{ : x ∈ X ∪ Y}
  \KeywordTok{define}\NormalTok{ : x ∈ Y ∪ X}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ h}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{X Y }\NormalTok{: Set U}
\InformationTok{x }\NormalTok{: U}
\NormalTok{⊢ x ∈ X ∨ x ∈ Y ↔}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  x ∈ Y ∨ x ∈ X}
\end{Highlighting}
\end{Shaded}

\end{outpt}

By the way, there are similar extensions of all of the tactics
\texttt{contrapos}, \texttt{demorgan}, \texttt{conditional},
\texttt{double\_neg}, \texttt{bicond\_neg}, and \texttt{quant\_neg} that
allow you to use a logical equivalence to rewrite just a part of a
formula. For example, if your goal is \texttt{P\ ∧\ (¬Q\ →\ R)}, then
the tactic \texttt{contrapos\ :\ ¬Q\ →\ R} will change the goal to
\texttt{P\ ∧\ (¬R\ →\ Q)}. If you have a given
\texttt{h\ :\ P\ →\ ¬∀\ (x\ :\ U),\ Q\ x}, then the tactic
\texttt{quant\_neg\ :\ ¬∀\ (x\ :\ U),\ Q\ x\ at\ h} will change
\texttt{h} to \texttt{h\ :\ P\ →\ ∃\ (x\ :\ U),\ ¬Q\ x}.

Returning to our proof of \texttt{union\_comm}: the goal is now
\texttt{x\ ∈\ X\ ∨\ x\ ∈\ Y\ ↔\ x\ ∈\ Y\ ∨\ x\ ∈\ X}. You could prove
this by a somewhat tedious application of the rules for biconditionals
and disjunctions that were discussed in the last two sections, and we
invite you to try it. But there is another possibility. The goal now has
the form \texttt{P\ ∨\ Q\ ↔\ Q\ ∨\ P}, which is the commutative law for
``or'' (see Section 1.2 of \emph{HTPI}). We saw in a previous example
that Lean has, in its library, the associative law for ``and''; it is
called \texttt{and\_assoc}. Does Lean also know the commutative law for
``or''?

Try typing \texttt{\#check\ @or\_} in VS Code. After a few seconds, a
pop-up window appears with possible completions of this command. You
will see \texttt{or\_assoc} on the list, as well as \texttt{or\_comm}.
Select \texttt{or\_comm}, and you'll get this response:
\texttt{@or\_comm\ :\ ∀\ \{a\ b\ :\ Prop\},\ a\ ∨\ b\ ↔\ b\ ∨\ a}. Since
\texttt{a} and \texttt{b} are implicit arguments in this theorem, you
can use \texttt{or\_comm} to prove any statement of the form
\texttt{a\ ∨\ b\ ↔\ b\ ∨\ a}, where Lean will figure out for itself what
\texttt{a} and \texttt{b} stand for. In particular, \texttt{or\_comm}
will prove our current goal.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ union\_comm \{U : }\KeywordTok{Type}\NormalTok{\} (X Y : Set U) :}
\NormalTok{    X ∪ Y = Y ∪ X := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Set.ext}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{define}\NormalTok{ : x ∈ X ∪ Y}
  \KeywordTok{define}\NormalTok{ : x ∈ Y ∪ X}
  \KeywordTok{show}\NormalTok{ x ∈ X ∨ x ∈ Y ↔ x ∈ Y ∨ x ∈ X }\KeywordTok{from}\NormalTok{ or\_comm}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialStringTok{No}\InformationTok{ }\SpecialStringTok{goals}
\end{Highlighting}
\end{Shaded}

\end{outpt}

We have now proven the two statements that were said to be ``clearly''
true in the proof in Example 3.6.2 of \emph{HTPI}, and we have given
them names. And that means that we can now use these theorems, in the
file containing these proofs, to prove other theorems. As with any
theorem in Lean's library, you can use the \texttt{\#check} command to
confirm what these theorems say. If you type
\texttt{\#check\ @empty\_union} and \texttt{\#check\ @union\_comm}, you
will get these results:

\begin{ind}

\begin{verbatim}
@empty_union : ∀ {U : Type} (B : Set U), ∅ ∪ B = B

@union_comm : ∀ {U : Type} (X Y : Set U), X ∪ Y = Y ∪ X
\end{verbatim}

\end{ind}

Notice that in both theorems we used curly braces when we introduced the
type \texttt{U}, so it is an implicit argument and will not need to be
specified when we apply the theorems. (Why did we decide to make
\texttt{U} an implicit argument? Well, when we apply the theorem
\texttt{empty\_union} we will be specifying the set \texttt{B}, and when
we apply \texttt{union\_comm} we will be specifying the sets \texttt{X}
and \texttt{Y}. Lean can figure out what \texttt{U} is by examining the
types of these sets, so there is no need to specify it separately.)

We are finally ready to prove the theorem from Example 3.6.2. Here is
the theorem:

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_6\_2 (U : }\KeywordTok{Type}\NormalTok{) :}
\NormalTok{    ∃! (A : Set U), ∀ (B : Set U),}
\NormalTok{    A ∪ B = B := }\KeywordTok{by}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\NormalTok{⊢ ∃! (A : Set U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  ∀ (B : Set U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    A ∪ B = B}
\end{Highlighting}
\end{Shaded}

\end{outpt}

The goal starts with \texttt{∃!}, so we use our new tactic,
\texttt{exists\_unique}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_6\_2 (U : }\KeywordTok{Type}\NormalTok{) :}
\NormalTok{    ∃! (A : Set U), ∀ (B : Set U),}
\NormalTok{    A ∪ B = B := }\KeywordTok{by}
  \KeywordTok{exists\_unique}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ Existence}
\InformationTok{U }\NormalTok{: Type}
\NormalTok{⊢ ∃ (A : Set U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  ∀ (B : Set U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    A ∪ B = B}
\RegionMarkerTok{case}\NormalTok{ Uniqueness}
\InformationTok{U }\NormalTok{: Type}
\NormalTok{⊢ ∀ (A\_1 A\_2 : Set U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  (∀ (B : Set U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{      A\_1 ∪ B = B) →}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  (∀ (B : Set U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{      A\_2 ∪ B = B) →}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  A\_1 = A\_2}
\end{Highlighting}
\end{Shaded}

\end{outpt}

We have two goals, labeled \texttt{Existence} and \texttt{Uniqueness}.
Imitating the proof from \emph{HTPI}, we prove existence by using the
value \texttt{∅} for \texttt{A}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_6\_2 (U : }\KeywordTok{Type}\NormalTok{) :}
\NormalTok{    ∃! (A : Set U), ∀ (B : Set U),}
\NormalTok{    A ∪ B = B := }\KeywordTok{by}
  \KeywordTok{exists\_unique}
\NormalTok{  · }\CommentTok{{-}{-} Existence}
    \KeywordTok{apply}\NormalTok{ Exists.intro ∅}
    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\NormalTok{  · }\CommentTok{{-}{-} Uniqueness}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ Existence}
\InformationTok{U }\NormalTok{: Type}
\NormalTok{⊢ ∀ (B : Set U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  ∅ ∪ B = B}
\end{Highlighting}
\end{Shaded}

\end{outpt}

The goal is now precisely the statement of the theorem
\texttt{empty\_union}, so we can prove it by simply citing that theorem.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_6\_2 (U : }\KeywordTok{Type}\NormalTok{) :}
\NormalTok{    ∃! (A : Set U), ∀ (B : Set U),}
\NormalTok{    A ∪ B = B := }\KeywordTok{by}
  \KeywordTok{exists\_unique}
\NormalTok{  · }\CommentTok{{-}{-} Existence}
    \KeywordTok{apply}\NormalTok{ Exists.intro ∅}
    \KeywordTok{show}\NormalTok{ ∀ (B : Set U), ∅ ∪ B = B }\KeywordTok{from}\NormalTok{ empty\_union}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Uniqueness}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ Uniqueness}
\InformationTok{U }\NormalTok{: Type}
\NormalTok{⊢ ∀ (A\_1 A\_2 : Set U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  (∀ (B : Set U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{      A\_1 ∪ B = B) →}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  (∀ (B : Set U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{      A\_2 ∪ B = B) →}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  A\_1 = A\_2}
\end{Highlighting}
\end{Shaded}

\end{outpt}

For the uniqueness proof, we begin by introducing arbitrary sets
\texttt{C} and \texttt{D} and assuming
\texttt{∀\ (B\ :\ Set\ U),\ C\ ∪\ B\ =\ B} and
\texttt{∀\ (B\ :\ Set\ U),\ D\ ∪\ B\ =\ B}, exactly as in the
\emph{HTPI} proof.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_6\_2 (U : }\KeywordTok{Type}\NormalTok{) :}
\NormalTok{    ∃! (A : Set U), ∀ (B : Set U),}
\NormalTok{    A ∪ B = B := }\KeywordTok{by}
  \KeywordTok{exists\_unique}
\NormalTok{  · }\CommentTok{{-}{-} Existence}
    \KeywordTok{apply}\NormalTok{ Exists.intro ∅}
    \KeywordTok{show}\NormalTok{ ∀ (B : Set U), ∅ ∪ B = B }\KeywordTok{from}\NormalTok{ empty\_union}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Uniqueness}
    \KeywordTok{fix}\NormalTok{ C : Set U; }\KeywordTok{fix}\NormalTok{ D : Set U}
    \KeywordTok{assume}\NormalTok{ h1 : ∀ (B : Set U), C ∪ B = B}
    \KeywordTok{assume}\NormalTok{ h2 : ∀ (B : Set U), D ∪ B = B}
    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ Uniqueness}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{C D }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: ∀ (B : Set U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  C ∪ B = B}
\InformationTok{h2 }\NormalTok{: ∀ (B : Set U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  D ∪ B = B}
\NormalTok{⊢ C = D}
\end{Highlighting}
\end{Shaded}

\end{outpt}

The next step in \emph{HTPI} was to apply \texttt{h1} to \texttt{D}, and
\texttt{h2} to \texttt{C}. We do the same thing in Lean.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_6\_2 (U : }\KeywordTok{Type}\NormalTok{) :}
\NormalTok{    ∃! (A : Set U), ∀ (B : Set U),}
\NormalTok{    A ∪ B = B := }\KeywordTok{by}
  \KeywordTok{exists\_unique}
\NormalTok{  · }\CommentTok{{-}{-} Existence}
    \KeywordTok{apply}\NormalTok{ Exists.intro ∅}
    \KeywordTok{show}\NormalTok{ ∀ (B : Set U), ∅ ∪ B = B }\KeywordTok{from}\NormalTok{ empty\_union}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Uniqueness}
    \KeywordTok{fix}\NormalTok{ C : Set U; }\KeywordTok{fix}\NormalTok{ D : Set U}
    \KeywordTok{assume}\NormalTok{ h1 : ∀ (B : Set U), C ∪ B = B}
    \KeywordTok{assume}\NormalTok{ h2 : ∀ (B : Set U), D ∪ B = B}
    \KeywordTok{have}\NormalTok{ h3 : C ∪ D = D := h1 D}
    \KeywordTok{have}\NormalTok{ h4 : D ∪ C = C := h2 C }
    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ Uniqueness}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{C D }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: ∀ (B : Set U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  C ∪ B = B}
\InformationTok{h2 }\NormalTok{: ∀ (B : Set U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  D ∪ B = B}
\InformationTok{h3 }\NormalTok{: C ∪ D = D}
\InformationTok{h4 }\NormalTok{: D ∪ C = C}
\NormalTok{⊢ C = D}
\end{Highlighting}
\end{Shaded}

\end{outpt}

The goal can now be achieved by stringing together a sequence of
equations: \texttt{C\ =\ D\ ∪\ C\ =\ C\ ∪\ D\ =\ D}. The first of these
equations is \texttt{h4.symm}---that is, \texttt{h4} read backwards; the
second follows from the commutative law for union; and the third is
\texttt{h3}. We saw in Section 3.4 that you can prove a biconditional
statement in Lean by stringing together a sequence of biconditionals in
a calculational proof. Exactly the same method applies to equations.
Here is the complete proof of the theorem:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_6\_2 (U : }\KeywordTok{Type}\NormalTok{) :}
\NormalTok{    ∃! (A : Set U), ∀ (B : Set U),}
\NormalTok{    A ∪ B = B := }\KeywordTok{by}
  \KeywordTok{exists\_unique}
\NormalTok{  · }\CommentTok{{-}{-} Existence}
    \KeywordTok{apply}\NormalTok{ Exists.intro ∅}
    \KeywordTok{show}\NormalTok{ ∀ (B : Set U), ∅ ∪ B = B }\KeywordTok{from}\NormalTok{ empty\_union}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Uniqueness}
    \KeywordTok{fix}\NormalTok{ C : Set U; }\KeywordTok{fix}\NormalTok{ D : Set U}
    \KeywordTok{assume}\NormalTok{ h1 : ∀ (B : Set U), C ∪ B = B}
    \KeywordTok{assume}\NormalTok{ h2 : ∀ (B : Set U), D ∪ B = B}
    \KeywordTok{have}\NormalTok{ h3 : C ∪ D = D := h1 D}
    \KeywordTok{have}\NormalTok{ h4 : D ∪ C = C := h2 C }
    \KeywordTok{show}\NormalTok{ C = D }\KeywordTok{from}
      \KeywordTok{calc}\NormalTok{ C}
\NormalTok{        \_ = D ∪ C := h4.symm}
\NormalTok{        \_ = C ∪ D := union\_comm D C}
\NormalTok{        \_ = D := h3}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

Since the statement \texttt{∃!\ (x\ :\ U),\ P\ x} asserts both the
existence and the uniqueness of an object satisfying the predicate
\texttt{P}, we have the following strategy for using a given of this
form (\emph{HTPI} p.~159):

\hypertarget{to-use-a-given-of-the-form-x-u-p-x-2}{%
\subsubsection{\texorpdfstring{To use a given of the form
\texttt{∃!\ (x\ :\ U),\ P\ x}:}{To use a given of the form ∃! (x : U), P x:}}\label{to-use-a-given-of-the-form-x-u-p-x-2}}

\begin{ind}
Introduce a new variable, say \texttt{a}, into the proof to stand for an
object of type \texttt{U} for which \texttt{P\ a} is true. You may also
assert that
\texttt{∀\ (x\_1\ x\_2\ :\ U),\ P\ x\_1\ →\ P\ x\_2\ →\ x\_1\ =\ x2}.

\end{ind}

If you have a given \texttt{h\ :\ ∃!\ (x\ :\ U),\ P\ x}, then the tactic
\texttt{obtain\ (a\ :\ U)\ (h1\ :\ P\ a)}
\texttt{(h2\ :\ ∀\ (x\_1\ x\_2\ :\ U),\ P\ x\_1\ →\ P\ x\_2\ →\ x\_1\ =\ x\_2)\ from\ h}
will introduce into the tactic state a new variable \texttt{a} of type
\texttt{U} and new givens \texttt{(h1\ :\ P\ a)} and
\texttt{(h2\ :\ ∀\ (x\_1\ x\_2\ :\ U),\ P\ x\_1\ →\ P\ x\_2\ →\ x\_1\ =\ x\_2)}.
To illustrate the use of this tactic, let's prove the theorem in Example
3.6.4 of \emph{HTPI}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_6\_4 (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U)}
\NormalTok{    (h1 : ∃ (x : U), x ∈ A ∩ B)}
\NormalTok{    (h2 : ∃ (x : U), x ∈ A ∩ C)}
\NormalTok{    (h3 : ∃! (x : U), x ∈ A) :}
\NormalTok{    ∃ (x : U), x ∈ B ∩ C := }\KeywordTok{by}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: ∃ (x : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  x ∈ A ∩ B}
\InformationTok{h2 }\NormalTok{: ∃ (x : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  x ∈ A ∩ C}
\InformationTok{h3 }\NormalTok{: ∃! (x : U), x ∈ A}
\NormalTok{⊢ ∃ (x : U), x ∈ B ∩ C}
\end{Highlighting}
\end{Shaded}

\end{outpt}

We begin by applying the \texttt{obtain} tactic to \texttt{h1},
\texttt{h2}, and \texttt{h3}. In the case of \texttt{h3}, we get an
extra given asserting the uniqueness of the element of \texttt{A}. We
also write out the definitions of two of the new givens we obtain.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_6\_4 (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U)}
\NormalTok{    (h1 : ∃ (x : U), x ∈ A ∩ B)}
\NormalTok{    (h2 : ∃ (x : U), x ∈ A ∩ C)}
\NormalTok{    (h3 : ∃! (x : U), x ∈ A) :}
\NormalTok{    ∃ (x : U), x ∈ B ∩ C := }\KeywordTok{by}
  \KeywordTok{obtain}\NormalTok{ (b : U) (h4 : b ∈ A ∩ B) }\KeywordTok{from}\NormalTok{ h1}
  \KeywordTok{obtain}\NormalTok{ (c : U) (h5 : c ∈ A ∩ C) }\KeywordTok{from}\NormalTok{ h2}
  \KeywordTok{obtain}\NormalTok{ (a : U) (h6 : a ∈ A) (h7 : ∀ (y z : U),}
\NormalTok{    y ∈ A → z ∈ A → y = z)  }\KeywordTok{from}\NormalTok{ h3}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h4; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h5}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: ∃ (x : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  x ∈ A ∩ B}
\InformationTok{h2 }\NormalTok{: ∃ (x : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  x ∈ A ∩ C}
\InformationTok{h3 }\NormalTok{: ∃! (x : U), x ∈ A}
\InformationTok{b }\NormalTok{: U}
\InformationTok{h4 }\NormalTok{: b ∈ A ∧ b ∈ B}
\InformationTok{c }\NormalTok{: U}
\InformationTok{h5 }\NormalTok{: c ∈ A ∧ c ∈ C}
\InformationTok{a }\NormalTok{: U}
\InformationTok{h6 }\NormalTok{: a ∈ A}
\InformationTok{h7 }\NormalTok{: ∀ (y z : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  y ∈ A → z ∈ A → y = z}
\NormalTok{⊢ ∃ (x : U), x ∈ B ∩ C}
\end{Highlighting}
\end{Shaded}

\end{outpt}

The key to the rest of the proof is the observation that, by the
uniqueness of the element of \texttt{A}, \texttt{b} must be equal to
\texttt{c}. To justify this conclusion, note that by two applications of
universal instantiation, \texttt{h7\ b\ c} is a proof of
\texttt{b\ ∈\ A\ →\ c\ ∈\ A\ →\ b\ =\ c}, and therefore by two
applications of modus ponens, \texttt{h7\ b\ c\ h4.left\ h5.left} is a
proof of \texttt{b\ =\ c}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_6\_4 (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U)}
\NormalTok{    (h1 : ∃ (x : U), x ∈ A ∩ B)}
\NormalTok{    (h2 : ∃ (x : U), x ∈ A ∩ C)}
\NormalTok{    (h3 : ∃! (x : U), x ∈ A) :}
\NormalTok{    ∃ (x : U), x ∈ B ∩ C := }\KeywordTok{by}
  \KeywordTok{obtain}\NormalTok{ (b : U) (h4 : b ∈ A ∩ B) }\KeywordTok{from}\NormalTok{ h1}
  \KeywordTok{obtain}\NormalTok{ (c : U) (h5 : c ∈ A ∩ C) }\KeywordTok{from}\NormalTok{ h2}
  \KeywordTok{obtain}\NormalTok{ (a : U) (h6 : a ∈ A) (h7 : ∀ (y z : U),}
\NormalTok{    y ∈ A → z ∈ A → y = z)  }\KeywordTok{from}\NormalTok{ h3}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h4; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h5}
  \KeywordTok{have}\NormalTok{ h8 : b = c := h7 b c h4.left h5.left}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: ∃ (x : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  x ∈ A ∩ B}
\InformationTok{h2 }\NormalTok{: ∃ (x : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  x ∈ A ∩ C}
\InformationTok{h3 }\NormalTok{: ∃! (x : U), x ∈ A}
\InformationTok{b }\NormalTok{: U}
\InformationTok{h4 }\NormalTok{: b ∈ A ∧ b ∈ B}
\InformationTok{c }\NormalTok{: U}
\InformationTok{h5 }\NormalTok{: c ∈ A ∧ c ∈ C}
\InformationTok{a }\NormalTok{: U}
\InformationTok{h6 }\NormalTok{: a ∈ A}
\InformationTok{h7 }\NormalTok{: ∀ (y z : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  y ∈ A → z ∈ A → y = z}
\InformationTok{h8 }\NormalTok{: b = c}
\NormalTok{⊢ ∃ (x : U), x ∈ B ∩ C}
\end{Highlighting}
\end{Shaded}

\end{outpt}

For our next step, we will need a new tactic. Since we have
\texttt{h8\ :\ b\ =\ c}, we should be able to replace \texttt{b} with
\texttt{c} anywhere it appears. The tactic that allows us to do this
called \texttt{rewrite}. If \texttt{h} is a proof of any equation
\texttt{s\ =\ t}, then \texttt{rewrite\ {[}h{]}} will replace all
occurrences of \texttt{s} in the goal with \texttt{t}. Notice that it is
the left side of the equation that is replaced with the right side; if
you want the replacement to go in the other direction, so that
\texttt{t} is replaced with \texttt{s}, you can use
\texttt{rewrite\ {[}←h{]}}. (Alternatively, since \texttt{h.symm} is a
proof of \texttt{t\ =\ s}, you can use \texttt{rewrite\ {[}h.symm{]}}.)
You can also apply the \texttt{rewrite} tactic to biconditional
statements. If you have \texttt{h\ :\ P\ ↔\ Q}, then
\texttt{rewrite\ {[}h{]}} will cause all occurrences of \texttt{P} in
the goal to be replaced with \texttt{Q} (and \texttt{rewrite\ {[}←h{]}}
will replace \texttt{Q} with \texttt{P}).

As with many other tactics, you can add \texttt{at\ h\textquotesingle{}}
to specify that the replacement should be done in the given
\texttt{h\textquotesingle{}} rather than the goal. In our case,
\texttt{rewrite\ {[}h8{]}\ at\ h4} will change both occurrences of
\texttt{b} in \texttt{h4} to \texttt{c}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_6\_4 (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U)}
\NormalTok{    (h1 : ∃ (x : U), x ∈ A ∩ B)}
\NormalTok{    (h2 : ∃ (x : U), x ∈ A ∩ C)}
\NormalTok{    (h3 : ∃! (x : U), x ∈ A) :}
\NormalTok{    ∃ (x : U), x ∈ B ∩ C := }\KeywordTok{by}
  \KeywordTok{obtain}\NormalTok{ (b : U) (h4 : b ∈ A ∩ B) }\KeywordTok{from}\NormalTok{ h1}
  \KeywordTok{obtain}\NormalTok{ (c : U) (h5 : c ∈ A ∩ C) }\KeywordTok{from}\NormalTok{ h2}
  \KeywordTok{obtain}\NormalTok{ (a : U) (h6 : a ∈ A) (h7 : ∀ (y z : U),}
\NormalTok{    y ∈ A → z ∈ A → y = z)  }\KeywordTok{from}\NormalTok{ h3}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h4; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h5}
  \KeywordTok{have}\NormalTok{ h8 : b = c := h7 b c h4.left h5.left}
  \KeywordTok{rewrite}\NormalTok{ [h8] }\KeywordTok{at}\NormalTok{ h4}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{U }\NormalTok{: Type}
\InformationTok{A B C }\NormalTok{: Set U}
\InformationTok{h1 }\NormalTok{: ∃ (x : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  x ∈ A ∩ B}
\InformationTok{h2 }\NormalTok{: ∃ (x : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  x ∈ A ∩ C}
\InformationTok{h3 }\NormalTok{: ∃! (x : U), x ∈ A}
\InformationTok{b c }\NormalTok{: U}
\InformationTok{h4 }\NormalTok{: c ∈ A ∧ c ∈ B}
\InformationTok{h5 }\NormalTok{: c ∈ A ∧ c ∈ C}
\InformationTok{a }\NormalTok{: U}
\InformationTok{h6 }\NormalTok{: a ∈ A}
\InformationTok{h7 }\NormalTok{: ∀ (y z : U),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  y ∈ A → z ∈ A → y = z}
\InformationTok{h8 }\NormalTok{: b = c}
\NormalTok{⊢ ∃ (x : U), x ∈ B ∩ C}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Now the right sides of \texttt{h4} and \texttt{h5} tell us that we can
prove the goal by plugging in \texttt{c} for \texttt{x}. Here is the
complete proof:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_6\_4 (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U)}
\NormalTok{    (h1 : ∃ (x : U), x ∈ A ∩ B)}
\NormalTok{    (h2 : ∃ (x : U), x ∈ A ∩ C)}
\NormalTok{    (h3 : ∃! (x : U), x ∈ A) :}
\NormalTok{    ∃ (x : U), x ∈ B ∩ C := }\KeywordTok{by}
  \KeywordTok{obtain}\NormalTok{ (b : U) (h4 : b ∈ A ∩ B) }\KeywordTok{from}\NormalTok{ h1}
  \KeywordTok{obtain}\NormalTok{ (c : U) (h5 : c ∈ A ∩ C) }\KeywordTok{from}\NormalTok{ h2}
  \KeywordTok{obtain}\NormalTok{ (a : U) (h6 : a ∈ A) (h7 : ∀ (y z : U),}
\NormalTok{    y ∈ A → z ∈ A → y = z)  }\KeywordTok{from}\NormalTok{ h3}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h4; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h5}
  \KeywordTok{have}\NormalTok{ h8 : b = c := h7 b c h4.left h5.left}
  \KeywordTok{rewrite}\NormalTok{ [h8] }\KeywordTok{at}\NormalTok{ h4}
  \KeywordTok{show}\NormalTok{ ∃ (x : U), x ∈ B ∩ C }\KeywordTok{from}
\NormalTok{    Exists.intro c (And.intro h4.right h5.right)}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

You might want to compare the Lean proof above to the proof of this
theorem as it appears in \emph{HTPI} (\emph{HTPI} p.~160):

\begin{thm}
Suppose \(A\), \(B\), and \(C\) are sets, \(A\) and \(B\) are not
disjoint, \(A\) and \(C\) are not disjoint, and \(A\) has exactly one
element. Then \(B\) and \(C\) are not disjoint

\end{thm}

\begin{proof}

Since \(A\) and \(B\) are not disjoint, we can let \(b\) be something
such that \(b \in A\) and \(b \in B\). Similarly, since \(A\) and \(C\)
are not disjoint, there is some object \(c\) such that \(c \in A\) and
\(c \in C\). Since \(A\) has only one element, we must have \(b = c\).
Thus \(b = c \in B \cap C\) and therefore \(B\) and \(C\) are not
disjoint. \excl{~□}\qedhere

\end{proof}

Before ending this section, we return to the question of how you can
tell if a theorem you want to use is in Lean's library. In an earlier
example, we guessed that the commutative law for ``or'' might be in
Lean's library, and we were then able to use the \texttt{\#check}
command to confirm it. But there is another technique that we could have
used: the tactic \texttt{apply?}, which asks Lean to search through its
library of theorems to see if there is one that could be applied to
prove the goal. Let's return to our proof of the theorem
\texttt{union\_comm}, which started like this:

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ union\_comm \{U : }\KeywordTok{Type}\NormalTok{\} (X Y : Set U) :}
\NormalTok{    X ∪ Y = Y ∪ X := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Set.ext}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{define}\NormalTok{ : x ∈ X ∪ Y}
  \KeywordTok{define}\NormalTok{ : x ∈ Y ∪ X}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ h}
\InformationTok{U }\NormalTok{: Type}
\InformationTok{X Y }\NormalTok{: Set U}
\InformationTok{x }\NormalTok{: U}
\NormalTok{⊢ x ∈ X ∨ x ∈ Y ↔}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  x ∈ Y ∨ x ∈ X}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Now let's give the \texttt{apply?} tactic a try.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ union\_comm \{U : }\KeywordTok{Type}\NormalTok{\} (X Y : Set U) :}
\NormalTok{    X ∪ Y = Y ∪ X := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Set.ext}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{define}\NormalTok{ : x ∈ X ∪ Y}
  \KeywordTok{define}\NormalTok{ : x ∈ Y ∪ X}
  \SpecialCharTok{++}\DocumentationTok{apply?}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

It takes a few seconds for Lean to search its library of theorems, but
eventually a blue squiggle appears under \texttt{apply?}, indicating
that the tactic has produced an answer. You will find the answer in the
Infoview pane: \texttt{Try\ this:\ exact\ Or.comm}. The word
\texttt{exact} is the name of a tactic that we have not discussed; it is
a shorthand for \texttt{show\ \_\ from}, where the blank gets filled in
with the goal. Thus, you can think of \texttt{apply?}'s answer as a
shortened form of the tactic

\begin{ind}

\begin{verbatim}
show x ∈ X ∨ x ∈ Y ↔ x ∈ Y ∨ x ∈ X from Or.comm
\end{verbatim}

\end{ind}

Usually your proof will be more readable if you use the \texttt{show}
tactic to state explicitly the goal that is being proven. This also
gives Lean a chance to correct you if you have become confused about
what goal you are proving. But sometimes---for example, if the goal is
very long---it is convenient to use the \texttt{exact} tactic instead.
You might think of \texttt{exact} as meaning ``the following is a
term-mode proof that is exactly what is needed to prove the goal.''

The \texttt{apply?} tactic has not only come up with a suggested tactic,
it has applied that tactic, and the proof is now complete. You can
confirm that the tactic completes the proof by replacing the line
\texttt{apply?} in the proof with either \texttt{apply?}'s suggested
\texttt{exact} tactic or the \texttt{show} tactic displayed above.

But what is \texttt{Or.comm}? The command \texttt{\#check\ @Or.comm}
gives the result

\begin{ind}

\begin{verbatim}
@Or.comm : ∀ {a b : Prop}, a ∨ b ↔ b ∨ a
\end{verbatim}

\end{ind}

So \texttt{Or.comm} is just another name for the theorem
\texttt{or\_comm}.

The \texttt{apply?} tactic is somewhat unpredictable; sometimes it is
able to find the right theorem in the library, and sometimes it isn't.
But it is always worth a try. Another way to try to find theorems is to
visit the documentation page for Lean's mathematics library, which can
be found at \url{https://leanprover-community.github.io/mathlib4_docs/}.

\hypertarget{exercises-4}{%
\subsection{Exercises}\label{exercises-4}}

\begin{numex}{1}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_4\_15 (U : }\KeywordTok{Type}\NormalTok{) (B : Set U) (F : Set (Set U)) :}
\NormalTok{    ⋃₀ \{ X : Set U | ∃ (A : Set U), A ∈ F ∧ X = A \textbackslash{} B \}}
\NormalTok{      ⊆ ⋃₀ (F \textbackslash{} 𝒫 B) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{2}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_5\_9 (U : }\KeywordTok{Type}\NormalTok{) (A B : Set U)}
\NormalTok{    (h1 : 𝒫 (A ∪ B) = 𝒫 A ∪ 𝒫 B) : A ⊆ B ∨ B ⊆ A := }\KeywordTok{by}
  \CommentTok{{-}{-}Hint:  Start like this:}
  \KeywordTok{have}\NormalTok{ h2 : A ∪ B ∈ 𝒫 (A ∪ B) := }\ConstantTok{sorry}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{3}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_6\_6b (U : }\KeywordTok{Type}\NormalTok{) :}
\NormalTok{    ∃! (A : Set U), ∀ (B : Set U), A ∪ B = A := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{4}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_6\_7b (U : }\KeywordTok{Type}\NormalTok{) :}
\NormalTok{    ∃! (A : Set U), ∀ (B : Set U), A ∩ B = A := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{5}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_6\_8a (U : }\KeywordTok{Type}\NormalTok{) : ∀ (A : Set U),}
\NormalTok{    ∃! (B : Set U), ∀ (C : Set U), C \textbackslash{} A = C ∩ B := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{6}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_6\_10 (U : }\KeywordTok{Type}\NormalTok{) (A : Set U)}
\NormalTok{    (h1 : ∀ (F : Set (Set U)), ⋃₀ F = A → A ∈ F) :}
\NormalTok{    ∃! (x : U), x ∈ A := }\KeywordTok{by}
  \CommentTok{{-}{-}Hint:  Start like this:}
  \KeywordTok{set}\NormalTok{ F0 : Set (Set U) := \{ X : Set U | X ⊆ A ∧ ∃! (x : U), x ∈ X \}}
  \CommentTok{{-}{-}Now F0 is in the tactic state, with the definition above}
  \KeywordTok{have}\NormalTok{ h2 : ⋃₀ F0 = A := }\ConstantTok{sorry}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{numex}

\hypertarget{more-examples-of-proofs}{%
\section{3.7. More Examples of Proofs}\label{more-examples-of-proofs}}

It is finally time to discuss proofs involving algebraic reasoning. Lean
has types for several different kinds of numbers. \texttt{Nat} is the
type of natural numbers---that is, the numbers 0, 1, 2, \ldots.
\texttt{Int} is the type of integers, \texttt{Rat} is the type of
rational numbers, \texttt{Real} is the type of real numbers, and
\texttt{Complex} is the type of complex numbers. Lean also uses the
notation \texttt{ℕ}, \texttt{ℤ}, \texttt{ℚ}, \texttt{ℝ}, and \texttt{ℂ}
for these types. (If you want to use those names for the number types,
you can enter them by typing \texttt{\textbackslash{}N},
\texttt{\textbackslash{}Z}, \texttt{\textbackslash{}Q},
\texttt{\textbackslash{}R}, and \texttt{\textbackslash{}C}.) To write
formulas involving arithmetic operations, you should use the symbols
\texttt{+} for addition, \texttt{-} for subtraction, \texttt{*} for
multiplication, \texttt{/} for division, and \texttt{\^{}} for
exponentiation. You can enter the symbols \texttt{≤}, \texttt{≥}, and
\texttt{≠} by typing \texttt{\textbackslash{}le},
\texttt{\textbackslash{}ge}, and \texttt{\textbackslash{}ne},
respectively. We will discuss some of the more subtle points of
algebraic reasoning in Chapter 6. For the moment, you are best off
avoiding subtraction and division when working with natural numbers and
avoiding division when working with integers.

To see what's involved in proving theorems about numbers in Lean, we'll
turn to a few examples from earlier in Chapter 3 of \emph{HTPI}. We
begin with Theorem 3.3.7, which concerns divisibility of integers. As in
\emph{HTPI}, for integers \texttt{x} and \texttt{y}, we will write
\texttt{x\ ∣\ y} to mean that \texttt{x} divides \texttt{y}, or
\texttt{y} is divisible by \texttt{x}. The formal definition is that
\texttt{x\ ∣\ y} means that there is an integer \texttt{k} such that
\texttt{y\ =\ x\ *\ k}. For example, \texttt{3\ ∣\ 12}, since
\texttt{12\ =\ 3\ *\ 4}. Lean knows this notation, but there is an
important warning: to type the vertical line that means ``divides,'' you
must type \texttt{\textbackslash{}\textbar{}}, not simply
\texttt{\textbar{}}. (There are two slightly different vertical line
symbols, and you have to look closely to see that they are different:
\texttt{\textbar{}} and \texttt{∣}. It is the second one that means
``divides'' in Lean, and to enter it you must type
\texttt{\textbackslash{}\textbar{}}.) Here is Theorem 3.3.7, written
using our usual rephrasing of a statement of the form
\texttt{A\ ∧\ B\ →\ C} as \texttt{A\ →\ B\ →\ C}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_3\_3\_7 :}
\NormalTok{    ∀ (a b c : Int), a ∣ b → b ∣ c → a ∣ c := }\KeywordTok{by}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{⊢ ∀ (a b c : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  a ∣ b → b ∣ c → a ∣ c}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Of course, we begin the proof by introducing arbitrary integers
\texttt{a}, \texttt{b}, and \texttt{c}, and assuming \texttt{a\ ∣\ b}
and \texttt{b\ ∣\ c}. We also write out the definitions of our
assumptions and the goal.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_3\_3\_7 :}
\NormalTok{    ∀ (a b c : Int), a ∣ b → b ∣ c → a ∣ c := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ a : Int; }\KeywordTok{fix}\NormalTok{ b : Int; }\KeywordTok{fix}\NormalTok{ c : Int}
  \KeywordTok{assume}\NormalTok{ h1 : a ∣ b; }\KeywordTok{assume}\NormalTok{ h2 : b ∣ c}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h2; }\KeywordTok{define}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{a b c }\NormalTok{: ℤ}
\InformationTok{h1 }\NormalTok{: ∃ (c : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  b = a * c}
\InformationTok{h2 }\NormalTok{: ∃ (c\_1 : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  c = b * c\_1}
\NormalTok{⊢ ∃ (c\_1 : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  c = a * c\_1}
\end{Highlighting}
\end{Shaded}

\end{outpt}

We always use existential givens right away, so we use \texttt{h1} and
\texttt{h2} to introduce two new variables, \texttt{m} and \texttt{n}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_3\_3\_7 :}
\NormalTok{    ∀ (a b c : Int), a ∣ b → b ∣ c → a ∣ c := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ a : Int; }\KeywordTok{fix}\NormalTok{ b : Int; }\KeywordTok{fix}\NormalTok{ c : Int}
  \KeywordTok{assume}\NormalTok{ h1 : a ∣ b; }\KeywordTok{assume}\NormalTok{ h2 : b ∣ c}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h2; }\KeywordTok{define}
  \KeywordTok{obtain}\NormalTok{ (m : Int) (h3 : b = a * m) }\KeywordTok{from}\NormalTok{ h1}
  \KeywordTok{obtain}\NormalTok{ (n : Int) (h4 : c = b * n) }\KeywordTok{from}\NormalTok{ h2}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{a b c }\NormalTok{: ℤ}
\InformationTok{h1 }\NormalTok{: ∃ (c : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  b = a * c}
\InformationTok{h2 }\NormalTok{: ∃ (c\_1 : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  c = b * c\_1}
\InformationTok{m }\NormalTok{: ℤ}
\InformationTok{h3 }\NormalTok{: b = a * m}
\InformationTok{n }\NormalTok{: ℤ}
\InformationTok{h4 }\NormalTok{: c = b * n}
\NormalTok{⊢ ∃ (c\_1 : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  c = a * c\_1}
\end{Highlighting}
\end{Shaded}

\end{outpt}

If we substitute the value for \texttt{b} given in \texttt{h3} into
\texttt{h4}, we will see how to reach the goal. Of course, the
\texttt{rewrite} tactic is what we need for this.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_3\_3\_7 :}
\NormalTok{    ∀ (a b c : Int), a ∣ b → b ∣ c → a ∣ c := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ a : Int; }\KeywordTok{fix}\NormalTok{ b : Int; }\KeywordTok{fix}\NormalTok{ c : Int}
  \KeywordTok{assume}\NormalTok{ h1 : a ∣ b; }\KeywordTok{assume}\NormalTok{ h2 : b ∣ c}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h2; }\KeywordTok{define}
  \KeywordTok{obtain}\NormalTok{ (m : Int) (h3 : b = a * m) }\KeywordTok{from}\NormalTok{ h1}
  \KeywordTok{obtain}\NormalTok{ (n : Int) (h4 : c = b * n) }\KeywordTok{from}\NormalTok{ h2}
  \KeywordTok{rewrite}\NormalTok{ [h3] }\KeywordTok{at}\NormalTok{ h4   }\CommentTok{{-}{-}h4 : c = a * m * n}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{a b c }\NormalTok{: ℤ}
\InformationTok{h1 }\NormalTok{: ∃ (c : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  b = a * c}
\InformationTok{h2 }\NormalTok{: ∃ (c\_1 : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  c = b * c\_1}
\InformationTok{m }\NormalTok{: ℤ}
\InformationTok{h3 }\NormalTok{: b = a * m}
\InformationTok{n }\NormalTok{: ℤ}
\InformationTok{h4 }\NormalTok{: c = a * m * n}
\NormalTok{⊢ ∃ (c\_1 : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  c = a * c\_1}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Looking at \texttt{h4}, we see that the value we should use for
\texttt{c\_1} in the goal is \texttt{m\ *\ n}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_3\_3\_7 :}
\NormalTok{    ∀ (a b c : Int), a ∣ b → b ∣ c → a ∣ c := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ a : Int; }\KeywordTok{fix}\NormalTok{ b : Int; }\KeywordTok{fix}\NormalTok{ c : Int}
  \KeywordTok{assume}\NormalTok{ h1 : a ∣ b; }\KeywordTok{assume}\NormalTok{ h2 : b ∣ c}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h2; }\KeywordTok{define}
  \KeywordTok{obtain}\NormalTok{ (m : Int) (h3 : b = a * m) }\KeywordTok{from}\NormalTok{ h1}
  \KeywordTok{obtain}\NormalTok{ (n : Int) (h4 : c = b * n) }\KeywordTok{from}\NormalTok{ h2}
  \KeywordTok{rewrite}\NormalTok{ [h3] }\KeywordTok{at}\NormalTok{ h4   }\CommentTok{{-}{-}h4 : c = a * m * n}
  \KeywordTok{apply}\NormalTok{ Exists.intro (m * n)}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{a b c }\NormalTok{: ℤ}
\InformationTok{h1 }\NormalTok{: ∃ (c : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  b = a * c}
\InformationTok{h2 }\NormalTok{: ∃ (c\_1 : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  c = b * c\_1}
\InformationTok{m }\NormalTok{: ℤ}
\InformationTok{h3 }\NormalTok{: b = a * m}
\InformationTok{n }\NormalTok{: ℤ}
\InformationTok{h4 }\NormalTok{: c = a * m * n}
\NormalTok{⊢ c = a * (m * n)}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Note that in the application of \texttt{Exists.intro}, the parentheses
around \texttt{m\ *\ n} are necessary to help Lean parse the line
correctly. Comparing \texttt{h4} to the goal, you might think that we
can finish the proof with
\texttt{show\ c\ =\ a\ *\ (m\ *\ n)\ from\ h4}. But if you try it, you
will get an error message. What's the problem? The difference in the
parentheses is the clue. Lean groups the arithmetic operations
\texttt{+}, \texttt{-}, \texttt{*}, and \texttt{/} to the left, so
\texttt{h4} means \texttt{h4\ :\ c\ =\ (a\ *\ m)\ *\ n}, which is not
quite the same as the goal. To prove the goal, we will need to apply the
associative law for multiplication.

We have already seen that \texttt{and\_assoc} is Lean's name for the
associative law for ``and''. Perhaps you can guess that the name for the
associative law for multiplication is \texttt{mul\_assoc}. If you type
\texttt{\#check\ @mul\_assoc}, Lean's response will be:

\begin{ind}

\begin{verbatim}
@mul_assoc : ∀ {G : Type u_1} [inst : Semigroup G] (a b c : G),
              a * b * c = a * (b * c)
\end{verbatim}

\end{ind}

The implicit arguments in this cases are a little complicated (the
expression \texttt{{[}inst\ :\ Semigroup\ G{]}} represents yet another
kind of implicit argument). But what they mean is that
\texttt{mul\_assoc} can be used to prove any statement of the form
\texttt{∀\ (a\ b\ c\ :\ G),\ a\ *\ b\ *\ c\ =\ a\ *\ (b\ *\ c)}, as long
as \texttt{G} is a type that has an associative multiplication
operation. In particular, \texttt{mul\_assoc} can be used as a proof of
\texttt{∀\ (a\ b\ c\ :\ Int),\ a\ *\ b\ *\ c\ =\ a\ *\ (b\ *\ c)}.
(There are also versions of this theorem for particular number types.
You can use the \texttt{\#check} command to verify the theorems
\texttt{Nat.mul\_assoc\ :\ ∀\ (a\ b\ c\ :\ ℕ),\ a\ *\ b\ *\ c\ =\ a\ *\ (b\ *\ c)},
\texttt{Int.mul\_assoc\ :\ ∀\ (a\ b\ c\ :\ ℤ),\ a\ *\ b\ *\ c\ =\ a\ *\ (b\ *\ c)},
and so on.)

Returning to our proof of Theorem 3.3.7, by three applications of
universal instantiation, \texttt{mul\_assoc\ a\ m\ n} is a proof of
\texttt{a\ *\ m\ *\ n\ =\ a\ *\ (m\ *\ n)}, and that is exactly what we
need to finish the proof. The tactic
\texttt{rewrite\ {[}mul\_assoc\ a\ m\ n{]}\ at\ h4} will replace
\texttt{a\ *\ m\ *\ n} in \texttt{h4} with \texttt{a\ *\ (m\ *\ n)}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_3\_3\_7 :}
\NormalTok{    ∀ (a b c : Int), a ∣ b → b ∣ c → a ∣ c := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ a : Int; }\KeywordTok{fix}\NormalTok{ b : Int; }\KeywordTok{fix}\NormalTok{ c : Int}
  \KeywordTok{assume}\NormalTok{ h1 : a ∣ b; }\KeywordTok{assume}\NormalTok{ h2 : b ∣ c}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h2; }\KeywordTok{define}
  \KeywordTok{obtain}\NormalTok{ (m : Int) (h3 : b = a * m) }\KeywordTok{from}\NormalTok{ h1}
  \KeywordTok{obtain}\NormalTok{ (n : Int) (h4 : c = b * n) }\KeywordTok{from}\NormalTok{ h2}
  \KeywordTok{rewrite}\NormalTok{ [h3] }\KeywordTok{at}\NormalTok{ h4   }\CommentTok{{-}{-}h4 : c = a * m * n}
  \KeywordTok{apply}\NormalTok{ Exists.intro (m * n)}
  \KeywordTok{rewrite}\NormalTok{ [mul\_assoc a m n] }\KeywordTok{at}\NormalTok{ h4}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{a b c }\NormalTok{: ℤ}
\InformationTok{h1 }\NormalTok{: ∃ (c : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  b = a * c}
\InformationTok{h2 }\NormalTok{: ∃ (c\_1 : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  c = b * c\_1}
\InformationTok{m }\NormalTok{: ℤ}
\InformationTok{h3 }\NormalTok{: b = a * m}
\InformationTok{n }\NormalTok{: ℤ}
\InformationTok{h4 }\NormalTok{: c = a * (m * n)}
\NormalTok{⊢ c = a * (m * n)}
\end{Highlighting}
\end{Shaded}

\end{outpt}

By the way, this is a case in which Lean could have figured out some
details on its own. If we had used
\texttt{rewrite\ {[}mul\_assoc\ \_\ \_\ \_{]}\ at\ h4}, then Lean would
have figured out that the blanks had to be filled in with \texttt{a},
\texttt{m}, and \texttt{n}. And as with the \texttt{apply} tactic,
blanks at the end of \texttt{rewrite} rules can be left out, so even
\texttt{rewrite\ {[}mul\_assoc{]}\ at\ h4} would have worked.

Of course, now \texttt{h4} really does match the goal exactly, so we can
use it to complete the proof.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_3\_3\_7 :}
\NormalTok{    ∀ (a b c : Int), a ∣ b → b ∣ c → a ∣ c := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ a : Int; }\KeywordTok{fix}\NormalTok{ b : Int; }\KeywordTok{fix}\NormalTok{ c : Int}
  \KeywordTok{assume}\NormalTok{ h1 : a ∣ b; }\KeywordTok{assume}\NormalTok{ h2 : b ∣ c}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h2; }\KeywordTok{define}
  \KeywordTok{obtain}\NormalTok{ (m : Int) (h3 : b = a * m) }\KeywordTok{from}\NormalTok{ h1}
  \KeywordTok{obtain}\NormalTok{ (n : Int) (h4 : c = b * n) }\KeywordTok{from}\NormalTok{ h2}
  \KeywordTok{rewrite}\NormalTok{ [h3] }\KeywordTok{at}\NormalTok{ h4   }\CommentTok{{-}{-}h4 : c = a * m * n}
  \KeywordTok{apply}\NormalTok{ Exists.intro (m * n)}
  \KeywordTok{rewrite}\NormalTok{ [mul\_assoc a m n] }\KeywordTok{at}\NormalTok{ h4}
  \KeywordTok{show}\NormalTok{ c = a * (m * n) }\KeywordTok{from}\NormalTok{ h4}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

As usual, you might find it instructive to compare the Lean proof above
to the proof of this theorem in \emph{HTPI}.

For our next example, we'll do a somewhat more complex proof concerning
divisibility. Here is the proof from \emph{HTPI} (\emph{HTPI} p.~139).

\begin{nthm}{Theorem 3.4.7}
For every integer \(n\), \(6 \mid n\) iff \(2 \mid n\) and \(3 \mid n\).

\end{nthm}

\begin{proof}

Let \(n\) be an arbitrary integer.

(\(\to\)) Suppose \(6 \mid n\). Then we can choose an integer \(k\) such
that \(6k=n\). Therefore \(n = 6k = 2(3k)\), so \(2 \mid n\), and
similarly \(n = 6k = 3(2k)\), so \(3 \mid n\).

(\(\leftarrow\)) Suppose \(2 \mid n\) and \(3 \mid n\). Then we can
choose integers \(j\) and \(k\) such that \(n = 2j\) and \(n = 3k\).
Therefore \(6(j-k) = 6j - 6k = 3(2j) - 2(3k) = 3n - 2n = n\), so
\(6 \mid n\). \excl{~□}\qedhere

\end{proof}

Let's try writing the proof in Lean. We use exactly the same strategy as
in the \emph{HTPI} proof: we begin by fixing an arbitrary integer
\texttt{n}, and then we prove the two directions of the biconditional
separately.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_3\_4\_7 :}
\NormalTok{    ∀ (n : Int), 6 ∣ n ↔ 2 ∣ n ∧ 3 ∣ n := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ n : Int}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ mp}
\InformationTok{n }\NormalTok{: ℤ}
\NormalTok{⊢ 6 ∣ n → 2 ∣ n ∧ 3 ∣ n}
\RegionMarkerTok{case}\NormalTok{ mpr}
\InformationTok{n }\NormalTok{: ℤ}
\NormalTok{⊢ 2 ∣ n ∧ 3 ∣ n → 6 ∣ n}
\end{Highlighting}
\end{Shaded}

\end{outpt}

For the left-to-right direction, we assume \texttt{6\ ∣\ n}, and since
the definition of this assumption is an existential statement, we
immediately apply existential instantiation.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_3\_4\_7 :}
\NormalTok{    ∀ (n : Int), 6 ∣ n ↔ 2 ∣ n ∧ 3 ∣ n := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ n : Int}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h1 : 6 ∣ n; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
    \KeywordTok{obtain}\NormalTok{ (k : Int) (h2 : n = 6 * k) }\KeywordTok{from}\NormalTok{ h1}
    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\NormalTok{  · }\CommentTok{{-}{-} (←)}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ mp}
\InformationTok{n }\NormalTok{: ℤ}
\InformationTok{h1 }\NormalTok{: ∃ (c : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  n = 6 * c}
\InformationTok{k }\NormalTok{: ℤ}
\InformationTok{h2 }\NormalTok{: n = 6 * k}
\NormalTok{⊢ 2 ∣ n ∧ 3 ∣ n}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Our goal is now a conjunction, so we prove the two conjuncts separately.
Focusing just on the first one, \texttt{2\ ∣\ n}, we write out the
definition to decide how to proceed.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_3\_4\_7 :}
\NormalTok{    ∀ (n : Int), 6 ∣ n ↔ 2 ∣ n ∧ 3 ∣ n := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ n : Int}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h1 : 6 ∣ n; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
    \KeywordTok{obtain}\NormalTok{ (k : Int) (h2 : n = 6 * k) }\KeywordTok{from}\NormalTok{ h1}
    \KeywordTok{apply}\NormalTok{ And.intro}
\NormalTok{    · }\CommentTok{{-}{-} Proof that 2 ∣ n}
      \KeywordTok{define}
      \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\NormalTok{    · }\CommentTok{{-}{-} Proof that 3 ∣ n}

      \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} (←)}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ mp.left}
\InformationTok{n }\NormalTok{: ℤ}
\InformationTok{h1 }\NormalTok{: ∃ (c : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  n = 6 * c}
\InformationTok{k }\NormalTok{: ℤ}
\InformationTok{h2 }\NormalTok{: n = 6 * k}
\NormalTok{⊢ ∃ (c : ℤ), n = 2 * c}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Since we have \texttt{n\ =\ 6\ *\ k\ =\ 2\ *\ 3\ *\ k}, it looks like
\texttt{3\ *\ k} is the value we should use for \texttt{c}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_3\_4\_7 :}
\NormalTok{    ∀ (n : Int), 6 ∣ n ↔ 2 ∣ n ∧ 3 ∣ n := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ n : Int}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h1 : 6 ∣ n; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
    \KeywordTok{obtain}\NormalTok{ (k : Int) (h2 : n = 6 * k) }\KeywordTok{from}\NormalTok{ h1}
    \KeywordTok{apply}\NormalTok{ And.intro}
\NormalTok{    · }\CommentTok{{-}{-} Proof that 2 ∣ n}
      \KeywordTok{define}
      \KeywordTok{apply}\NormalTok{ Exists.intro (3 * k)}
      \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\NormalTok{    · }\CommentTok{{-}{-} Proof that 3 ∣ n}

      \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} (←)}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ mp.left}
\InformationTok{n }\NormalTok{: ℤ}
\InformationTok{h1 }\NormalTok{: ∃ (c : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  n = 6 * c}
\InformationTok{k }\NormalTok{: ℤ}
\InformationTok{h2 }\NormalTok{: n = 6 * k}
\NormalTok{⊢ n = 2 * (3 * k)}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Once again, if you think carefully about it, you will see that in order
to deduce the goal from \texttt{h2}, we will need to use the
associativity of multiplication to rewrite the goal as
\texttt{n\ =\ 2\ *\ 3\ *\ k}. As we have already seen,
\texttt{mul\_assoc\ 2\ 3\ k} is a proof of
\texttt{2\ *\ 3\ *\ k\ =\ 2\ *\ (3\ *\ k)}. Since we want to replace the
right side of this equation with the left in the goal, we'll use the
tactic \texttt{rewrite\ {[}←mul\_assoc\ 2\ 3\ k{]}}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_3\_4\_7 :}
\NormalTok{    ∀ (n : Int), 6 ∣ n ↔ 2 ∣ n ∧ 3 ∣ n := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ n : Int}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h1 : 6 ∣ n; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
    \KeywordTok{obtain}\NormalTok{ (k : Int) (h2 : n = 6 * k) }\KeywordTok{from}\NormalTok{ h1}
    \KeywordTok{apply}\NormalTok{ And.intro}
\NormalTok{    · }\CommentTok{{-}{-} Proof that 2 ∣ n}
      \KeywordTok{define}
      \KeywordTok{apply}\NormalTok{ Exists.intro (3 * k)}
      \KeywordTok{rewrite}\NormalTok{ [←mul\_assoc 2 3 k]}
      \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\NormalTok{    · }\CommentTok{{-}{-} Proof that 3 ∣ n}

      \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} (←)}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ mp.left}
\InformationTok{n }\NormalTok{: ℤ}
\InformationTok{h1 }\NormalTok{: ∃ (c : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  n = 6 * c}
\InformationTok{k }\NormalTok{: ℤ}
\InformationTok{h2 }\NormalTok{: n = 6 * k}
\NormalTok{⊢ n = 2 * 3 * k}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Do we have to convince Lean that \texttt{2\ *\ 3\ =\ 6}? No, remember
that Lean works out definitions on its own. Lean knows the definition of
multiplication, and it knows that, according to that definition,
\texttt{2\ *\ 3} is equal to \texttt{6}. So it regards
\texttt{n\ =\ 6\ *\ k} and \texttt{n\ =\ 2\ *\ 3\ *\ k} as
definitionally equal, and therefore it will recognize \texttt{h2} as a
proof of the goal.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_3\_4\_7 :}
\NormalTok{    ∀ (n : Int), 6 ∣ n ↔ 2 ∣ n ∧ 3 ∣ n := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ n : Int}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h1 : 6 ∣ n; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
    \KeywordTok{obtain}\NormalTok{ (k : Int) (h2 : n = 6 * k) }\KeywordTok{from}\NormalTok{ h1}
    \KeywordTok{apply}\NormalTok{ And.intro}
\NormalTok{    · }\CommentTok{{-}{-} Proof that 2 ∣ n}
      \KeywordTok{define}
      \KeywordTok{apply}\NormalTok{ Exists.intro (3 * k)}
      \KeywordTok{rewrite}\NormalTok{ [←mul\_assoc 2 3 k]}
      \KeywordTok{show}\NormalTok{ n = 2 * 3 * k }\KeywordTok{from}\NormalTok{ h2}
      \KeywordTok{done}
\NormalTok{    · }\CommentTok{{-}{-} Proof that 3 ∣ n}

      \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} (←)}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ mp.right}
\InformationTok{n }\NormalTok{: ℤ}
\InformationTok{h1 }\NormalTok{: ∃ (c : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  n = 6 * c}
\InformationTok{k }\NormalTok{: ℤ}
\InformationTok{h2 }\NormalTok{: n = 6 * k}
\NormalTok{⊢ 3 ∣ n}
\end{Highlighting}
\end{Shaded}

\end{outpt}

The proof of the next goal, \texttt{3\ ∣\ n}, is similar, and it
completes the left-to-right direction of the biconditional.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_3\_4\_7 :}
\NormalTok{    ∀ (n : Int), 6 ∣ n ↔ 2 ∣ n ∧ 3 ∣ n := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ n : Int}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h1 : 6 ∣ n; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
    \KeywordTok{obtain}\NormalTok{ (k : Int) (h2 : n = 6 * k) }\KeywordTok{from}\NormalTok{ h1}
    \KeywordTok{apply}\NormalTok{ And.intro}
\NormalTok{    · }\CommentTok{{-}{-} Proof that 2 ∣ n}
      \KeywordTok{define}
      \KeywordTok{apply}\NormalTok{ Exists.intro (3 * k)}
      \KeywordTok{rewrite}\NormalTok{ [←mul\_assoc 2 3 k]}
      \KeywordTok{show}\NormalTok{ n = 2 * 3 * k }\KeywordTok{from}\NormalTok{ h2}
      \KeywordTok{done}
\NormalTok{    · }\CommentTok{{-}{-} Proof that 3 ∣ n}
      \KeywordTok{define}
      \KeywordTok{apply}\NormalTok{ Exists.intro (2 * k)}
      \KeywordTok{rewrite}\NormalTok{ [←mul\_assoc 3 2 k]}
      \KeywordTok{show}\NormalTok{ n = 3 * 2 * k }\KeywordTok{from}\NormalTok{ h2}
      \KeywordTok{done}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} (←)}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ mpr}
\InformationTok{n }\NormalTok{: ℤ}
\NormalTok{⊢ 2 ∣ n ∧ 3 ∣ n → 6 ∣ n}
\end{Highlighting}
\end{Shaded}

\end{outpt}

For the right-to-left direction, we begin by assuming
\texttt{2\ ∣\ n\ ∧\ 3\ ∣\ n}. We write out the definitions of
\texttt{2\ ∣\ n} and \texttt{3\ ∣\ n}, and since this gives us two
existential givens, we apply existential instantiation twice. To save
space, we won't repeat the proof of the first half of the proof in the
displays below.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_3\_4\_7 :}
\NormalTok{    ∀ (n : Int), 6 ∣ n ↔ 2 ∣ n ∧ 3 ∣ n := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ n : Int}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
\NormalTok{    ...}
\NormalTok{  · }\CommentTok{{-}{-} (←)}
    \KeywordTok{assume}\NormalTok{ h1 : 2 ∣ n ∧ 3 ∣ n}
    \KeywordTok{have}\NormalTok{ h2 : 2 ∣ n := h1.left}
    \KeywordTok{have}\NormalTok{ h3 : 3 ∣ n := h1.right}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h3; }\KeywordTok{define}
    \KeywordTok{obtain}\NormalTok{ (j : Int) (h4 : n = 2 * j) }\KeywordTok{from}\NormalTok{ h2}
    \KeywordTok{obtain}\NormalTok{ (k : Int) (h5 : n = 3 * k) }\KeywordTok{from}\NormalTok{ h3}
    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ mpr}
\InformationTok{n }\NormalTok{: ℤ}
\InformationTok{h1 }\NormalTok{: 2 ∣ n ∧ 3 ∣ n}
\InformationTok{h2 }\NormalTok{: ∃ (c : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  n = 2 * c}
\InformationTok{h3 }\NormalTok{: ∃ (c : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  n = 3 * c}
\InformationTok{j }\NormalTok{: ℤ}
\InformationTok{h4 }\NormalTok{: n = 2 * j}
\InformationTok{k }\NormalTok{: ℤ}
\InformationTok{h5 }\NormalTok{: n = 3 * k}
\NormalTok{⊢ ∃ (c : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  n = 6 * c}
\end{Highlighting}
\end{Shaded}

\end{outpt}

The next step in the \emph{HTPI} proof is a string of equations that
proves \(6(j - k) = n\), which establishes that \(6 \mid n\). Let's try
to do the same thing in Lean, using a calculational proof:

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem} \SpecialCharTok{??}\AnnotationTok{Theorem\_3\_4\_7}\SpecialCharTok{::}\NormalTok{ :}
\NormalTok{    ∀ (n : Int), 6 ∣ n ↔ 2 ∣ n ∧ 3 ∣ n := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ n : Int}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
\NormalTok{    ...}
\NormalTok{  · }\CommentTok{{-}{-} (←)}
    \KeywordTok{assume}\NormalTok{ h1 : 2 ∣ n ∧ 3 ∣ n}
    \KeywordTok{have}\NormalTok{ h2 : 2 ∣ n := h1.left}
    \KeywordTok{have}\NormalTok{ h3 : 3 ∣ n := h1.right}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h3; }\KeywordTok{define}
    \KeywordTok{obtain}\NormalTok{ (j : Int) (h4 : n = 2 * j) }\KeywordTok{from}\NormalTok{ h2}
    \KeywordTok{obtain}\NormalTok{ (k : Int) (h5 : n = 3 * k) }\KeywordTok{from}\NormalTok{ h3}
    \KeywordTok{have}\NormalTok{ h6 : 6 * (j {-} k) = n :=}
      \KeywordTok{calc}\NormalTok{ 6 * (j {-} k)}
\NormalTok{        \_ = 6 * j {-} 6 * k := }\ConstantTok{sorry}
\NormalTok{        \_ = 3 * (2 * j) {-} 2 * (3 * k) := }\ConstantTok{sorry}
\NormalTok{        \_ = 3 * n {-} 2 * n := }\ConstantTok{sorry}
\NormalTok{        \_ = (3 {-} 2) * n := }\ConstantTok{sorry}
\NormalTok{        \_ = n := }\ConstantTok{sorry}
    \KeywordTok{show}\NormalTok{ ∃ (c : Int), n = 6 * c }\KeywordTok{from}
\NormalTok{      Exists.intro (j {-} k) h6.symm}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialStringTok{No}\InformationTok{ }\SpecialStringTok{goals}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Sometimes the easiest way to write a calculational proof is to justify
each line with \texttt{sorry} and then go back and fill in real
justifications. Lean has accepted the proof above, so we know that we'll
have a complete proof if we can replace each \texttt{sorry} with a
justification.

To justify the first line of the calculational proof, try replacing
\texttt{sorry} with \texttt{by\ apply?}. Lean comes up with a
justification: \texttt{Int.mul\_sub\ 6\ j\ k}. The command
\texttt{\#check\ @Int.mul\_sub} tells us that the theorem
\texttt{Int.mul\_sub} means

\begin{ind}

\begin{verbatim}
Int.mul_sub : ∀ (a b c : ℤ), a * (b - c) = a * b - a * c
\end{verbatim}

\end{ind}

Thus, we can fill in \texttt{Int.mul\_sub\ 6\ j\ k} as a proof of the
first equation.

It looks like we'll have to use the associativity of multiplication
again to prove the second equation, but it will take more than one step.
Let's try writing a tactic-mode proof. In the display below, we'll just
focus on the calculational proof.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{have}\NormalTok{ h6 : 6 * (j {-} k) = n :=}
  \KeywordTok{calc}\NormalTok{ 6 * (j {-} k)}
\NormalTok{    \_ = 6 * j {-} 6 * k := Int.mul\_sub 6 j k}
\NormalTok{    \_ = 3 * (2 * j) {-} 2 * (3 * k) := }\KeywordTok{by}

          \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\NormalTok{    \_ = 3 * n {-} 2 * n := }\ConstantTok{sorry}
\NormalTok{    \_ = (3 {-} 2) * n := }\ConstantTok{sorry}
\NormalTok{    \_ = n := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{n }\NormalTok{: ℤ}
\InformationTok{h1 }\NormalTok{: 2 ∣ n ∧ 3 ∣ n}
\InformationTok{h2 }\NormalTok{: ∃ (c : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  n = 2 * c}
\InformationTok{h3 }\NormalTok{: ∃ (c : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  n = 3 * c}
\InformationTok{j }\NormalTok{: ℤ}
\InformationTok{h4 }\NormalTok{: n = 2 * j}
\InformationTok{k }\NormalTok{: ℤ}
\InformationTok{h5 }\NormalTok{: n = 3 * k}
\NormalTok{⊢ 6 * j {-} 6 * k =}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  3 * (2 * j) {-}}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    2 * (3 * k)}
\end{Highlighting}
\end{Shaded}

\end{outpt}

To justify the second equation, we'll have to use associativity to
rewrite both \texttt{3\ *\ (2\ *\ j)} as \texttt{3\ *\ 2\ *\ j} and also
\texttt{2\ *\ (3\ *\ k)} as \texttt{2\ *\ 3\ *\ k}. So we apply the
\texttt{rewrite} tactic to both of the proofs
\texttt{mul\_assoc\ 3\ 2\ j\ :\ 3\ *\ 2\ *\ j\ =\ 3\ *\ (2\ *\ j)} and
\texttt{mul\_assoc\ 2\ 3\ k\ :\ 2\ *\ 3\ *\ k\ =\ 2\ *\ (3\ *\ k)}:

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{have}\NormalTok{ h6 : 6 * (j {-} k) = n :=}
  \KeywordTok{calc}\NormalTok{ 6 * (j {-} k)}
\NormalTok{    \_ = 6 * j {-} 6 * k := Int.mul\_sub 6 j k}
\NormalTok{    \_ = 3 * (2 * j) {-} 2 * (3 * k) := }\KeywordTok{by}
          \KeywordTok{rewrite}\NormalTok{ [←mul\_assoc 3 2 j]}
          \KeywordTok{rewrite}\NormalTok{ [←mul\_assoc 2 3 k]}
          \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\NormalTok{    \_ = 3 * n {-} 2 * n := }\ConstantTok{sorry}
\NormalTok{    \_ = (3 {-} 2) * n := }\ConstantTok{sorry}
\NormalTok{    \_ = n := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{n }\NormalTok{: ℤ}
\InformationTok{h1 }\NormalTok{: 2 ∣ n ∧ 3 ∣ n}
\InformationTok{h2 }\NormalTok{: ∃ (c : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  n = 2 * c}
\InformationTok{h3 }\NormalTok{: ∃ (c : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  n = 3 * c}
\InformationTok{j }\NormalTok{: ℤ}
\InformationTok{h4 }\NormalTok{: n = 2 * j}
\InformationTok{k }\NormalTok{: ℤ}
\InformationTok{h5 }\NormalTok{: n = 3 * k}
\NormalTok{⊢ 6 * j {-} 6 * k =}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  3 * 2 * j {-} }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    2 * 3 * k}
\end{Highlighting}
\end{Shaded}

\end{outpt}

To finish off the justification of the second equation, we'll use the
theorem \texttt{Eq.refl}. The command \texttt{\#check\ @Eq.refl} gives
the result

\begin{ind}

\begin{verbatim}
@Eq.refl : ∀ {α : Sort u_1} (a : α), a = a
\end{verbatim}

\end{ind}

Ignoring the implicit argument \texttt{α}, this should remind you of the
theorem \texttt{Iff.refl\ :\ ∀\ (a\ :\ Prop),\ a\ ↔\ a}. Recall that we
were able to use \texttt{Iff.refl\ \_} to prove not only any statement
of the form \texttt{a\ ↔\ a}, but also statements of the form
\texttt{a\ ↔\ a\textquotesingle{}}, where \texttt{a} and
\texttt{a\textquotesingle{}} are definitionally equal. Similarly,
\texttt{Eq.refl\ \_} will prove any equation of the form
\texttt{a\ =\ a\textquotesingle{}}, where \texttt{a} and
\texttt{a\textquotesingle{}} are definitionally equal. Since Lean knows
that, by definition, \texttt{3\ *\ 2\ =\ 6} and \texttt{2\ *\ 3\ =\ 6},
the goal has this form. Thus we can complete the proof with the tactic
\texttt{show\ 6\ *\ j\ -\ 6\ *\ k\ =\ 3\ *\ 2\ *\ j\ -\ 2\ *\ 3\ *\ k\ from\ Eq.refl\ \_}.
As we saw earlier, a shorter version of this would be
\texttt{exact\ Eq.refl\ \_}. But this situation comes up often enough
that there is an even shorter version: the tactic \texttt{rfl} can be
used as a shorthand for either \texttt{exact\ Eq.refl\ \_} or
\texttt{exact\ Iff.refl\ \_}. In other words, in a tactic-mode proof, if
the goal has one of the forms \texttt{a\ =\ a\textquotesingle{}} or
\texttt{a\ ↔\ a\textquotesingle{}}, where \texttt{a} and
\texttt{a\textquotesingle{}} are definitionally equal, then the tactic
\texttt{rfl} will prove the goal. So \texttt{rfl} will finish off the
justification of the second equation, and we can move on to the third.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{have}\NormalTok{ h6 : 6 * (j {-} k) = n :=}
  \KeywordTok{calc}\NormalTok{ 6 * (j {-} k)}
\NormalTok{    \_ = 6 * j {-} 6 * k := Int.mul\_sub 6 j k}
\NormalTok{    \_ = 3 * (2 * j) {-} 2 * (3 * k) := }\KeywordTok{by}
          \KeywordTok{rewrite}\NormalTok{ [←mul\_assoc 3 2 j]}
          \KeywordTok{rewrite}\NormalTok{ [←mul\_assoc 2 3 k]}
          \KeywordTok{rfl}
          \KeywordTok{done}
\NormalTok{    \_ = 3 * n {-} 2 * n := }\KeywordTok{by}

          \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\NormalTok{    \_ = (3 {-} 2) * n := }\ConstantTok{sorry}
\NormalTok{    \_ = n := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{n }\NormalTok{: ℤ}
\InformationTok{h1 }\NormalTok{: 2 ∣ n ∧ 3 ∣ n}
\InformationTok{h2 }\NormalTok{: ∃ (c : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  n = 2 * c}
\InformationTok{h3 }\NormalTok{: ∃ (c : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  n = 3 * c}
\InformationTok{j }\NormalTok{: ℤ}
\InformationTok{h4 }\NormalTok{: n = 2 * j}
\InformationTok{k }\NormalTok{: ℤ}
\InformationTok{h5 }\NormalTok{: n = 3 * k}
\NormalTok{⊢ 3 * (2 * j) {-}}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  2 * (3 * k) =}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    3 * n {-} 2 * n}
\end{Highlighting}
\end{Shaded}

\end{outpt}

To justify the third equation we have to substitute \texttt{n} for both
\texttt{2\ *\ j} and \texttt{3\ *\ k}. We can use \texttt{h4} and
\texttt{h5} in the rewrite tactic to do this. In fact, we can do it in
one step: you can put a list of proofs of equations or biconditionals
inside the brackets, and the \texttt{rewrite} tactic will perform all of
the replacements, one after another. In our case, the tactic
\texttt{rewrite\ {[}←h4,\ ←h5{]}} will first replace \texttt{2\ *\ j} in
the goal with \texttt{n}, and then it will replace \texttt{3\ *\ k} with
\texttt{n}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{have}\NormalTok{ h6 : 6 * (j {-} k) = n :=}
  \KeywordTok{calc}\NormalTok{ 6 * (j {-} k)}
\NormalTok{    \_ = 6 * j {-} 6 * k := Int.mul\_sub 6 j k}
\NormalTok{    \_ = 3 * (2 * j) {-} 2 * (3 * k) := }\KeywordTok{by}
          \KeywordTok{rewrite}\NormalTok{ [←mul\_assoc 3 2 j]}
          \KeywordTok{rewrite}\NormalTok{ [←mul\_assoc 2 3 k]}
          \KeywordTok{rfl}
          \KeywordTok{done}
\NormalTok{    \_ = 3 * n {-} 2 * n := }\KeywordTok{by}
          \KeywordTok{rewrite}\NormalTok{ [←h4, ←h5]}
          \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\NormalTok{    \_ = (3 {-} 2) * n := }\ConstantTok{sorry}
\NormalTok{    \_ = n := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{n }\NormalTok{: ℤ}
\InformationTok{h1 }\NormalTok{: 2 ∣ n ∧ 3 ∣ n}
\InformationTok{h2 }\NormalTok{: ∃ (c : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  n = 2 * c}
\InformationTok{h3 }\NormalTok{: ∃ (c : ℤ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  n = 3 * c}
\InformationTok{j }\NormalTok{: ℤ}
\InformationTok{h4 }\NormalTok{: n = 2 * j}
\InformationTok{k }\NormalTok{: ℤ}
\InformationTok{h5 }\NormalTok{: n = 3 * k}
\NormalTok{⊢ 3 * n {-} 2 * n =}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  3 * n {-} 2 * n}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Of course, the \texttt{rfl} tactic will now finish off the justification
of the third equation.

The fourth equation is \texttt{3\ *\ n\ -\ 2\ *\ n\ =\ (3\ -\ 2)\ *\ n}.
It looks like the algebraic law we need to justify this is a lot like
the one that was used in the first equation, but with the multiplication
to the right of the subtraction rather than to the left. It shouldn't be
surprising, therefore, that the name of the theorem we need is
\texttt{Int.sub\_mul}. The command \texttt{\#check\ @Int.sub\_mul} gives
the response

\begin{ind}

\begin{verbatim}
Int.sub_mul : ∀ (a b c : ℤ), (a - b) * c = a * c - b * c
\end{verbatim}

\end{ind}

so \texttt{Int.sub\_mul\ 3\ 2\ n} is a proof of
\texttt{(3\ -\ 2)\ *\ n\ =\ 3\ *\ n\ -\ 2\ *\ n}. But the fourth
equation has the sides of this equation reversed, so to justify it we
need \texttt{(Int.sub\_mul\ 3\ 2\ n).symm}.

Finally, the fifth equation is \texttt{(3\ -\ 2)\ *\ n\ =\ n}. Why is
this true? Because it is definitionally equal to \texttt{1\ *\ n\ =\ n}.
Is there a theorem to justify this last equation? One way to find the
answer is to type in this example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (n : Int) : 1 * n = n := }\KeywordTok{by} \SpecialCharTok{++}\DocumentationTok{apply?}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

Lean responds with \texttt{exact\ Int.one\_mul\ n}, and
\texttt{\#check\ @Int.one\_mul} yields

\begin{ind}

\begin{verbatim}
Int.one_mul : ∀ (a : ℤ), 1 * a = a
\end{verbatim}

\end{ind}

So \texttt{Int.one\_mul\ n} should justify the last equation. Here's the
complete calculational proof, where we have shortened the second step a
bit by doing both \texttt{rewrite}s in one step. When a tactic proof is
short enough that it can be written on one line, we generally leave off
\texttt{done}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{have}\NormalTok{ h6 : 6 * (j {-} k) = n :=}
  \KeywordTok{calc}\NormalTok{ 6 * (j {-} k)}
\NormalTok{    \_ = 6 * j {-} 6 * k := Int.mul\_sub 6 j k}
\NormalTok{    \_ = 3 * (2 * j) {-} 2 * (3 * k) := }\KeywordTok{by}
          \KeywordTok{rewrite}\NormalTok{ [←mul\_assoc 3 2 j, ←mul\_assoc 2 3 k]; }\KeywordTok{rfl}
\NormalTok{    \_ = 3 * n {-} 2 * n := }\KeywordTok{by} \KeywordTok{rewrite}\NormalTok{ [←h4, ←h5]; }\KeywordTok{rfl}
\NormalTok{    \_ = (3 {-} 2) * n := (Int.sub\_mul 3 2 n).symm}
\NormalTok{    \_ = n := Int.one\_mul n}
\end{Highlighting}
\end{Shaded}

Whew! This example illustrates why algebraic reasoning in Lean can be
difficult. But one reason why this proof was challenging is that we
justified all of our steps from basic algebraic principles. Fortunately,
there are more powerful tactics that can automate some algebraic
reasoning. For example, the tactic \texttt{ring} can combine algebraic
laws involving addition, subtraction, multiplication, and exponentiation
with natural number exponents to prove many equations in one step. Also,
the tactic \texttt{rw} is a variant of \texttt{rewrite} that
automatically applies \texttt{rfl} after the rewriting if it can be used
to finish the proof. Here's a shortened version of our calculational
proof that uses these tactics.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{have}\NormalTok{ h6 : 6 * (j {-} k) = n :=}
  \KeywordTok{calc}\NormalTok{ 6 * (j {-} k)}
\NormalTok{    \_ = 3 * (2 * j) {-} 2 * (3 * k) := }\KeywordTok{by} \KeywordTok{ring}
\NormalTok{    \_ = 3 * n {-} 2 * n := }\KeywordTok{by} \KeywordTok{rw}\NormalTok{ [←h4, ←h5]}
\NormalTok{    \_ = n := }\KeywordTok{by} \KeywordTok{ring}
\end{Highlighting}
\end{Shaded}

By the way, the theorems \texttt{Int.mul\_sub}, \texttt{Int.sub\_mul},
and \texttt{Int.one\_mul} that we used earlier are the integer versions
of more general theorems \texttt{mul\_sub}, \texttt{sub\_mul}, and
\texttt{one\_mul}. The \texttt{\#check} command tells us what these
general theorems say:

\begin{ind}

\begin{verbatim}
@mul_sub : ∀ {α : Type u_1} [inst : NonUnitalNonAssocRing α]
            (a b c : α), a * (b - c) = a * b - a * c

@sub_mul : ∀ {α : Type u_1} [inst : NonUnitalNonAssocRing α]
            (a b c : α), (a - b) * c = a * c - b * c

@one_mul : ∀ {M : Type u_1} [inst : MulOneClass M]
            (a : M), 1 * a = a
\end{verbatim}

\end{ind}

The implicit arguments say that these theorems apply in any number
system with the appropriate algebraic properties. We'll use the third
theorem in our next example, which involves algebraic reasoning about
real numbers. You can use the \texttt{\#check} command to find the
meanings of the other theorems we use in this proof.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_3\_5\_4 (x : Real) (h1 : x ≤ x \^{} 2) : x ≤ 0 ∨ 1 ≤ x := }\KeywordTok{by}
  \KeywordTok{or\_right} \KeywordTok{with}\NormalTok{ h2     }\CommentTok{{-}{-}h2 : ¬x ≤ 0;  Goal : 1 ≤ x}
  \KeywordTok{have}\NormalTok{ h3 : 0 \textless{} x := lt\_of\_not\_le h2}
  \KeywordTok{have}\NormalTok{ h4 : 1 * x ≤ x * x :=}
    \KeywordTok{calc}\NormalTok{ 1 * x}
\NormalTok{      \_ = x := one\_mul x}
\NormalTok{      \_ ≤ x \^{} 2 := h1}
\NormalTok{      \_ = x * x := }\KeywordTok{by} \KeywordTok{ring}
  \KeywordTok{show}\NormalTok{ 1 ≤ x }\KeywordTok{from}\NormalTok{ le\_of\_mul\_le\_mul\_right h4 h3}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-5}{%
\subsection{Exercises}\label{exercises-5}}

\begin{numex}{1}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_3\_18a (a b c : Int)}
\NormalTok{    (h1 : a ∣ b) (h2 : a ∣ c) : a ∣ (b + c) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

2. Complete the following proof by justifying the steps in the
calculational proof. Remember that you can use the tactic
\texttt{demorgan\ :\ ...} to apply one of De Morgan's laws to just a
part of the goal. You may also find the theorem \texttt{and\_or\_left}
useful. (Use \texttt{\#check} to see what the theorem says.)

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_4\_6 (U : }\KeywordTok{Type}\NormalTok{) (A B C : Set U) :}
\NormalTok{    A \textbackslash{} (B ∩ C) = (A \textbackslash{} B) ∪ (A \textbackslash{} C) := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Set.ext}
  \KeywordTok{fix}\NormalTok{ x : U}
  \KeywordTok{show}\NormalTok{ x ∈ A \textbackslash{} (B ∩ C) ↔ x ∈ A \textbackslash{} B ∪ A \textbackslash{} C }\KeywordTok{from}
    \KeywordTok{calc}\NormalTok{ x ∈ A \textbackslash{} (B ∩ C)}
\NormalTok{      \_ ↔ x ∈ A ∧ ¬(x ∈ B ∧ x ∈ C) := }\ConstantTok{sorry}
\NormalTok{      \_ ↔ x ∈ A ∧ (¬x ∈ B ∨ ¬x ∈ C) := }\ConstantTok{sorry}  
\NormalTok{      \_ ↔ (x ∈ A ∧ ¬x ∈ B) ∨ (x ∈ A ∧ ¬x ∈ C) := }\ConstantTok{sorry}
\NormalTok{      \_ ↔ x ∈ (A \textbackslash{} B) ∪ (A \textbackslash{} C) := }\ConstantTok{sorry}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\begin{mdsk}

\end{mdsk}

For the next exercise you will need the following definitions:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ even (n : Int) : }\KeywordTok{Prop}\NormalTok{ := ∃ (k : Int), n = 2 * k}

\KeywordTok{def}\NormalTok{ odd (n : Int) : }\KeywordTok{Prop}\NormalTok{ := ∃ (k : Int), n = 2 * k + 1}
\end{Highlighting}
\end{Shaded}

These definitions tell Lean that if \texttt{n} has type \texttt{Int},
then \texttt{even\ n} means \texttt{∃\ (k\ :\ Int),\ n\ =\ 2\ *\ k} and
\texttt{odd\ n} means \texttt{∃\ (k\ :\ Int),\ n\ =\ 2\ *\ k\ +\ 1}.

\begin{numex}{3}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_4\_10 (x y : Int)}
\NormalTok{    (h1 : odd x) (h2 : odd y) : even (x {-} y) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{4}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_3\_4\_27a :}
\NormalTok{    ∀ (n : Int), 15 ∣ n ↔ 3 ∣ n ∧ 5 ∣ n := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{5}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Like\_Exercise\_3\_7\_5 (U : }\KeywordTok{Type}\NormalTok{) (F : Set (Set U))}
\NormalTok{    (h1 : 𝒫 (⋃₀ F) ⊆ ⋃₀ \{ 𝒫 A | A ∈ F \}) :}
\NormalTok{    ∃ (A : Set U), A ∈ F ∧ ∀ (B : Set U), B ∈ F → B ⊆ A := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\bookmarksetup{startatroot}

\hypertarget{conclusions}{%
\chapter{Conclusions}\label{conclusions}}

\hypertarget{ordered-pairs-and-cartesian-products}{%
\section{4.1. Ordered Pairs and Cartesian
Products}\label{ordered-pairs-and-cartesian-products}}

Section 4.1 of \emph{How To Prove It} defines the \emph{Cartesian
product} \(A \times B\) of two sets \(A\) and \(B\) to be the set of all
ordered pairs \((a, b)\), where \(a \in A\) and \(b \in B\). However, in
Lean, Cartesian product is an operation on \emph{types}, not sets. If
\texttt{A} and \texttt{B} are types, then \texttt{A\ ×\ B} is the type
of ordered pairs \texttt{(a,\ b)}, where \texttt{a} has type \texttt{A}
and \texttt{b} has type \texttt{B}. (To enter the symbol \texttt{×} in
Lean, type \texttt{\textbackslash{}times} or
\texttt{\textbackslash{}x}.) In other words, if you have
\texttt{a\ :\ A} and \texttt{b\ :\ B}, then \texttt{(a,\ b)} is an
object of type \texttt{A\ ×\ B}. There is also notation for the first
and second coordinates of an ordered pair. If \texttt{p} has type
\texttt{A\ ×\ B}, then \texttt{p.fst} is the first coordinate of
\texttt{p}, and \texttt{p.snd} is the second coordinate. You can also
use the notation \texttt{p.1} for the first coordinate of \texttt{p} and
\texttt{p.2} for the second coordinate. This means that
\texttt{p\ =\ (p.fst,\ p.snd)\ =\ (p.1,\ p.2)}.

\hypertarget{relations}{%
\section{4.2. Relations}\label{relations}}

Section 4.2 of \emph{HTPI} defines a \emph{relation from \(A\) to \(B\)}
to be a subset of \(A \times B\). In other words, if \(R\) is a relation
from \(A\) to \(B\), then \(R\) is a set whose element are ordered pairs
\((a, b)\), where \(a \in A\) and \(b \in B\). We will see in the next
section that in Lean, it is convenient to use a somewhat different
definition of relations. Nevertheless, we will take some time in this
section to study sets of ordered pairs. If \texttt{A} and \texttt{B} are
types, and \texttt{R} has type \texttt{Set\ (A\ ×\ B)}, then \texttt{R}
is a set whose elements are ordered pairs \texttt{(a,\ b)}, where
\texttt{a} has type \texttt{A} and \texttt{b} has type \texttt{B}.

Section 4.2 of \emph{HTPI} discusses several concepts concerning
relations. Here is how these concepts are defined in \emph{HTPI}
(\emph{HTPI} p.~183):

\begin{ndfn}{Definition 4.2.3}

Suppose \(R\) is a relation from \(A\) to \(B\). Then the \emph{domain}
of \(R\) is the set

\begin{quote}
\(\text{Dom}(R) = \{a \in A \mid \exists b \in B((a, b) \in R)\}\).

\end{quote}

The \emph{range} of \(R\) is the set

\begin{quote}
\(\text{Ran}(R) = \{b \in B \mid \exists a \in A((a, b) \in R)\}\).

\end{quote}

The \emph{inverse} of \(R\) is the relation \(R^{-1}\) from \(B\) to
\(A\) define as follows:

\begin{quote}
\(R^{-1} = \{(b, a) \in B \times A \mid (a, b) \in R\}\).

\end{quote}

Finally, suppose \(R\) is a relation from \(A\) to \(B\) and \(S\) is a
relation from \(B\) to \(C\). Then the \emph{composition} of \(S\) and
\(R\) is the relation \(S \circ R\) from \(A\) to \(C\) defined as
follows:

\begin{quote}
\(S \circ R = \{(a, c) \in A \times C \mid \exists b \in B((a, b) \in R \text{ and } (b, c) \in S)\}\).

\end{quote}

\end{ndfn}

There are several examples in \emph{HTPI} that illustrate these
definitions. We will focus here on seeing how to work with these
concepts in Lean.

We can write corresponding definitions in Lean as follows:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ Dom \{A B : }\KeywordTok{Type}\NormalTok{\} (R : Set (A × B)) : Set A :=}
\NormalTok{  \{ a : A | ∃ (b : B), (a, b) ∈ R \}}

\KeywordTok{def}\NormalTok{ Ran \{A B : }\KeywordTok{Type}\NormalTok{\} (R : Set (A × B)) : Set B :=}
\NormalTok{  \{ b : B | ∃ (a : A), (a, b) ∈ R \}}

\KeywordTok{def}\NormalTok{ inv \{A B : }\KeywordTok{Type}\NormalTok{\} (R : Set (A × B)) : Set (B × A) :=}
\NormalTok{  \{ (b, a) : B × A | (a, b) ∈ R \}}

\KeywordTok{def}\NormalTok{ comp \{A B C : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (S : Set (B × C)) (R : Set (A × B)) : Set (A × C) :=}
\NormalTok{  \{ (a, c) : A × C | ∃ (x : B), (a, x) ∈ R ∧ (x, c) ∈ S \}}
\end{Highlighting}
\end{Shaded}

Definitions in Lean are introduced with the keyword \texttt{def}. In the
definition of \texttt{Dom}, we have declared that \texttt{A} and
\texttt{B} are implicit arguments and \texttt{R} is an explicit
argument. That means that, in a Lean file containing these definitions,
if we have \texttt{R\ :\ Set\ (A\ ×\ B)}, then we can just write
\texttt{Dom\ R} for the domain of \texttt{R}, and Lean will figure out
for itself what \texttt{A} and \texttt{B} are. After the list of
arguments there is a colon and then the type of \texttt{Dom\ R}, which
is \texttt{Set\ A}. This is followed by \texttt{:=} and then the
definition of \texttt{Dom\ R}. The definition says that \texttt{Dom\ R}
is the set of all objects \texttt{a} of type \texttt{A} such that there
is some \texttt{b} of type \texttt{B} with \texttt{(a,\ b)\ ∈\ R}. This
is a direct translation, into Lean's type-theory language, of the first
part of Definition 4.2.3. The other three definitions are similar; they
define \texttt{Ran\ R} to be the range of \texttt{R}, \texttt{inv\ R} to
be the inverse of \texttt{R}, and \texttt{comp\ S\ R} to be the
composition of \texttt{S} and \texttt{R}.

Here is the main theorem about these concepts, as stated in \emph{HTPI}
(\emph{HTPI} p.~187):

\begin{nthm}{Theorem 4.2.5}

Suppose \(R\) is a relation from \(A\) to \(B\), \(S\) is a relation
from \(B\) to \(C\), and \(T\) is a relation from \(C\) to \(D\). Then:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \((R^{-1})^{-1} = R\).
\item
  \(\mathrm{Dom}(R^{-1}) = \mathrm{Ran}(R)\).
\item
  \(\mathrm{Ran}(R^{-1}) = \mathrm{Dom}(R)\).
\item
  \(T \circ (S \circ R) = (T \circ S) \circ R\).
\item
  \((S \circ R)^{-1} = R^{-1} \circ S^{-1}\).
\end{enumerate}

\end{nthm}

All five parts of this theorem follow directly from the definitions of
the relevant concepts. In fact, in the first three parts, Lean
recognizes the two sides of the equation as being definitionally equal,
and therefore the tactic \texttt{rfl} proves those parts:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_4\_2\_5\_1 \{A B : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (R : Set (A × B)) : inv (inv R) = R := }\KeywordTok{by} \KeywordTok{rfl}

\KeywordTok{theorem}\NormalTok{ Theorem\_4\_2\_5\_2 \{A B : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (R : Set (A × B)) : Dom (inv R) = Ran R := }\KeywordTok{by} \KeywordTok{rfl}

\KeywordTok{theorem}\NormalTok{ Theorem\_4\_2\_5\_3 \{A B : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (R : Set (A × B)) : Ran (inv R) = Dom R := }\KeywordTok{by} \KeywordTok{rfl}
\end{Highlighting}
\end{Shaded}

The fourth part will take a little more work to prove. We start the
proof like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_4\_2\_5\_4 \{A B C D : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (R : Set (A × B)) (S : Set (B × C)) (T : Set (C × D)) :}
\NormalTok{    comp T (comp S R) = comp (comp T S) R := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Set.ext}
  \KeywordTok{fix}\NormalTok{ (a, d) : A × D}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

After the \texttt{apply\ Set.ext} tactic, the goal is

\begin{quote}
\texttt{∀\ (x\ :\ A\ ×\ D),\ x\ ∈\ comp\ T\ (comp\ S\ R)\ ↔\ x\ ∈\ comp\ (comp\ T\ S)\ R}

\end{quote}

The next step should be to introduce an arbitrary object of type
\texttt{A\ ×\ D}. We could just call this object \texttt{x}, but Lean
lets us use a shortcut here. An object of type \texttt{A\ ×\ D} must
have the form of an ordered pair, where the first coordinate has type
\texttt{A} and the second has type \texttt{D}. So Lean lets us write it
as an ordered pair right away. That's what we've done in the second
step, \texttt{fix\ (a,\ d)\ :\ A\ ×\ D}. This tactic introduces two new
variables into the proof, \texttt{a\ :\ A} and \texttt{d\ :\ D}. (The
proof in \emph{HTPI} uses a similar shortcut. And we used a similar
shortcut in the definitions of \texttt{inv\ R} and \texttt{comp\ R},
where the elements of these sets were written as ordered pairs.)

Here is the complete proof.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_4\_2\_5\_4 \{A B C D : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (R : Set (A × B)) (S : Set (B × C)) (T : Set (C × D)) :}
\NormalTok{    comp T (comp S R) = comp (comp T S) R := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Set.ext}
  \KeywordTok{fix}\NormalTok{ (a, d) : A × D}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h1 : (a, d) ∈ comp T (comp S R)}
                     \CommentTok{{-}{-}Goal : (a, d) ∈ comp (comp T S) R}
    \KeywordTok{define}           \CommentTok{{-}{-}Goal : ∃ (x : B), (a, x) ∈ R ∧ (x, d) ∈ comp T S}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1     }\CommentTok{{-}{-}h1 : ∃ (x : C), (a, x) ∈ comp S R ∧ (x, d) ∈ T}
    \KeywordTok{obtain}\NormalTok{ (c : C) (h2 : (a, c) ∈ comp S R ∧ (c, d) ∈ T) }\KeywordTok{from}\NormalTok{ h1}
    \KeywordTok{have}\NormalTok{ h3 : (a, c) ∈ comp S R := h2.left}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h3     }\CommentTok{{-}{-}h3 : ∃ (x : B), (a, x) ∈ R ∧ (x, c) ∈ S}
    \KeywordTok{obtain}\NormalTok{ (b : B) (h4 : (a, b) ∈ R ∧ (b, c) ∈ S) }\KeywordTok{from}\NormalTok{ h3}
    \KeywordTok{apply}\NormalTok{ Exists.intro b    }\CommentTok{{-}{-}Goal : (a, b) ∈ R ∧ (b, d) ∈ comp T S}
    \KeywordTok{apply}\NormalTok{ And.intro h4.left }\CommentTok{{-}{-}Goal : (b, d) ∈ comp T S}
    \KeywordTok{define}                  \CommentTok{{-}{-}Goal : ∃ (x : C), (b, x) ∈ S ∧ (x, d) ∈ T}
    \KeywordTok{show}\NormalTok{ ∃ (x : C), (b, x) ∈ S ∧ (x, d) ∈ T }\KeywordTok{from}
\NormalTok{      Exists.intro c (And.intro h4.right h2.right)}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} (←)}
    \KeywordTok{assume}\NormalTok{ h1 : (a, d) ∈ comp (comp T S) R}
    \KeywordTok{define}\NormalTok{; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
    \KeywordTok{obtain}\NormalTok{ (b : B) (h2 : (a, b) ∈ R ∧ (b, d) ∈ comp T S) }\KeywordTok{from}\NormalTok{ h1}
    \KeywordTok{have}\NormalTok{ h3 : (b, d) ∈ comp T S := h2.right}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h3}
    \KeywordTok{obtain}\NormalTok{ (c : C) (h4 : (b, c) ∈ S ∧ (c, d) ∈ T) }\KeywordTok{from}\NormalTok{ h3}
    \KeywordTok{apply}\NormalTok{ Exists.intro c}
    \KeywordTok{apply}\NormalTok{ And.intro \_ h4.right}
    \KeywordTok{define}
    \KeywordTok{show}\NormalTok{ ∃ (x : B), (a, x) ∈ R ∧ (x, c) ∈ S }\KeywordTok{from}
\NormalTok{      Exists.intro b (And.intro h2.left h4.left)}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

Of course, if you have trouble reading this proof, you can enter it into
Lean and see how the tactic state changes over the course of the proof.

Here is a natural way to start the proof of part 5:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_4\_2\_5\_5 \{A B C : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (R : Set (A × B)) (S : Set (B × C)) :}
\NormalTok{    inv (comp S R) = comp (inv R) (inv S) := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Set.ext}
  \KeywordTok{fix}\NormalTok{ (c, a) : C × A}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h1 : (c, a) ∈ inv (comp S R)}
                      \CommentTok{{-}{-}Goal : (c, a) ∈ comp (inv R) (inv S)}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1      }\CommentTok{{-}{-}h1 : ∃ (x : B), (a, x) ∈ R ∧ (x, c) ∈ S}
    \KeywordTok{define}            \CommentTok{{-}{-}Goal : ∃ (x : B), (c, x) ∈ inv S ∧ (x, a) ∈ inv R}
    \KeywordTok{obtain}\NormalTok{ (b : B) (h2 : (a, b) ∈ R ∧ (b, c) ∈ S) }\KeywordTok{from}\NormalTok{ h1}
    \KeywordTok{apply}\NormalTok{ Exists.intro b         }\CommentTok{{-}{-}Goal : (c, b) ∈ inv S ∧ (b, a) ∈ inv R}
    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\NormalTok{  · }\CommentTok{{-}{-} (←)}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

After the tactics \texttt{apply\ Set.ext} and
\texttt{fix\ (c,\ a)\ :\ C\ ×\ A}, the goal is
\texttt{(c,\ a)\ ∈\ inv\ (comp\ S\ R)\ ↔\ (c,\ a)\ ∈\ comp\ (inv\ R)\ (inv\ S)}.
For the proof of the left-to-right direction, we assume
\texttt{h1\ :\ (c,\ a)\ ∈\ inv\ (comp\ S\ R)}, and we must prove
\texttt{(c,\ a)\ ∈\ comp\ (inv\ R)\ (inv\ S)}. The definition of
\texttt{h1} is an existential statement, so we apply existential
instantiation to obtain \texttt{b\ :\ B} and
\texttt{h2\ :\ (a,\ b)\ ∈\ R\ ∧\ (b,\ c)\ ∈\ S}. The definition of the
goal is also an existential statement, and after the tactic
\texttt{apply\ Exists.intro\ b}, the goal is
\texttt{(c,\ b)\ ∈\ inv\ S\ ∧\ (b,\ a)\ ∈\ inv\ R}. It looks like this
goal will follow easily from \texttt{h2}, using the definitions of the
inverses of \texttt{S} and \texttt{R}.

One way to write out these definitions would be to use the tactics
\texttt{define\ :\ (c,\ b)\ ∈\ inv\ S} and
\texttt{define\ :\ (b,\ a)\ ∈\ inv\ R}. But we're going to use this
example to illustrate another way to proceed. To use this alternative
method, we'll need to prove a preliminary theorem before proving part 5
of Theorem 4.2.5:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ inv\_def \{A B : }\KeywordTok{Type}\NormalTok{\} (R : Set (A × B)) (a : A) (b : B) :}
\NormalTok{    (b, a) ∈ inv R ↔ (a, b) ∈ R := }\KeywordTok{by} \KeywordTok{rfl}
\end{Highlighting}
\end{Shaded}

Now, any time we have a relation \texttt{R\ :\ Set\ (A\ ×\ B)} and
objects \texttt{a\ :\ A} and \texttt{b\ :\ B}, the expression
\texttt{inv\_def\ R\ a\ b} will be a proof of the statement
\texttt{(b,\ a)\ ∈\ inv\ R\ ↔\ (a,\ b)\ ∈\ R}. (Note that \texttt{A} and
\texttt{B} are implicit arguments and don't need to be specified.) And
that means that the tactic \texttt{rewrite\ {[}inv\_def\ R\ a\ b{]}}
will change \texttt{(b,\ a)\ ∈\ inv\ R} to \texttt{(a,\ b)\ ∈\ R}. In
fact, as we've seen before, you can just write
\texttt{rewrite\ {[}inv\_def{]}}, and Lean will figure out how to apply
the theorem \texttt{inv\_def} to rewrite some part of the goal.

Returning to our proof of part 5 of Theorem 4.2.5, recall that after the
step \texttt{apply\ Exists.intro\ b}, the goal is
\texttt{(c,\ b)\ ∈\ inv\ S\ ∧\ (b,\ a)\ ∈\ inv\ R}. Rather than using
the \texttt{define} tactic to write out the definitions of the inverses,
we'll use the tactic \texttt{rewrite\ {[}inv\_def,\ inv\_def{]}}. Why do
we list \texttt{inv\_def} twice in the \texttt{rewrite} tactic? When we
ask Lean to use the theorem \texttt{inv\_def} as a rewriting rule, it
figures out that \texttt{inv\_def\ S\ b\ c} is a proof of the statement
\texttt{(c,\ b)\ ∈\ inv\ S\ ↔\ (b,\ c)\ ∈\ S}, which can be used to
rewrite the left half of the goal. To rewrite the right half, we need a
different application of the \texttt{inv\_def} theorem,
\texttt{inv\_def\ R\ a\ b}. So we have to ask Lean to apply the theorem
a second time. After the \texttt{rewrite} tactic, the goal is
\texttt{(b,\ c)\ ∈\ S\ ∧\ (a,\ b)\ ∈\ R}, which will follow easily from
\texttt{h2}.

The rest of the proof of straightforward. Here is the complete proof.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_4\_2\_5\_5 \{A B C : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (R : Set (A × B)) (S : Set (B × C)) :}
\NormalTok{    inv (comp S R) = comp (inv R) (inv S) := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Set.ext}
  \KeywordTok{fix}\NormalTok{ (c, a) : C × A}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h1 : (c, a) ∈ inv (comp S R)}
                      \CommentTok{{-}{-}Goal : (c, a) ∈ comp (inv R) (inv S)}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1      }\CommentTok{{-}{-}h1 : ∃ (x : B), (a, x) ∈ R ∧ (x, c) ∈ S}
    \KeywordTok{define}            \CommentTok{{-}{-}Goal : ∃ (x : B), (c, x) ∈ inv S ∧ (x, a) ∈ inv R}
    \KeywordTok{obtain}\NormalTok{ (b : B) (h2 : (a, b) ∈ R ∧ (b, c) ∈ S) }\KeywordTok{from}\NormalTok{ h1}
    \KeywordTok{apply}\NormalTok{ Exists.intro b         }\CommentTok{{-}{-}Goal : (c, b) ∈ inv S ∧ (b, a) ∈ inv R}
    \KeywordTok{rewrite}\NormalTok{ [inv\_def, inv\_def] }\CommentTok{{-}{-}Goal : (b, c) ∈ S ∧ (a, b) ∈ R}
    \KeywordTok{show}\NormalTok{ (b, c) ∈ S ∧ (a, b) ∈ R }\KeywordTok{from}\NormalTok{ And.intro h2.right h2.left}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} (←)}
    \KeywordTok{assume}\NormalTok{ h1 : (c, a) ∈ comp (inv R) (inv S)}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
    \KeywordTok{define}
    \KeywordTok{obtain}\NormalTok{ (b : B) (h2 : (c, b) ∈ inv S ∧ (b, a) ∈ inv R) }\KeywordTok{from}\NormalTok{ h1}
    \KeywordTok{apply}\NormalTok{ Exists.intro b}
    \KeywordTok{rewrite}\NormalTok{ [inv\_def, inv\_def] }\KeywordTok{at}\NormalTok{ h2}
    \KeywordTok{show}\NormalTok{ (a, b) ∈ R ∧ (b, c) ∈ S }\KeywordTok{from}\NormalTok{ And.intro h2.right h2.left}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

By the way, an alternative way to complete both directions of this proof
would have been to apply the commutativity of ``and''. See if you can
guess the name of that theorem (you can use \texttt{\#check} to confirm
your guess) and apply it as a third rewriting rule in the
\texttt{rewrite} steps.

\hypertarget{exercises-6}{%
\subsection{Exercises}\label{exercises-6}}

\begin{numex}{1}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_4\_2\_9a \{A B C : }\KeywordTok{Type}\NormalTok{\} (R : Set (A × B))}
\NormalTok{    (S : Set (B × C)) : Dom (comp S R) ⊆ Dom R := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{2}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_4\_2\_9b \{A B C : }\KeywordTok{Type}\NormalTok{\} (R : Set (A × B))}
\NormalTok{    (S : Set (B × C)) : Ran R ⊆ Dom S → Dom (comp S R) = Dom R := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{3}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-}Fill in the blank to get a correct theorem and then prove the theorem}
\KeywordTok{theorem}\NormalTok{ Exercise\_4\_2\_9c \{A B C : }\KeywordTok{Type}\NormalTok{\} (R : Set (A × B))}
\NormalTok{    (S : Set (B × C)) : \_\_\_ → Ran (comp S R) = Ran S := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{4}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_4\_2\_12a \{A B C : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (R : Set (A × B)) (S T : Set (B × C)) :}
\NormalTok{    (comp S R) \textbackslash{} (comp T R) ⊆ comp (S \textbackslash{} T) R := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

5. Here is an incorrect theorem with an incorrect proof.

\begin{nthm}{Incorrect Theorem}
Suppose \(R\) is a relation from \(A\) to \(B\) and \(S\) and \(T\) are
relations from \(B\) to \(C\). Then
\((S \setmin T) \circ R \subseteq (S \circ R) \setmin (T \circ R)\).

\end{nthm}

\begin{npf}{Incorrect Proof (HTPI p. 190)}
Suppose \((a, c) \in (S \setmin T) \circ R\). Then we can choose some
\(b \in B\) such that \((a, b) \in R\) and \((b, c) \in S \setmin T\),
so \((b, c) \in S\) and \((b, c) \notin T\). Since \((a, b) \in R\) and
\((b, c) \in S\), \((a, c) \in S \circ R\). Similarly, since
\((a, b) \in R\) and \((b, c) \notin T\), \((a, c) \notin T \circ R\).
Therefore \((a, c) \in (S \circ R) \setmin (T \circ R)\). Since
\((a, c)\) was arbitrary, this shows that
\((S \setmin T) \circ R \subseteq (S \circ R) \setmin (T \circ R)\).
\excl{~□}\qedhere

\end{npf}

Find the mistake in the proof by attempting to write the proof in Lean:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-}You won\textquotesingle{}t be able to complete this proof}
\KeywordTok{theorem}\NormalTok{ Exercise\_4\_2\_12b \{A B C : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (R : Set (A × B)) (S T : Set (B × C)) :}
\NormalTok{    comp (S \textbackslash{} T) R ⊆ (comp S R) \textbackslash{} (comp T R) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

6. Is the following theorem correct? Try to prove it in Lean. If you
can't prove it, see if you can find a counterexample.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-}You might not be able to complete this proof}
\KeywordTok{theorem}\NormalTok{ Exercise\_4\_2\_14c \{A B C : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (R : Set (A × B)) (S T : Set (B × C)) :}
\NormalTok{    comp (S ∩ T) R = (comp S R) ∩ (comp T R) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

7. Is the following theorem correct? Try to prove it in Lean. If you
can't prove it, see if you can find a counterexample.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-}You might not be able to complete this proof}
\KeywordTok{theorem}\NormalTok{ Exercise\_4\_2\_14d \{A B C : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (R : Set (A × B)) (S T : Set (B × C)) :}
\NormalTok{    comp (S ∪ T) R = (comp S R) ∪ (comp T R) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\hypertarget{more-about-relations}{%
\section{4.3. More About Relations}\label{more-about-relations}}

Section 4.3 of \emph{HTPI} introduces new notation for working with
relations. If \(R \subseteq A \times B\), \(a \in A\), and \(b \in B\),
then \emph{HTPI} introduces the notation \(aRb\) as an alternative way
of saying \((a, b) \in R\).

The notation we will use in Lean is slightly different. Corresponding to
the notation \(aRb\) in \emph{HTPI}, in Lean we will use the notation
\texttt{R\ a\ b}. And we cannot use this notation when \texttt{R} has
type \texttt{Set\ (A\ ×\ B)}. Rather, we will need to introduce a new
type for the variable \texttt{R} in the notation \texttt{R\ a\ b}. The
name we will use for this new type is \texttt{Rel\ A\ B}. Thus, if
\texttt{R} has type \texttt{Rel\ A\ B}, \texttt{a} has type \texttt{A},
and \texttt{b} has type \texttt{B}, then \texttt{R\ a\ b} is a
proposition. This should remind you of the way predicates work in Lean.
If we have \texttt{P\ :\ Pred\ A}, then we think of \texttt{P} as
representing a property that an object of type \texttt{A} might have,
and if we also have \texttt{a\ :\ A}, then \texttt{P\ a} is the
proposition asserting that \texttt{a} has the property represented by
\texttt{P}. Similarly, if we have \texttt{R\ :\ Rel\ A\ B}, then we can
think of \texttt{R} as representing a relationship that might hold
between an object of type \texttt{A} and an object of type \texttt{B},
and if we also have \texttt{a\ :\ A} and \texttt{b\ :\ B}, then
\texttt{R\ a\ b} is the proposition asserting that the relationship
represented by \texttt{R} holds between \texttt{a} and \texttt{b}.

Notice that in \emph{HTPI}, the same variable \(R\) is used in both the
notation \(aRb\) and \((a, b) \in R\). But in Lean, the notation
\texttt{R\ a\ b} is used when \texttt{R} has type \texttt{Rel\ A\ B},
and the notation \texttt{(a,\ b)\ ∈\ R} is used when \texttt{R} has type
\texttt{Set\ (A\ ×\ B)}. The types \texttt{Rel\ A\ B} and
\texttt{Set\ (A\ ×\ B)} are different, so we cannot use the same
variable \texttt{R} in the two notations. However, there is a
correspondence between the two types. Suppose \texttt{R} has type
\texttt{Rel\ A\ B}. If we let \texttt{R\textquotesingle{}} denote the
set of all ordered pairs \texttt{(a,\ b)\ :\ A\ ×\ B} such that the
proposition \texttt{R\ a\ b} is true, then \texttt{R\textquotesingle{}}
has type \texttt{Set\ (A\ ×\ B)}. And there is then a simple
relationship between \texttt{R} and \texttt{R\textquotesingle{}}: for
any objects \texttt{a\ :\ A} and \texttt{b\ :\ B}, the propositions
\texttt{R\ a\ b} and \texttt{(a,\ b)\ ∈\ R\textquotesingle{}} are
equivalent. For our work in Lean, we will say that \texttt{R} is a
\emph{relation} from \texttt{A} to \texttt{B}, and
\texttt{R\textquotesingle{}} is the \emph{extension} of \texttt{R}.

We can define the extension of a relation, and state the correspondence
between a relation and its extension, in Lean as follows:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ extension \{A B : }\KeywordTok{Type}\NormalTok{\} (R : Rel A B) : Set (A × B) :=}
\NormalTok{  \{ (a, b) : A × B | R a b \}}

\KeywordTok{theorem}\NormalTok{ ext\_def \{A B : }\KeywordTok{Type}\NormalTok{\} (R : Rel A B) (a : A) (b : B) :}
\NormalTok{    (a, b) ∈ extension R ↔ R a b := }\KeywordTok{by} \KeywordTok{rfl}
\end{Highlighting}
\end{Shaded}

The rest of Chapter 4 of \emph{HTPI} focuses on relations from a set to
itself; in Lean, the corresponding idea is a relation from a type to
itself. If \texttt{A} is any type and \texttt{R} has type
\texttt{Rel\ A\ A}, then we will say that \texttt{R} is a \emph{binary
relation on \texttt{A}}. The notation \texttt{BinRel\ A} denotes the
type of binary relations on \texttt{A}. In other words,
\texttt{BinRel\ A} is just an abbreviation for \texttt{Rel\ A\ A}. If
\texttt{R} is a binary relation on \texttt{A}, then we say that
\texttt{R} is \emph{reflexive} if for every \texttt{x} of type
\texttt{A}, \texttt{R\ x\ x} holds. It is \emph{symmetric} if for all
\texttt{x} and \texttt{y} of type \texttt{A}, if \texttt{R\ x\ y} then
\texttt{R\ y\ x}. And it is \emph{transitive} if for all \texttt{x},
\texttt{y}, and \texttt{z} of type \texttt{A}, if \texttt{R\ x\ y} and
\texttt{R\ y\ z} then \texttt{R\ x\ z}. Of course, we can tell Lean
about these definitions, which correspond to Definition 4.3.2 in
\emph{HTPI}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ reflexive \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  ∀ (x : A), R x x}

\KeywordTok{def}\NormalTok{ symmetric \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  ∀ (x y : A), R x y → R y x}

\KeywordTok{def}\NormalTok{ transitive \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  ∀ (x y z : A), R x y → R y z → R x z}
\end{Highlighting}
\end{Shaded}

Once again, we refer you to \emph{HTPI} to see examples of these
concepts, and we focus here on proving theorems about these concepts in
Lean. The main theorem about these concepts in Section 4.3 of
\emph{HTPI} is Theorem 4.3.4. Here is what it says (\emph{HTPI} p.~196):

\begin{nthm}{Theorem 4.3.4}

Suppose \(R\) is a relation on a set \(A\).

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \(R\) is reflexive iff
  \(\{(x, y) \in A \times A \mid x = y\} \subseteq R\).
\item
  \(R\) is symmetric iff \(R = R^{-1}\).
\item
  \(R\) is transitive iff \(R \circ R \subseteq R\).
\end{enumerate}

\end{nthm}

We can prove corresponding statements in Lean, but we'll have to be
careful to distinguish between the types \texttt{BinRel\ A} and
\texttt{Set\ (A\ ×\ A)}. In \emph{HTPI}, each of the three statements in
the theorem uses the same letter \(R\) on both sides of the ``iff'', but
we can't write the statements that way in Lean. In each statement, the
part before ``iff'' uses a concept that was defined for objects of type
\texttt{BinRel\ A}, whereas the part after ``iff'' uses concepts that
only make sense for objects of type \texttt{Set\ (A\ ×\ A)}. So we'll
have to rephrase the statements by using the correspondence between a
relation of type \texttt{BinRel\ A} and its extension, which has type
\texttt{Set\ (A\ ×\ A)}. Here's the Lean theorem corresponding to
statement 2 of Theorem 4.3.4:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_4\_3\_4\_2 \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) :}
\NormalTok{    symmetric R ↔ extension R = inv (extension R) := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h1 : symmetric R}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1             }\CommentTok{{-}{-}h1 : ∀ (x y : A), R x y → R y x}
    \KeywordTok{apply}\NormalTok{ Set.ext}
    \KeywordTok{fix}\NormalTok{ (a, b) : A × A}
    \KeywordTok{show}\NormalTok{ (a, b) ∈ extension R ↔ (a, b) ∈ inv (extension R) }\KeywordTok{from}
      \KeywordTok{calc}\NormalTok{ (a, b) ∈ extension R}
\NormalTok{        \_ ↔ R a b := }\KeywordTok{by} \KeywordTok{rfl}
\NormalTok{        \_ ↔ R b a := Iff.intro (h1 a b) (h1 b a)}
\NormalTok{        \_ ↔ (a, b) ∈ inv (extension R) := }\KeywordTok{by} \KeywordTok{rfl}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} (←)}
    \KeywordTok{assume}\NormalTok{ h1 : extension R = inv (extension R)}
    \KeywordTok{define}                   \CommentTok{{-}{-}Goal : ∀ (x y : A), R x y → R y x}
    \KeywordTok{fix}\NormalTok{ a : A; }\KeywordTok{fix}\NormalTok{ b : A}
    \KeywordTok{assume}\NormalTok{ h2 : R a b        }\CommentTok{{-}{-}Goal : R b a}
    \KeywordTok{rewrite}\NormalTok{ [←ext\_def R, h1, inv\_def, ext\_def] }\KeywordTok{at}\NormalTok{ h2}
    \KeywordTok{show}\NormalTok{ R b a }\KeywordTok{from}\NormalTok{ h2}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

Note that near the end of the proof, we assume \texttt{h2\ :\ R\ a\ b},
and our goal is \texttt{R\ b\ a}. We convert \texttt{R\ a\ b} to
\texttt{R\ b\ a} by a sequence of rewrites. Applying the right-to-left
direction of the theorem \texttt{ext\_def\ R\ a\ b} converts
\texttt{R\ a\ b} to \texttt{(a,\ b)\ ∈\ extension\ R}. Then rewriting
with \texttt{h1} converts this to
\texttt{(a,\ b)\ ∈\ inv\ (extension\ R)}, using
\texttt{inv\_def\ (extension\ R)\ b\ a} converts this to
\texttt{(b,\ a)\ ∈\ extension\ R}, and finally
\texttt{ext\_def\ R\ b\ a} produces \texttt{R\ b\ a}. Usually we can
leave out the arguments when we use a theorem as a rewriting rule, and
Lean will figure them out for itself. But in this case, if you try using
\texttt{←ext\_def} as the first rewriting rule, you will see that Lean
is unable to figure out that it should use the right-to-left direction
of \texttt{ext\_def\ R\ a\ b}. Supplying the first argument turns out to
be enough of a hint for Lean to figure out the rest. That's why our
first rewriting rule is \texttt{←ext\_def\ R}.

We'll leave the proofs of the other two statements in Theorem 4.3.4 as
exercises for you.

For any types \texttt{A} and \texttt{B}, if we want to define a
particular relation \texttt{R} from \texttt{A} to \texttt{B}, we can do
it by specifying, for any \texttt{a\ :\ A} and \texttt{b\ :\ B}, what
proposition is represented by \texttt{R\ a\ b}. For example, for any
type \texttt{A}, we can define a relation \texttt{elementhood\ A} from
\texttt{A} to \texttt{Set\ A} as follows:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ elementhood (A : }\KeywordTok{Type}\NormalTok{) (a : A) (X : Set A) : }\KeywordTok{Prop}\NormalTok{ := a ∈ X}
\end{Highlighting}
\end{Shaded}

This definition says that if \texttt{A} is a type, \texttt{a} has type
\texttt{A}, and \texttt{X} has type \texttt{Set\ A}, then
\texttt{elementhood\ A\ a\ X} is the proposition \texttt{a\ ∈\ X}. Thus,
if \texttt{elementhood\ A} is followed by objects of type \texttt{A} and
\texttt{Set\ A}, the result is a proposition, so \texttt{elementhood\ A}
is functioning as a relation from \texttt{A} to \texttt{Set\ A}. For
example, \texttt{elementhood\ Int} is a relation from integers to sets
of integers, and
\texttt{elementhood\ Int\ 6\ \{\ n\ :\ Int\ \textbar{}\ ∃\ (k\ :\ Int),\ n\ =\ 2\ *\ k\ \}}
is the (true) statement that \texttt{6} is an element of the set of even
integers. (You are asked to prove it in the exercises.)

We can also use this method to define an operation that reverses the
process of forming the extension of a relation. If \texttt{R} has type
\texttt{Set\ (A\ ×\ B)}, then we define \texttt{RelFromExt\ R} to be the
relation whose extension is \texttt{R}. A few simple theorems, which
follow directly from the definition, clarify the meaning of
\texttt{RelFromExt\ R}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ RelFromExt \{A B : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (R : Set (A × B)) (a : A) (b : B) : }\KeywordTok{Prop}\NormalTok{ := (a, b) ∈ R}

\KeywordTok{theorem}\NormalTok{ RelFromExt\_def \{A B : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (R : Set (A × B)) (a : A) (b : B) :}
\NormalTok{    RelFromExt R a b ↔ (a, b) ∈ R := }\KeywordTok{by} \KeywordTok{rfl}

\KeywordTok{example}\NormalTok{ \{A B : }\KeywordTok{Type}\NormalTok{\} (R : Rel A B) :}
\NormalTok{    RelFromExt (extension R) = R := }\KeywordTok{by} \KeywordTok{rfl}

\KeywordTok{example}\NormalTok{ \{A B : }\KeywordTok{Type}\NormalTok{\} (R : Set (A × B)) :}
\NormalTok{    extension (RelFromExt R) = R := }\KeywordTok{by} \KeywordTok{rfl}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-7}{%
\subsection{Exercises}\label{exercises-7}}

\begin{numex}{1}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ :}
\NormalTok{    elementhood Int 6 \{ n : Int | ∃ (k : Int), n = 2 * k \} := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{2}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_4\_3\_4\_1 \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) :}
\NormalTok{    reflexive R ↔ \{ (x, y) : A × A | x = y \} ⊆ extension R := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{3}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_4\_3\_4\_3 \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) :}
\NormalTok{    transitive R ↔}
\NormalTok{      comp (extension R) (extension R) ⊆ extension R := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{4}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_4\_3\_12a \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (h1 : reflexive R) :}
\NormalTok{    reflexive (RelFromExt (inv (extension R))) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{5}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_4\_3\_12c \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (h1 : transitive R) :}
\NormalTok{    transitive (RelFromExt (inv (extension R))) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{6}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_4\_3\_18 \{A : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (R S : BinRel A) (h1 : transitive R) (h2 : transitive S)}
\NormalTok{    (h3 : comp (extension S) (extension R) ⊆}
\NormalTok{      comp (extension R) (extension S)) :}
\NormalTok{    transitive (RelFromExt (comp (extension R) (extension S))) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{7}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_4\_3\_20 \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (S : BinRel (Set A))}
\NormalTok{    (h : ∀ (X Y : Set A), S X Y ↔ X ≠ ∅ ∧ Y ≠ ∅ ∧}
\NormalTok{    ∀ (x y : A), x ∈ X → y ∈ Y → R x y) :}
\NormalTok{    transitive R → transitive S := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{mdsk}

\end{mdsk}

In the next three exercises, determine whether or not the theorem is
correct.

\begin{numex}{8}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-}You might not be able to complete this proof}
\KeywordTok{theorem}\NormalTok{ Exercise\_4\_3\_13b \{A : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (R1 R2 : BinRel A) (h1 : symmetric R1) (h2 : symmetric R2) :}
\NormalTok{    symmetric (RelFromExt ((extension R1) ∪ (extension R2))) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{9}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-}You might not be able to complete this proof}
\KeywordTok{theorem}\NormalTok{ Exercise\_4\_3\_13c \{A : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (R1 R2 : BinRel A) (h1 : transitive R1) (h2 : transitive R2) :}
\NormalTok{    transitive (RelFromExt ((extension R1) ∪ (extension R2))) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{10}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-}You might not be able to complete this proof}
\KeywordTok{theorem}\NormalTok{ Exercise\_4\_3\_19 \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (S : BinRel (Set A))}
\NormalTok{    (h : ∀ (X Y : Set A), S X Y ↔ ∃ (x y : A), x ∈ X ∧ y ∈ Y ∧ R x y) :}
\NormalTok{    transitive R → transitive S := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\hypertarget{ordering-relations}{%
\section{4.4. Ordering Relations}\label{ordering-relations}}

Section 4.4 of \emph{HTPI} begins by defining several new concepts about
binary relations. Here are the definitions, written in Lean:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ antisymmetric \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  ∀ (x y : A), R x y → R y x → x = y}

\KeywordTok{def}\NormalTok{ partial\_order \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  reflexive R ∧ transitive R ∧ antisymmetric R}

\KeywordTok{def}\NormalTok{ total\_order \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  partial\_order R ∧ ∀ (x y : A), R x y ∨ R y x}
\end{Highlighting}
\end{Shaded}

These definitions say that if \texttt{R} is a binary relation on
\texttt{A}, then \texttt{R} is \emph{antisymmetric} if \texttt{R\ x\ y}
and \texttt{R\ y\ x} cannot both be true unless \texttt{x\ =\ y}.
\texttt{R} is a \emph{partial order on \texttt{A}}---or just a
\emph{partial order}, if \texttt{A} is clear from context---if it is
reflexive, transitive, and antisymmetric. And \texttt{R} is a
\emph{total order on \texttt{A}} if it is a partial order and also, for
any \texttt{x} and \texttt{y} of type \texttt{A}, either
\texttt{R\ x\ y} or \texttt{R\ y\ x}. Note that, since Lean groups the
connective \texttt{∧} to the right, \texttt{partial\_order\ R} means
\texttt{reflexive\ R\ ∧\ (transitive\ R\ ∧\ antisymmetric\ R)}, and
therefore if \texttt{h} is a proof of \texttt{partial\_order\ R}, then
\texttt{h.left} is a proof of \texttt{reflexive\ R},
\texttt{h.right.left} is a proof of \texttt{transitive\ R}, and
\texttt{h.right.right} is a proof of \texttt{antisymmetric\ R}.

Example 4.4.3 in \emph{HTPI} gives several examples of partial orders
and total orders. We'll give one of those examples here. For any type
\texttt{A}, we define \texttt{sub\ A} to be the subset relation on sets
of objects of type \texttt{A}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ sub (A : }\KeywordTok{Type}\NormalTok{) (X Y : Set A) : }\KeywordTok{Prop}\NormalTok{ := X ⊆ Y}
\end{Highlighting}
\end{Shaded}

According to this definition, \texttt{sub\ A} is a binary relation on
\texttt{Set\ A}, and for any two sets \texttt{X} and \texttt{Y} of type
\texttt{Set\ A}, \texttt{sub\ A\ X\ Y} is the proposition
\texttt{X\ ⊆\ Y}. We will leave it as an exercise for you to prove that
\texttt{sub\ A} is a partial order on the type \texttt{Set\ A}.

Notice that \texttt{X\ ⊆\ Y} could be thought of as expressing a sense
in which \texttt{Y} is ``at least as large as'' \texttt{X}. Often, if
\texttt{R} is a partial order on \texttt{A} and \texttt{a} and
\texttt{b} have type \texttt{A}, then \texttt{R\ a\ b} can be thought of
as meaning that \texttt{b} is in some sense ``at least as large as''
\texttt{a}. Many of the concepts we study for partial and total orders
are motivated by this interpretation of \texttt{R}.

For example, if \texttt{R} is a partial order on \texttt{A}, \texttt{B}
has type \texttt{Set\ A}, and \texttt{b} has type \texttt{A}, then we
say that \texttt{b} is an \emph{\texttt{R}-smallest element} of
\texttt{B} if it is an element of \texttt{B}, and every element of
\texttt{B} is at least as large as \texttt{b}, according to this
interpretation of the ordering \texttt{R}. We say that \texttt{b} is an
\emph{\texttt{R}-minimal element} of \texttt{B} if it is an element of
\texttt{B}, and there is no other element of \texttt{B} that is smaller
than \texttt{b}, according to the ordering \texttt{R}. We can state
these precisely as definitions in Lean:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ smallestElt \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (b : A) (B : Set A) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  b ∈ B ∧ ∀ x ∈ B, R b x}

\KeywordTok{def}\NormalTok{ minimalElt \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (b : A) (B : Set A) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  b ∈ B ∧ ¬∃ x ∈ B, R x b ∧ x ≠ b}
\end{Highlighting}
\end{Shaded}

Notice that, as in \emph{HTPI}, in Lean we can write
\texttt{∀\ x\ ∈\ B,\ P\ x} as an abbreviation for
\texttt{∀\ (x\ :\ A),\ x\ ∈\ B\ →\ P\ x}, and \texttt{∃\ x\ ∈\ B,\ P\ x}
as an abbreviation for \texttt{∃\ (x\ :\ A),\ x\ ∈\ B\ ∧\ P\ x}.
According to these definitions, \texttt{smallestElt\ R\ b\ B} is the
proposition that \texttt{b} is an \texttt{R}-smallest element of
\texttt{B}, and \texttt{minimalElt\ R\ b\ B} means that \texttt{b} is an
\texttt{R}-minimal element of \texttt{B}.

Theorem 4.4.6 in \emph{HTPI} asserts three statements about these
concepts. We'll prove the second and third, and leave the first as an
exercise for you. The first statement in Theorem 4.4.6 says that if
\texttt{B} has an \texttt{R}-smallest element, then that
\texttt{R}-smallest element is unique. Thus, we can talk about
\emph{the} \texttt{R}-smallest element of \texttt{B} rather than
\emph{an} \texttt{R}-smallest element. The second says that if
\texttt{b} is the \texttt{R}-smallest element of \texttt{B}, then it is
also an \texttt{R}-minimal element, and it is the only
\texttt{R}-minimal element. Here is how you might start the proof:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_4\_4\_6\_2 \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (B : Set A) (b : A)}
\NormalTok{    (h1 : partial\_order R) (h2 : smallestElt R b B) :}
\NormalTok{    minimalElt R b B ∧ ∀ (c : A), minimalElt R c B → b = c := }\KeywordTok{by}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1     }\CommentTok{{-}{-}h1 : reflexive R ∧ transitive R ∧ antisymmetric R}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2     }\CommentTok{{-}{-}h2 : b ∈ B ∧ ∀ (x : A), x ∈ B → R b x}
  \KeywordTok{apply}\NormalTok{ And.intro}
\NormalTok{  · }\CommentTok{{-}{-} Proof that b is minimal}
    \KeywordTok{define}           \CommentTok{{-}{-}Goal : b ∈ B ∧ ¬∃ (x : A), x ∈ B ∧ R x b ∧ x ≠ b}
    \KeywordTok{apply}\NormalTok{ And.intro h2.left}
    \KeywordTok{quant\_neg}        \CommentTok{{-}{-}Goal : ∀ (x : A), ¬(x ∈ B ∧ R x b ∧ x ≠ b)}
    \SpecialCharTok{**}\WarningTok{demorgan}\ErrorTok{ : ¬(x ∈ B ∧ R x b ∧ x ≠ b)}\SpecialCharTok{::}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Proof that b is only minimal element}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

When the goal is
\texttt{∀\ (x\ :\ A),\ ¬(x\ ∈\ B\ ∧\ R\ x\ b\ ∧\ x\ ≠\ b)}, it is
tempting to apply the \texttt{demorgan} tactic to
\texttt{¬(x\ ∈\ B\ ∧\ R\ x\ b\ ∧\ x\ ≠\ b)}, but unfortunately this
generates an error in Lean:
\texttt{unknown\ identifier\ \textquotesingle{}x\textquotesingle{}}. The
problem is that \texttt{x} is not defined in the tactic state, so
without the quantifier \texttt{∀\ (x\ :\ A)} in front of it,
\texttt{¬(x\ ∈\ B\ ∧\ R\ x\ b\ ∧\ x\ ≠\ b)} doesn't mean anything to
Lean. The solution to the problem is to deal with the universal
quantifier first by introducing an arbitrary \texttt{x} of type
\texttt{A}. Once \texttt{x} has been introduced, we can apply the
\texttt{demorgan} tactic.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_4\_4\_6\_2 \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (B : Set A) (b : A)}
\NormalTok{    (h1 : partial\_order R) (h2 : smallestElt R b B) :}
\NormalTok{    minimalElt R b B ∧ ∀ (c : A), minimalElt R c B → b = c := }\KeywordTok{by}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1     }\CommentTok{{-}{-}h1 : reflexive R ∧ transitive R ∧ antisymmetric R}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2     }\CommentTok{{-}{-}h2 : b ∈ B ∧ ∀ (x : A), x ∈ B → R b x}
  \KeywordTok{apply}\NormalTok{ And.intro}
\NormalTok{  · }\CommentTok{{-}{-} Proof that b is minimal}
    \KeywordTok{define}           \CommentTok{{-}{-}Goal : b ∈ B ∧ ¬∃ (x : A), x ∈ B ∧ R x b ∧ x ≠ b}
    \KeywordTok{apply}\NormalTok{ And.intro h2.left}
    \KeywordTok{quant\_neg}        \CommentTok{{-}{-}Goal : ∀ (x : A), ¬(x ∈ B ∧ R x b ∧ x ≠ b)}
    \KeywordTok{fix}\NormalTok{ x : A}
    \KeywordTok{demorgan}         \CommentTok{{-}{-}Goal : ¬x ∈ B ∨ ¬(R x b ∧ x ≠ b)}
    \KeywordTok{or\_right} \KeywordTok{with}\NormalTok{ h3 }\CommentTok{{-}{-}h3 : x ∈ B; Goal : ¬(R x b ∧ x ≠ b)}
    \KeywordTok{demorgan}         \CommentTok{{-}{-}Goal : ¬R x b ∨ x = b}
    \KeywordTok{or\_right} \KeywordTok{with}\NormalTok{ h4 }\CommentTok{{-}{-}h4 : R x b; Goal : x = b}
    \KeywordTok{have}\NormalTok{ h5 : R b x := h2.right x h3}
    \KeywordTok{have}\NormalTok{ h6 : antisymmetric R := h1.right.right}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h6     }\CommentTok{{-}{-}h6 : ∀ (x y : A), R x y → R y x → x = y}
    \KeywordTok{show}\NormalTok{ x = b }\KeywordTok{from}\NormalTok{ h6 x b h4 h5}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Proof that b is only minimal element}
    \KeywordTok{fix}\NormalTok{ c : A}
    \KeywordTok{assume}\NormalTok{ h3 : minimalElt R c B}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h3    }\CommentTok{{-}{-}h3 : c ∈ B ∧ ¬∃ (x : A), x ∈ B ∧ R x c ∧ x ≠ c}
    \KeywordTok{contradict}\NormalTok{ h3.right }\KeywordTok{with}\NormalTok{ h4}
                  \CommentTok{{-}{-}h4 : ¬b = c; Goal : ∃ (x : A), x ∈ B ∧ R x c ∧ x ≠ c}
    \KeywordTok{have}\NormalTok{ h5 : R b c := h2.right c h3.left}
    \KeywordTok{show}\NormalTok{ ∃ (x : A), x ∈ B ∧ R x c ∧ x ≠ c }\KeywordTok{from}
\NormalTok{      Exists.intro b (And.intro h2.left (And.intro h5 h4))}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

Finally, the third statement in Theorem 4.4.6 says that if \texttt{R} is
a total order, then any \texttt{R}-minimal element of a set \texttt{B}
must be the \texttt{R}-smallest element of \texttt{B}. The beginning of
the proof is straightforward:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_4\_4\_6\_3 \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (B : Set A) (b : A)}
\NormalTok{    (h1 : total\_order R) (h2 : minimalElt R b B) : smallestElt R b B := }\KeywordTok{by}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1         }\CommentTok{{-}{-}h1 : partial\_order R ∧ ∀ (x y : A), R x y ∨ R y x}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2         }\CommentTok{{-}{-}h2 : b ∈ B ∧ ¬∃ (x : A), x ∈ B ∧ R x b ∧ x ≠ b}
  \KeywordTok{define}               \CommentTok{{-}{-}Goal : b ∈ B ∧ ∀ (x : A), x ∈ B → R b x}
  \KeywordTok{apply}\NormalTok{ And.intro h2.left  }\CommentTok{{-}{-}Goal : ∀ (x : A), x ∈ B → R b x}
  \KeywordTok{fix}\NormalTok{ x : A}
  \KeywordTok{assume}\NormalTok{ h3 : x ∈ B        }\CommentTok{{-}{-}Goal : R b x}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

Surprisingly, at this point it is difficult to find a way to reach the
goal \texttt{R\ b\ x}. See \emph{HTPI} for an explanation of why it
turns out to be helpful to split the proof into two cases, depending on
whether or not \texttt{x\ =\ b}. Of course, we use the
\texttt{by\_cases} tactic for this.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_4\_4\_6\_3 \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (B : Set A) (b : A)}
\NormalTok{    (h1 : total\_order R) (h2 : minimalElt R b B) : smallestElt R b B := }\KeywordTok{by}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1         }\CommentTok{{-}{-}h1 : partial\_order R ∧ ∀ (x y : A), R x y ∨ R y x}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2         }\CommentTok{{-}{-}h2 : b ∈ B ∧ ¬∃ (x : A), x ∈ B ∧ R x b ∧ x ≠ b}
  \KeywordTok{define}               \CommentTok{{-}{-}Goal : b ∈ B ∧ ∀ (x : A), x ∈ B → R b x}
  \KeywordTok{apply}\NormalTok{ And.intro h2.left  }\CommentTok{{-}{-}Goal : ∀ (x : A), x ∈ B → R b x}
  \KeywordTok{fix}\NormalTok{ x : A}
  \KeywordTok{assume}\NormalTok{ h3 : x ∈ B        }\CommentTok{{-}{-}Goal : R b x}
  \KeywordTok{by\_cases}\NormalTok{ h4 : x = b}
\NormalTok{  · }\CommentTok{{-}{-} Case 1. h4 : x = b}
    \KeywordTok{rewrite}\NormalTok{ [h4]             }\CommentTok{{-}{-}Goal : R b b}
    \KeywordTok{have}\NormalTok{ h5 : partial\_order R := h1.left}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h5}
    \KeywordTok{have}\NormalTok{ h6 : reflexive R := h5.left}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h6}
    \KeywordTok{show}\NormalTok{ R b b }\KeywordTok{from}\NormalTok{ h6 b}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Case 2. h4 : x ≠ b}
    \KeywordTok{have}\NormalTok{ h5 : ∀ (x y : A), R x y ∨ R y x := h1.right}
    \KeywordTok{have}\NormalTok{ h6 : R x b ∨ R b x := h5 x b}
    \KeywordTok{have}\NormalTok{ h7 : ¬R x b := }\KeywordTok{by}
      \KeywordTok{contradict}\NormalTok{ h2.right }\KeywordTok{with}\NormalTok{ h8}
      \KeywordTok{show}\NormalTok{ ∃ (x : A), x ∈ B ∧ R x b ∧ x ≠ b }\KeywordTok{from}
\NormalTok{        Exists.intro x (And.intro h3 (And.intro h8 h4))}
      \KeywordTok{done}
    \KeywordTok{disj\_syll}\NormalTok{ h6 h7}
    \KeywordTok{show}\NormalTok{ R b x }\KeywordTok{from}\NormalTok{ h6}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

Imitating the definitions above, you should be able to formulate
definitions of \texttt{R}-largest and \texttt{R}-maximal elements.
Section 4.4 of \emph{HTPI} defines four more terms: upper bound, lower
bound, least upper bound, and greatest lower bound. We will discuss
upper bounds and least upper bounds, and leave lower bounds and greatest
lower bounds for you to figure out on your own.

If \texttt{R} is a partial order on \texttt{A}, \texttt{B} has type
\texttt{Set\ A}, and \texttt{a} has type \texttt{A}, then \texttt{a} is
called an \emph{upper bound} for \texttt{B} if it is at least as large
as every element of \texttt{B}. If it is the smallest element of the set
of upper bounds, then it is called the \emph{least upper bound} of
\texttt{B}. The phrase ``least upper bound'' is often abbreviated
``lub''. Here are these definitions, written in Lean:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ upperBd \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (a : A) (B : Set A) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  ∀ x ∈ B, R x a}

\KeywordTok{def}\NormalTok{ lub \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (a : A) (B : Set A) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  smallestElt R a \{ c : A | upperBd R c B \}}
\end{Highlighting}
\end{Shaded}

As usual, we will let you consult \emph{HTPI} for examples of these
concepts. But we will mention one example: If \texttt{A} is a type and
\texttt{F} has type \texttt{Set\ (Set\ A)}---that is, \texttt{F} is a
set whose elements are sets of objects of type \texttt{A}---then the
least upper bound of \texttt{F}, with respect to the partial order
\texttt{sub\ A}, is \texttt{⋃₀\ F}. We leave the proof of this fact as
an exercise.

\hypertarget{exercises-8}{%
\subsection{Exercises}\label{exercises-8}}

\begin{numex}{1}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_4\_4\_3\_1 \{A : }\KeywordTok{Type}\NormalTok{\} : partial\_order (sub A) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{2}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_4\_4\_6\_1 \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (B : Set A) (b : A)}
\NormalTok{    (h1 : partial\_order R) (h2 : smallestElt R b B) :}
\NormalTok{    ∀ (c : A), smallestElt R c B → b = c := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{3}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-}If F is a set of sets, then ⋃₀ F is the lub of F in the subset ordering}
\KeywordTok{theorem}\NormalTok{ Theorem\_4\_4\_11 \{A : }\KeywordTok{Type}\NormalTok{\} (F : Set (Set A)) :}
\NormalTok{    lub (sub A) (⋃₀ F) F := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{4}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_4\_4\_8 \{A B : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (S : BinRel B)}
\NormalTok{    (T : BinRel (A × B)) (h1 : partial\_order R) (h2 : partial\_order S)}
\NormalTok{    (h3 : ∀ (a a\textquotesingle{} : A) (b b\textquotesingle{} : B),}
\NormalTok{      T (a, b) (a\textquotesingle{}, b\textquotesingle{}) ↔ R a a\textquotesingle{} ∧ S b b\textquotesingle{}) :}
\NormalTok{    partial\_order T := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{5}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_4\_4\_9\_part \{A B : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (S : BinRel B)}
\NormalTok{    (L : BinRel (A × B)) (h1 : total\_order R) (h2 : total\_order S)}
\NormalTok{    (h3 : ∀ (a a\textquotesingle{} : A) (b b\textquotesingle{} : B),}
\NormalTok{      L (a, b) (a\textquotesingle{}, b\textquotesingle{}) ↔ R a a\textquotesingle{} ∧ (a = a\textquotesingle{} → S b b\textquotesingle{})) :}
\NormalTok{    ∀ (a a\textquotesingle{} : A) (b b\textquotesingle{} : B),}
\NormalTok{      L (a, b) (a\textquotesingle{}, b\textquotesingle{}) ∨ L (a\textquotesingle{}, b\textquotesingle{}) (a, b) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{6}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_4\_4\_15a \{A : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (R1 R2 : BinRel A) (B : Set A) (b : A)}
\NormalTok{    (h1 : partial\_order R1) (h2 : partial\_order R2)}
\NormalTok{    (h3 : extension R1 ⊆ extension R2) :}
\NormalTok{    smallestElt R1 b B → smallestElt R2 b B := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{7}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_4\_4\_15b \{A : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (R1 R2 : BinRel A) (B : Set A) (b : A)}
\NormalTok{    (h1 : partial\_order R1) (h2 : partial\_order R2)}
\NormalTok{    (h3 : extension R1 ⊆ extension R2) :}
\NormalTok{    minimalElt R2 b B → minimalElt R1 b B := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{8}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_4\_4\_18a \{A : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (R : BinRel A) (B1 B2 : Set A) (h1 : partial\_order R)}
\NormalTok{    (h2 : ∀ x ∈ B1, ∃ y ∈ B2, R x y) (h3 : ∀ x ∈ B2, ∃ y ∈ B1, R x y) :}
\NormalTok{    ∀ (x : A), upperBd R x B1 ↔ upperBd R x B2 := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{9}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_4\_4\_22 \{A : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (R : BinRel A) (B1 B2 : Set A) (x1 x2 : A)}
\NormalTok{    (h1 : partial\_order R) (h2 : lub R x1 B1) (h3 : lub R x2 B2) :}
\NormalTok{    B1 ⊆ B2 → R x1 x2 := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{10}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_4\_4\_24 \{A : }\KeywordTok{Type}\NormalTok{\} (R : Set (A × A)) :}
\NormalTok{    smallestElt (sub (A × A)) (R ∪ (inv R))}
\NormalTok{    \{ T : Set (A × A) | R ⊆ T ∧ symmetric (RelFromExt T) \} := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\hypertarget{equivalence-relations}{%
\section{4.5. Equivalence Relations}\label{equivalence-relations}}

Chapter 4 of \emph{HTPI} concludes with the study of one more important
combination of properties that a relation might have. A binary relation
\(R\) on a set \(A\) is called an \emph{equivalence relation} if it is
reflexive, symmetric, and transitive. If \(x \in A\), then the
\emph{equivalence class} of \(x\) with respect to \(R\) is the set of
all \(y \in A\) such that \(yRx\). In \emph{HTPI}, this equivalence
class is denoted \([x]_R\), so we have \[
[x]_R = \{y \in A \mid yRx\}.
\] The set whose elements are all of these equivalence classes is called
\(A\) \emph{mod} \(R\). It is written \(A/R\), so \[
A/R = \{[x]_R \mid x \in A\}.
\] Note that \(A/R\) is a set whose elements are sets: for each
\(x \in A\), \([x]_R\) is a subset of \(A\), and \([x]_R \in A/R\).

To define these concepts in Lean, we write:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ equiv\_rel \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  reflexive R ∧ symmetric R ∧ transitive R}

\KeywordTok{def}\NormalTok{ equivClass \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (x : A) : Set A :=}
\NormalTok{  \{ y : A | R y x \}}

\KeywordTok{def}\NormalTok{ mod (A : }\KeywordTok{Type}\NormalTok{) (R : BinRel A) : Set (Set A) :=}
\NormalTok{  \{ equivClass R x | x : A \}}
\end{Highlighting}
\end{Shaded}

Thus, \texttt{equiv\_rel\ R} is the proposition that \texttt{R} is an
equivalence relation, \texttt{equivClass\ R\ x} is the equivalence class
of \texttt{x} with respect to \texttt{R}, and \texttt{mod\ A\ R} is
\texttt{A} mod \texttt{R}. Note that \texttt{equivClass\ R\ x} has type
\texttt{Set\ A}, while \texttt{mod\ A\ R} has type
\texttt{Set\ (Set\ A)}. The definition of \texttt{mod\ A\ R} is
shorthand for
\texttt{\{\ X\ :\ Set\ A\ \textbar{}\ ∃\ (x\ :\ A),\ equivClass\ R\ x\ =\ X\ \}}.

\emph{HTPI} gives several examples of equivalence relations, and these
examples illustrate that equivalence classes always have certain
properties. The most important of these are that each equivalence class
is a nonempty set, the equivalence classes do not overlap, and their
union is all of \texttt{A}. We say that the equivalence classes form a
\emph{partition} of \texttt{A}. To state and prove these properties in
Lean we will need some definitions. We start with these:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ empty \{A : }\KeywordTok{Type}\NormalTok{\} (X : Set A) : }\KeywordTok{Prop}\NormalTok{ := ¬∃ (x : A), x ∈ X }

\KeywordTok{def}\NormalTok{ pairwise\_disjoint \{A : }\KeywordTok{Type}\NormalTok{\} (F : Set (Set A)) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  ∀ X ∈ F, ∀ Y ∈ F, X ≠ Y → empty (X ∩ Y)}
\end{Highlighting}
\end{Shaded}

To say that a set \texttt{X} is empty, we could write \texttt{X\ =\ ∅},
but it is more convenient to have a statement that says more explicitly
what it means for a set to be empty. Thus, we have defined
\texttt{empty\ X} to be the proposition saying that \texttt{X} has no
elements. If \texttt{F} has type \texttt{Set\ (Set\ A)}, then
\texttt{pairwise\_disjoint\ F} is the proposition that no two distinct
elements of \texttt{F} have any element in common---in other words, the
elements of \texttt{F} do not overlap. We can now give the precise
definition of a partition:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ partition \{A : }\KeywordTok{Type}\NormalTok{\} (F : Set (Set A)) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  (∀ (x : A), x ∈ ⋃₀ F) ∧ pairwise\_disjoint F ∧ ∀ X ∈ F, ¬empty X}
\end{Highlighting}
\end{Shaded}

The main theorem about equivalence relations in \emph{HTPI} is Theorem
4.5.4, which says that \texttt{mod\ A\ R} is a partition of \texttt{A}.
The proof of this theorem is hard enough that \emph{HTPI} proves two
facts about equivalence classes first. A fact that is proven just for
the purpose of using it to prove something else is often called a
\emph{lemma}. We can use this term in Lean as well. Here is the first
part of Lemma 4.5.5 from \emph{HTPI}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ Lemma\_4\_5\_5\_1 \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (h : equiv\_rel R) :}
\NormalTok{    ∀ (x : A), x ∈ equivClass R x := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ x : A}
  \KeywordTok{define}           \CommentTok{{-}{-}Goal : R x x}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h      }\CommentTok{{-}{-}h : reflexive R ∧ symmetric R ∧ transitive R}
  \KeywordTok{have}\NormalTok{ Rref : reflexive R := h.left}
  \KeywordTok{show}\NormalTok{ R x x }\KeywordTok{from}\NormalTok{ Rref x}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

The command \texttt{\#check\ @Lemma\_4\_5\_5\_1} produces the result

\begin{ind}

\begin{verbatim}
@Lemma_4_5_5_1 : ∀ {A : Type} (R : BinRel A),
                  equiv_rel R → ∀ (x : A), x ∈ equivClass R x
\end{verbatim}

\end{ind}

Thus, if we have \texttt{R\ :\ BinRel\ A}, \texttt{h\ :\ equiv\_rel\ R},
and \texttt{x\ :\ A}, then \texttt{Lemma\_4\_5\_5\_1\ R\ h\ x} is a
proof of \texttt{x\ ∈\ equivClass\ R\ x}. We will use this at the end of
the proof of our next lemma:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ Lemma\_4\_5\_5\_2 \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (h : equiv\_rel R) :}
\NormalTok{    ∀ (x y : A), y ∈ equivClass R x ↔}
\NormalTok{      equivClass R y = equivClass R x := }\KeywordTok{by}
  \KeywordTok{have}\NormalTok{ Rsymm : symmetric R := h.right.left}
  \KeywordTok{have}\NormalTok{ Rtrans : transitive R := h.right.right}
  \KeywordTok{fix}\NormalTok{ x : A; }\KeywordTok{fix}\NormalTok{ y : A}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h2 :}
\NormalTok{      y ∈ equivClass R x    }\CommentTok{{-}{-}Goal : equivClass R y = equivClass R x}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2                        }\CommentTok{{-}{-}h2 : R y x}
    \KeywordTok{apply}\NormalTok{ Set.ext}
    \KeywordTok{fix}\NormalTok{ z : A}
    \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{    · }\CommentTok{{-}{-} Proof that z ∈ equivClass R y → z ∈ equivClass R x}
      \KeywordTok{assume}\NormalTok{ h3 : z ∈ equivClass R y}
      \KeywordTok{define}                            \CommentTok{{-}{-}Goal : R z x}
      \KeywordTok{define} \KeywordTok{at}\NormalTok{ h3                      }\CommentTok{{-}{-}h3 : R z y}
      \KeywordTok{show}\NormalTok{ R z x }\KeywordTok{from}\NormalTok{ Rtrans z y x h3 h2}
      \KeywordTok{done}
\NormalTok{    · }\CommentTok{{-}{-} Proof that z ∈ equivClass R x → z ∈ equivClass R y}
      \KeywordTok{assume}\NormalTok{ h3 : z ∈ equivClass R x}
      \KeywordTok{define}                            \CommentTok{{-}{-}Goal : R z y}
      \KeywordTok{define} \KeywordTok{at}\NormalTok{ h3                      }\CommentTok{{-}{-}h3 : R z x}
      \KeywordTok{have}\NormalTok{ h4 : R x y := Rsymm y x h2}
      \KeywordTok{show}\NormalTok{ R z y }\KeywordTok{from}\NormalTok{ Rtrans z x y h3 h4}
      \KeywordTok{done}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} (←)}
    \KeywordTok{assume}\NormalTok{ h2 :}
\NormalTok{      equivClass R y = equivClass R x   }\CommentTok{{-}{-}Goal : y ∈ equivClass R x}
    \KeywordTok{rewrite}\NormalTok{ [←h2]                       }\CommentTok{{-}{-}Goal : y ∈ equivClass R y}
    \KeywordTok{show}\NormalTok{ y ∈ equivClass R y }\KeywordTok{from}\NormalTok{ Lemma\_4\_5\_5\_1 R h y}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

The definition of ``partition'' has three parts, so to prove Theorem
4.5.4 we will have to prove three statements. It will make the proof
easier to read if we prove the three statements separately.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ Theorem\_4\_5\_4\_part\_1 \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (h : equiv\_rel R) :}
\NormalTok{    ∀ (x : A), x ∈ ⋃₀ (mod A R) := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ x : A}
  \KeywordTok{define}        \CommentTok{{-}{-}Goal : ∃ (t : Set A), t ∈ mod A R ∧ x ∈ t}
  \KeywordTok{apply}\NormalTok{ Exists.intro (equivClass R x)}
  \KeywordTok{apply}\NormalTok{ And.intro \_ (Lemma\_4\_5\_5\_1 R h x)}
                \CommentTok{{-}{-}Goal : equivClass R x ∈ mod A R}
  \KeywordTok{define}        \CommentTok{{-}{-}Goal : ∃ (x\_1 : A), equivClass R x\_1 = equivClass R x}
  \KeywordTok{apply}\NormalTok{ Exists.intro x}
  \KeywordTok{rfl}
  \KeywordTok{done}

\KeywordTok{lemma}\NormalTok{ Theorem\_4\_5\_4\_part\_2 \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (h : equiv\_rel R) :}
\NormalTok{    pairwise\_disjoint (mod A R) := }\KeywordTok{by}
  \KeywordTok{define}
  \KeywordTok{fix}\NormalTok{ X : Set A}
  \KeywordTok{assume}\NormalTok{ h2 : X ∈ mod A R}
  \KeywordTok{fix}\NormalTok{ Y : Set A}
  \KeywordTok{assume}\NormalTok{ h3 : Y ∈ mod A R           }\CommentTok{{-}{-}Goal : X ≠ Y → empty (X ∩ Y)}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2; }\KeywordTok{define} \KeywordTok{at}\NormalTok{ h3}
  \KeywordTok{obtain}\NormalTok{ (x : A) (h4 : equivClass R x = X) }\KeywordTok{from}\NormalTok{ h2}
  \KeywordTok{obtain}\NormalTok{ (y : A) (h5 : equivClass R y = Y) }\KeywordTok{from}\NormalTok{ h3}
  \KeywordTok{contrapos}
  \KeywordTok{assume}\NormalTok{ h6 : ∃ (x : A), x ∈ X ∩ Y  }\CommentTok{{-}{-}Goal : X = Y}
  \KeywordTok{obtain}\NormalTok{ (z : A) (h7 : z ∈ X ∩ Y) }\KeywordTok{from}\NormalTok{ h6}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h7}
  \KeywordTok{rewrite}\NormalTok{ [←h4, ←h5] }\KeywordTok{at}\NormalTok{ h7 }\CommentTok{{-}{-}h7 : z ∈ equivClass R x ∧ z ∈ equivClass R y}
  \KeywordTok{have}\NormalTok{ h8 : equivClass R z = equivClass R x :=}
\NormalTok{    (Lemma\_4\_5\_5\_2 R h x z).ltr h7.left}
  \KeywordTok{have}\NormalTok{ h9 : equivClass R z = equivClass R y :=}
\NormalTok{    (Lemma\_4\_5\_5\_2 R h y z).ltr h7.right}
  \KeywordTok{show}\NormalTok{ X = Y }\KeywordTok{from}
    \KeywordTok{calc}\NormalTok{ X}
\NormalTok{      \_ = equivClass R x := h4.symm}
\NormalTok{      \_ = equivClass R z := h8.symm}
\NormalTok{      \_ = equivClass R y := h9}
\NormalTok{      \_ = Y              := h5}
  \KeywordTok{done}

\KeywordTok{lemma}\NormalTok{ Theorem\_4\_5\_4\_part\_3 \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (h : equiv\_rel R) :}
\NormalTok{    ∀ X ∈ mod A R, ¬empty X := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ X : Set A}
  \KeywordTok{assume}\NormalTok{ h2 : X ∈ mod A R  }\CommentTok{{-}{-}Goal : ¬empty X}
  \KeywordTok{define}\NormalTok{; }\KeywordTok{double\_neg}       \CommentTok{{-}{-}Goal : ∃ (x : A), x ∈ X}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2             }\CommentTok{{-}{-}h2 : ∃ (x : A), equivClass R x = X}
  \KeywordTok{obtain}\NormalTok{ (x : A) (h3 : equivClass R x = X) }\KeywordTok{from}\NormalTok{ h2}
  \KeywordTok{rewrite}\NormalTok{ [←h3]}
  \KeywordTok{show}\NormalTok{ ∃ (x\_1 : A), x\_1 ∈ equivClass R x }\KeywordTok{from}
\NormalTok{    Exists.intro x (Lemma\_4\_5\_5\_1 R h x)}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

It's easy now to put everything together to prove Theorem 4.5.4.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_4\_5\_4 \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (h : equiv\_rel R) :}
\NormalTok{    partition (mod A R) := And.intro (Theorem\_4\_5\_4\_part\_1 R h)}
\NormalTok{      (And.intro (Theorem\_4\_5\_4\_part\_2 R h) (Theorem\_4\_5\_4\_part\_3 R h))}
\end{Highlighting}
\end{Shaded}

Theorem 4.5.4 shows that an equivalence relation on \texttt{A}
determines a partition of \texttt{A}, namely \texttt{mod\ A\ R}. Our
next project will be to prove Theorem 4.5.6 in \emph{HTPI}, which says
that every partition of \texttt{A} arises in this way; that is, every
partition is \texttt{mod\ A\ R} for some equivalence relation
\texttt{R}. To prove this, we must show how to use a partition
\texttt{F} to define an equivalence relation \texttt{R} for which
\texttt{mod\ A\ R\ =\ F}. The proof in \emph{HTPI} defines the required
equivalence relation \texttt{R} as a set of ordered pairs, but in Lean
we will need to define it instead as a binary relation on \texttt{A}.
Translating \emph{HTPI}'s set-theoretic definition into Lean's notation
for binary relations leads to the following definition:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ EqRelFromPart \{A : }\KeywordTok{Type}\NormalTok{\} (F : Set (Set A)) (x y : A) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  ∃ X ∈ F, x ∈ X ∧ y ∈ X}
\end{Highlighting}
\end{Shaded}

In other words, \texttt{EqRelFromPart\ F} is the binary relation on
\texttt{A} that is true of any two objects \texttt{x} and \texttt{y} of
type \texttt{A} if and only if \texttt{x} and \texttt{y} belong to the
same set in \texttt{F}. Our plan now is to show that if \texttt{F} is a
partition of \texttt{A}, then \texttt{EqRelFromPart\ F} is an
equivalence relation on \texttt{A}, and
\texttt{mod\ A\ (EqRelFromPart\ F)\ =\ F}.

Once again, \emph{HTPI} breaks the proof up by proving some lemmas
first, and we will find it convenient to break the proof into even
smaller pieces. We will leave the proofs of most of these lemmas as
exercises for you.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ overlap\_implies\_equal \{A : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (F : Set (Set A)) (h : partition F) :}
\NormalTok{    ∀ X ∈ F, ∀ Y ∈ F, ∀ (x : A), x ∈ X → x ∈ Y → X = Y := }\ConstantTok{sorry}

\KeywordTok{lemma}\NormalTok{ Lemma\_4\_5\_7\_ref \{A : }\KeywordTok{Type}\NormalTok{\} (F : Set (Set A)) (h : partition F):}
\NormalTok{    reflexive (EqRelFromPart F) := }\ConstantTok{sorry}
  
\KeywordTok{lemma}\NormalTok{ Lemma\_4\_5\_7\_symm \{A : }\KeywordTok{Type}\NormalTok{\} (F : Set (Set A)) (h : partition F):}
\NormalTok{    symmetric (EqRelFromPart F) := }\ConstantTok{sorry}

\KeywordTok{lemma}\NormalTok{ Lemma\_4\_5\_7\_trans \{A : }\KeywordTok{Type}\NormalTok{\} (F : Set (Set A)) (h : partition F):}
\NormalTok{    transitive (EqRelFromPart F) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

We can now put these pieces together to prove Lemma 4.5.7 in
\emph{HTPI}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ Lemma\_4\_5\_7 \{A : }\KeywordTok{Type}\NormalTok{\} (F : Set (Set A)) (h : partition F) :}
\NormalTok{    equiv\_rel (EqRelFromPart F) := And.intro (Lemma\_4\_5\_7\_ref F h)}
\NormalTok{      (And.intro (Lemma\_4\_5\_7\_symm F h) (Lemma\_4\_5\_7\_trans F h))}
\end{Highlighting}
\end{Shaded}

We need one more lemma before we can prove Theorem 4.5.6:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ Lemma\_4\_5\_8 \{A : }\KeywordTok{Type}\NormalTok{\} (F : Set (Set A)) (h : partition F) :}
\NormalTok{    ∀ X ∈ F, ∀ x ∈ X, equivClass (EqRelFromPart F) x = X := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

We are finally now ready to address Theorem 4.5.6. Here is the statement
of the theorem:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_4\_5\_6 \{A : }\KeywordTok{Type}\NormalTok{\} (F : Set (Set A)) (h: partition F) :}
\NormalTok{    ∃ (R : BinRel A), equiv\_rel R ∧ mod A R = F}
\end{Highlighting}
\end{Shaded}

Of course, the relation \texttt{R} that we will use to prove the theorem
is \texttt{EqRelFromPart\ F}, so we could start the proof with the
tactic \texttt{apply\ Exists.intro\ (EqRelFromPart\ F)}. But this means
that the rest of the proof will involve many statements about the
relation \texttt{EqRelFromPart\ F}. When a complicated object appears
multiple times in a proof, it can make the proof a little easier to read
if we give that object a name. We can do that by using a new tactic. The
tactic \texttt{set\ R\ :\ BinRel\ A\ :=\ EqRelFromPart\ F} introduces
the new variable \texttt{R} into the tactic state. The variable
\texttt{R} has type \texttt{BinRel\ A}, and it is definitionally equal
to \texttt{EqRelFromPart\ F}. That means that, when necessary, Lean will
fill in this definition of \texttt{R}. For example, one of our first
steps will be to apply \texttt{Lemma\_4\_5\_7} to \texttt{F} and
\texttt{h}. The conclusion of that lemma is
\texttt{equiv\_rel\ (EqRelFromPart\ F)}, but Lean will recognize this as
meaning the same thing as \texttt{equiv\_rel\ R}. Here is the proof of
the theorem:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_4\_5\_6 \{A : }\KeywordTok{Type}\NormalTok{\} (F : Set (Set A)) (h: partition F) :}
\NormalTok{    ∃ (R : BinRel A), equiv\_rel R ∧ mod A R = F := }\KeywordTok{by}
  \KeywordTok{set}\NormalTok{ R : BinRel A := EqRelFromPart F}
  \KeywordTok{apply}\NormalTok{ Exists.intro R               }\CommentTok{{-}{-}Goal : equiv\_rel R ∧ mod A R = F}
  \KeywordTok{apply}\NormalTok{ And.intro (Lemma\_4\_5\_7 F h)  }\CommentTok{{-}{-}Goal : mod A R = F}
  \KeywordTok{apply}\NormalTok{ Set.ext}
  \KeywordTok{fix}\NormalTok{ X : Set A                      }\CommentTok{{-}{-}Goal :  X ∈ mod A R ↔ X ∈ F}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h2 : X ∈ mod A R          }\CommentTok{{-}{-}Goal : X ∈ F}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2                     }\CommentTok{{-}{-}h2 : ∃ (x : A), equivClass R x = X}
    \KeywordTok{obtain}\NormalTok{ (x : A) (h3 : equivClass R x = X) }\KeywordTok{from}\NormalTok{ h2}
    \KeywordTok{have}\NormalTok{ h4 : x ∈ ⋃₀ F := h.left x}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h4}
    \KeywordTok{obtain}\NormalTok{ (Y : Set A) (h5 : Y ∈ F ∧ x ∈ Y) }\KeywordTok{from}\NormalTok{ h4}
    \KeywordTok{have}\NormalTok{ h6 : equivClass R x = Y :=}
\NormalTok{      Lemma\_4\_5\_8 F h Y h5.left x h5.right}
    \KeywordTok{rewrite}\NormalTok{ [←h3, h6]}
    \KeywordTok{show}\NormalTok{ Y ∈ F }\KeywordTok{from}\NormalTok{ h5.left}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} (←)}
    \KeywordTok{assume}\NormalTok{ h2 : X ∈ F                }\CommentTok{{-}{-}Goal : X ∈ mod A R}
    \KeywordTok{have}\NormalTok{ h3 : ¬empty X := h.right.right X h2}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h3; }\KeywordTok{double\_neg} \KeywordTok{at}\NormalTok{ h3   }\CommentTok{{-}{-}h3 : ∃ (x : A), x ∈ X}
    \KeywordTok{obtain}\NormalTok{ (x : A) (h4 : x ∈ X) }\KeywordTok{from}\NormalTok{ h3}
    \KeywordTok{define}                       \CommentTok{{-}{-}Goal : ∃ (x : A), equivClass R x = X}
    \KeywordTok{show}\NormalTok{ ∃ (x : A), equivClass R x = X }\KeywordTok{from}
\NormalTok{      Exists.intro x (Lemma\_4\_5\_8 F h X h2 x h4)}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-9}{%
\subsection{Exercises}\label{exercises-9}}

\begin{numex}{1}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ overlap\_implies\_equal \{A : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (F : Set (Set A)) (h : partition F) :}
\NormalTok{    ∀ X ∈ F, ∀ Y ∈ F, ∀ (x : A), x ∈ X → x ∈ Y → X = Y := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{2}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ Lemma\_4\_5\_7\_ref \{A : }\KeywordTok{Type}\NormalTok{\} (F : Set (Set A)) (h : partition F) :}
\NormalTok{    reflexive (EqRelFromPart F) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{3}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ Lemma\_4\_5\_7\_symm \{A : }\KeywordTok{Type}\NormalTok{\} (F : Set (Set A)) (h : partition F) :}
\NormalTok{    symmetric (EqRelFromPart F) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{4}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ Lemma\_4\_5\_7\_trans \{A : }\KeywordTok{Type}\NormalTok{\} (F : Set (Set A)) (h : partition F) :}
\NormalTok{    transitive (EqRelFromPart F) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{5}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ Lemma\_4\_5\_8 \{A : }\KeywordTok{Type}\NormalTok{\} (F : Set (Set A)) (h : partition F) :}
\NormalTok{    ∀ X ∈ F, ∀ x ∈ X, equivClass (EqRelFromPart F) x = X := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{6}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ elt\_mod\_equiv\_class\_of\_elt}
\NormalTok{    \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (h : equiv\_rel R) :}
\NormalTok{    ∀ X ∈ mod A R, ∀ x ∈ X, equivClass R x = X := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{mdsk}

\end{mdsk}

The next three exercises use the following definitions:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ dot \{A : }\KeywordTok{Type}\NormalTok{\} (F G : Set (Set A)) : Set (Set A) :=}
\NormalTok{  \{ Z : Set A | ¬empty Z ∧ ∃ X ∈ F, ∃ Y ∈ G, Z = X ∩ Y \}}

\KeywordTok{def}\NormalTok{ conj \{A : }\KeywordTok{Type}\NormalTok{\} (R S : BinRel A) (x y : A) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  R x y ∧ S x y}
\end{Highlighting}
\end{Shaded}

\begin{numex}{7}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_4\_5\_20a \{A : }\KeywordTok{Type}\NormalTok{\} (R S : BinRel A)}
\NormalTok{    (h1 : equiv\_rel R) (h2 : equiv\_rel S) :}
\NormalTok{    equiv\_rel (conj R S) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{8}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_4\_5\_20b \{A : }\KeywordTok{Type}\NormalTok{\} (R S : BinRel A)}
\NormalTok{    (h1 : equiv\_rel R) (h2 : equiv\_rel S) :}
\NormalTok{    ∀ (x : A), equivClass (conj R S) x =}
\NormalTok{      equivClass R x ∩ equivClass S x := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{9}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_4\_5\_20c \{A : }\KeywordTok{Type}\NormalTok{\} (R S : BinRel A)}
\NormalTok{    (h1 : equiv\_rel R) (h2 : equiv\_rel S) :}
\NormalTok{    mod A (conj R S) = dot (mod A R) (mod A S) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{mdsk}

\end{mdsk}

The next exercise uses the following definition:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ equiv\_mod (m x y : Int) : }\KeywordTok{Prop}\NormalTok{ := m ∣ (x {-} y)}
\end{Highlighting}
\end{Shaded}

\begin{numex}{10}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_4\_5\_10 : ∀ (m : Int), equiv\_rel (equiv\_mod m) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\bookmarksetup{startatroot}

\hypertarget{works-cited}{%
\chapter{Works Cited}\label{works-cited}}

This work had been formatted and styled from the book \emph{How To Prove
It With Lean}, written by Daniel J. Velleman. \emph{How To Prove It With
Lean} contains short excerpts from \emph{How To Prove It: A Structured
Approach, 3rd Edition}, by Daniel J. Velleman and published by Cambridge
University Press.

\hypertarget{functions}{%
\section{5.1. Functions}\label{functions}}

The first definition in Chapter 5 of \emph{HTPI} says that if
\(F \subseteq A \times B\), then \(F\) is called a \emph{function} from
\(A\) to \(B\) if for every \(a \in A\) there is exactly one \(b \in B\)
such that \((a, b) \in F\). The notation \(F : A \to B\) means that
\(F\) is a function from \(A\) to \(B\). If \(F\) is a function from
\(A\) to \(B\) and \(a \in A\), then \emph{HTPI} introduces the notation
\(F(a)\) for the unique \(b \in B\) such that \((a, b) \in F\). Thus, if
\(F : A \to B\), \(a \in A\), and \(b \in B\), then \(F(a) = b\) means
the same thing as \((a, b) \in F\). We sometimes think of \(F\) as
representing an operation that can be applied to an element \(a\) of
\(A\) to produce a corresponding element \(F(a)\) of \(B\), and we call
\(F(a)\) the \emph{value of \(F\) at \(a\)}, or the \emph{result of
applying \(F\) to \(a\)}.

This might remind you of the situation we faced in Chapter 4. If
\(R \subseteq A \times B\), \(a \in A\), and \(b \in B\), then Chapter 4
of \emph{HTPI} uses the notation \(aRb\) to mean the same thing as
\((a, b) \in R\). But in Lean, we found it necessary to change this
notation. Instead of using \emph{HTPI}'s notation \(aRb\), we introduced
the notation \texttt{R\ a\ b}, which we use when \texttt{R} has type
\texttt{Rel\ A\ B}, \texttt{a} has type \texttt{A}, and \texttt{b} has
type \texttt{B}. (The notation \texttt{(a,\ b)\ ∈\ R}, in contrast, can
be used only when \texttt{R} has type \texttt{Set\ (A\ ×\ B)}.) If
\texttt{R} has type \texttt{Rel\ A\ B}, then we think of \texttt{R} as
representing some relationship that might hold between \texttt{a} and
\texttt{b}, and \texttt{R\ a\ b} as the proposition saying that this
relationship holds. And although \texttt{R} is not a set of ordered
pairs, there is a corresponding set, \texttt{extension\ R}, of type
\texttt{Set\ (A\ ×\ B)}, with the property that
\texttt{(a,\ b)\ ∈\ extension\ R} if and only if \texttt{R\ a\ b}.

We will take a similar approach to functions in this chapter. For any
types \texttt{A} and \texttt{B}, we introduce a new type
\texttt{A\ →\ B}. If \texttt{f} has type \texttt{A\ →\ B}, then we think
of \texttt{f} as representing some operation that can be applied to an
object of type \texttt{A} to produce a corresponding object of type
\texttt{B}. We will say that \texttt{f} is a \emph{function} from
\texttt{A} to \texttt{B}, and \texttt{A} is the \emph{domain} of
\texttt{f}. If \texttt{a} has type \texttt{A}, then we write
\texttt{f\ a} (with a space but no parentheses) for the result of
applying the operation represented by \texttt{f} to the object
\texttt{a}. Thus, if we have \texttt{f\ :\ A\ →\ B} and
\texttt{a\ :\ A}, then \texttt{f\ a} has type \texttt{B}. As with
relations, if \texttt{f} has type \texttt{A\ →\ B}, then \texttt{f} is
not a set of ordered pairs. But there is a corresponding set of ordered
pairs, which we will call the \emph{graph} of \texttt{f}, whose elements
are the ordered pairs \texttt{(a,\ b)} for which \texttt{f\ a\ =\ b}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ graph \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) : Set (A × B) :=}
\NormalTok{  \{ (a, b) : A × B | f a = b \}}

\KeywordTok{theorem}\NormalTok{ graph\_def \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (a : A) (b : B) :}
\NormalTok{    (a, b) ∈ graph f ↔ f a = b := }\KeywordTok{by} \KeywordTok{rfl}
\end{Highlighting}
\end{Shaded}

Every set of type \texttt{Set\ (A\ ×\ B)} is the extension of some
relation from \texttt{A} to \texttt{B}, but not every such set is the
graph of a function from \texttt{A} to \texttt{B}. To be the graph of a
function, it must have the property that was used to define functions in
\emph{HTPI}: each object of type \texttt{A} must be paired in the set
with exactly one object of type \texttt{B}. Let's give this property a
name:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ is\_func\_graph \{A B : }\KeywordTok{Type}\NormalTok{\} (F : Set (A × B)) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  ∀ (x : A), ∃! (y : B), (x, y) ∈ F}
\end{Highlighting}
\end{Shaded}

And now we can say that the sets of type \texttt{Set\ (A\ ×\ B)} that
are graphs of functions from \texttt{A} to \texttt{B} are precisely the
ones that have the property \texttt{is\_func\_graph}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ func\_from\_graph \{A B : }\KeywordTok{Type}\NormalTok{\} (F : Set (A × B)) :}
\NormalTok{    (∃ (f : A → B), graph f = F) ↔ is\_func\_graph F}
\end{Highlighting}
\end{Shaded}

We will ask you to prove the left-to-right direction of this theorem in
the exercises. The proof of the right-to-left direction in Lean is
tricky; it requires an idea that we won't introduce until Section 8.2.
We'll give the proof then, but we'll go ahead and use the theorem in
this chapter when we find it useful.

Section 5.1 of \emph{HTPI} proves two theorems about functions. The
first gives a convenient way of proving that two functions are equal
(\emph{HTPI} p.~232):

\begin{nthm}{Theorem 5.1.4}
Suppose \(f\) and \(g\) are functions from \(A\) to \(B\). If
\(\forall a \in A(f(a) = g(a))\), then \(f = g\).

\end{nthm}

The proof of this theorem in \emph{HTPI} is based on the axiom of
extensionality for sets. But in Lean, functions aren't sets of ordered
pairs, so this method of proof won't work. Fortunately, Lean has a
similar axiom of extensionality for functions. The axiom is called
\texttt{funext}, and it proves Theorem 5.1.4.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_5\_1\_4 \{A B : }\KeywordTok{Type}\NormalTok{\} (f g : A → B) :}
\NormalTok{    (∀ (a : A), f a = g a) → f = g := funext}
\end{Highlighting}
\end{Shaded}

We saw previously that if we are trying to prove \texttt{X\ =\ Y}, where
\texttt{X} and \texttt{Y} both have type \texttt{Set\ U}, then often the
best first step is the tactic \texttt{apply\ Set.ext}, which converts
the goal to \texttt{∀\ (x\ :\ U),\ x\ ∈\ X\ ↔\ x\ ∈\ Y}. Similarly, if
we are trying to prove \texttt{f\ =\ g}, where \texttt{f} and \texttt{g}
both have type \texttt{A\ →\ B}, then we will usually start with the
tactic \texttt{apply\ funext}, which will convert the goal to
\texttt{∀\ (x\ :\ A),\ f\ x\ =\ g\ x}. By Theorem\_5\_1\_4, this implies
the original goal \texttt{f\ =\ g}. For example, here is a proof that if
two functions have the same graph, then they are equal:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ \{A B : }\KeywordTok{Type}\NormalTok{\} (f g : A → B) :}
\NormalTok{    graph f = graph g → f = g := }\KeywordTok{by}
  \KeywordTok{assume}\NormalTok{ h1 : graph f = graph g  }\CommentTok{{-}{-}Goal : f = g}
  \KeywordTok{apply}\NormalTok{ funext                   }\CommentTok{{-}{-}Goal : ∀ (x : A), f x = g x}
  \KeywordTok{fix}\NormalTok{ x : A}
  \KeywordTok{have}\NormalTok{ h2 : (x, f x) ∈ graph f := }\KeywordTok{by}
    \KeywordTok{define}                       \CommentTok{{-}{-}Goal : f x = f x}
    \KeywordTok{rfl}
    \KeywordTok{done}
  \KeywordTok{rewrite}\NormalTok{ [h1] }\KeywordTok{at}\NormalTok{ h2             }\CommentTok{{-}{-}h2 : (x, f x) ∈ graph g}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2                   }\CommentTok{{-}{-}h2 : g x = f x}
  \KeywordTok{show}\NormalTok{ f x = g x }\KeywordTok{from}\NormalTok{ h2.symm}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

The axiom of extensionality for sets says that a set is completely
determined by its elements. This is what justifies our usual method of
defining a set: we specify what its elements are, using notation like
\texttt{\{0,\ 1,\ 2\}} or
\texttt{\{\ x\ :\ Nat\ \textbar{}\ x\ \textless{}\ 3\ \}}. Similarly,
the axiom of extensionality for functions says that a function is
completely determined by its values, and therefore we can define a
function by specifying its values. For instance, we can define a
function from \texttt{Nat} to \texttt{Nat} by specifying, for any
\texttt{n\ :\ Nat}, the result of applying the function to \texttt{n}.
As an example of this, we could define the ``squaring function'' from
\texttt{Nat} to \texttt{Nat} to be the function that, when applied to
any \texttt{n\ :\ Nat}, produces the result \texttt{n\ \^{}\ 2}. Here
are two ways to define this function in Lean:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ square1 (n : Nat) : Nat := n \^{} 2}

\KeywordTok{def}\NormalTok{ square2 : Nat → Nat := fun (n : Nat) =\textgreater{} n \^{} 2}
\end{Highlighting}
\end{Shaded}

The first of these definitions uses notation we have used before; it
says that if \texttt{n} has type \texttt{Nat}, then the expression
\texttt{square1\ n} also has type \texttt{Nat}, and it is definitionally
equal to \texttt{n\ \^{}\ 2}. The second definition introduces new Lean
notation. It says that \texttt{square2} has type \texttt{Nat\ →\ Nat},
and it defines it to be the function that, when applied to any
\texttt{n} of type \texttt{Nat}, yields the result \texttt{n\ \^{}\ 2}.
Of course, this also means that \texttt{square2\ n} is definitionally
equal to \texttt{n\ \^{}\ 2}. In general, the notation
\texttt{fun\ (x\ :\ A)\ =\textgreater{}\ ...} means ``the function
which, when applied to any \texttt{x} of type \texttt{A}, yields the
result \ldots{}'' The two definitions above are equivalent. You can ask
Lean to confirm this, and try out the squaring function, as follows (the
\texttt{\#eval} command asks Lean to evaluate an expression):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ : square1 = square2 := }\KeywordTok{by} \KeywordTok{rfl}

\SpecialCharTok{++}\DocumentationTok{\#eval}\SpecialCharTok{::}\NormalTok{ square1 7     }\CommentTok{{-}{-}Answer: 49}
\end{Highlighting}
\end{Shaded}

There is one more theorem in Section 5.1 of \emph{HTPI}. Theorem 5.1.5
says that if \(f\) is a function from \(A\) to \(B\) and \(g\) is a
function from \(B\) to \(C\), then the composition of \(g\) and \(f\) is
a function from \(A\) to \(C\). To state this theorem in Lean, we will
have to make adjustments for the differences between the treatment of
functions in \emph{HTPI} and Lean. In Chapter 4, we defined
\texttt{comp\ S\ R} to be the composition of \texttt{S} and \texttt{R},
where \texttt{R} has type \texttt{Set\ (A\ ×\ B)} and \texttt{S} had
type \texttt{Set\ (B\ ×\ C)}. But functions in Lean are not sets of
ordered pairs, so we cannot apply the operation \texttt{comp} to them.
We can, however, apply it to their graphs. So the theorem corresponding
to Theorem 5.1.5 in \emph{HTPI} is this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_5\_1\_5 \{A B C : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (g : B → C) :}
\NormalTok{    ∃ (h : A → C), graph h = comp (graph g) (graph f) := }\KeywordTok{by}
  \KeywordTok{set}\NormalTok{ h : A → C := fun (x : A) =\textgreater{} g (f x)}
  \KeywordTok{apply}\NormalTok{ Exists.intro h}
  \KeywordTok{apply}\NormalTok{ Set.ext}
  \KeywordTok{fix}\NormalTok{ (a, c) : A × C}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} Proof that (a, c) ∈ graph h → (a, c) ∈ comp (graph g) (graph f)}
    \KeywordTok{assume}\NormalTok{ h1 : (a, c) ∈ graph h}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1  }\CommentTok{{-}{-}h1 : h a = c}
    \KeywordTok{define}        \CommentTok{{-}{-}Goal : ∃ (x : B), (a, x) ∈ graph f ∧ (x, c) ∈ graph g}
    \KeywordTok{apply}\NormalTok{ Exists.intro (f a)}
    \KeywordTok{apply}\NormalTok{ And.intro}
\NormalTok{    · }\CommentTok{{-}{-} Proof that (a, f a) ∈ graph f}
      \KeywordTok{define}
      \KeywordTok{rfl}
      \KeywordTok{done}
\NormalTok{    · }\CommentTok{{-}{-} Proof that (f a, c) ∈ graph g}
      \KeywordTok{define}
      \KeywordTok{show}\NormalTok{ g (f a) = c }\KeywordTok{from}\NormalTok{ h1}
      \KeywordTok{done}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Proof that (a, c) ∈ comp (graph g) (graph f) → (a, c) ∈ graph h}
    \KeywordTok{assume}\NormalTok{ h1 : (a, c) ∈ comp (graph g) (graph f)}
    \KeywordTok{define}        \CommentTok{{-}{-}Goal : h a = c}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1  }\CommentTok{{-}{-}h1 : ∃ (x : B), (a, x) ∈ graph f ∧ (x, c) ∈ graph g}
    \KeywordTok{obtain}\NormalTok{ (b : B) (h2 : (a, b) ∈ graph f ∧ (b, c) ∈ graph g) }\KeywordTok{from}\NormalTok{ h1}
    \KeywordTok{have}\NormalTok{ h3 : (a, b) ∈ graph f := h2.left}
    \KeywordTok{have}\NormalTok{ h4 : (b, c) ∈ graph g := h2.right}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h3          }\CommentTok{{-}{-}h3 : f a = b}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h4          }\CommentTok{{-}{-}h4 : g b = c}
    \KeywordTok{rewrite}\NormalTok{ [←h3] }\KeywordTok{at}\NormalTok{ h4   }\CommentTok{{-}{-}h4 : g (f a) = c}
    \KeywordTok{show}\NormalTok{ h a = c }\KeywordTok{from}\NormalTok{ h4}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

Notice that the proof of \texttt{Theorem\_5\_1\_5} begins by defining
the function \texttt{h} for which
\texttt{graph\ h\ =\ comp\ (graph\ g)\ (graph\ f)}. The definition says
that for all \texttt{x} of type \texttt{A}, \texttt{h\ x\ =\ g\ (f\ x)}.
This function \texttt{h} is called the \emph{composition} of \texttt{g}
and \texttt{f}, and it is denoted \texttt{g\ ∘\ f}. (To type \texttt{∘}
in VS Code, type \texttt{\textbackslash{}comp} or
\texttt{\textbackslash{}circ}.) In other words, \texttt{g\ ∘\ f} has
type \texttt{A\ →\ C}, and for all \texttt{x} of type \texttt{A},
\texttt{(g\ ∘\ f)\ x} is definitionally equal to \texttt{g\ (f\ x)}. In
\emph{HTPI}, functions are sets of ordered pairs, and the operation of
composition of functions is literally the same as the operation
\texttt{comp} that we used in Chapter 4. But in Lean, we distinguish
among functions, relations, and sets of ordered pairs, so all we can say
is that the operation of composition of functions corresponds to the
operation \texttt{comp} from Chapter 4. The correspondence is that, as
shown in the proof of \texttt{Theorem\_5\_1\_5}, if
\texttt{h\ =\ g\ ∘\ f}, then
\texttt{graph\ h\ =\ comp\ (graph\ g)\ (graph\ f)}.

We saw in part 4 of Theorem 4.2.5 that composition of relations is
associative. Composition of functions is also associative. In fact, if
\texttt{f\ :\ A\ →\ B}, \texttt{g\ :\ B\ →\ C}, and
\texttt{h\ :\ C\ →\ D}, then \texttt{h\ ∘\ (g\ ∘\ f)} and
\texttt{(h\ ∘\ g)\ ∘\ f} are definitionally equal, since they both mean
the same thing as
\texttt{fun\ (x\ :\ A)\ =\textgreater{}\ h\ (g\ (f\ a))}. As a result,
the tactic \texttt{rfl} proves the associativity of composition of
functions:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ \{A B C D : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (g : B → C) (h : C → D) :}
\NormalTok{    h ∘ (g ∘ f) = (h ∘ g) ∘ f := }\KeywordTok{by} \KeywordTok{rfl}
\end{Highlighting}
\end{Shaded}

\emph{HTPI} defines the identity function on a set \(A\) to be the
function \(i_A\) from \(A\) to \(A\) such that
\(\forall x \in A(i_A(x) = x)\), and Exercise 9 from Section 4.3 of
\emph{HTPI} implies that if \(f : A \to B\), then \(f \circ i_A = f\)
and \(i_B \circ f = f\). We say, therefore, that the identity functions
are \emph{identity elements} for composition of functions. Similarly, in
Lean, for each type \texttt{A} there is an identity function from
\texttt{A} to \texttt{A}. This identity function is denoted \texttt{id};
there is no need to specify \texttt{A} in the notation, because
\texttt{A} is an implicit argument to \texttt{id}. Thus, when you use
\texttt{id} to denote an identity function, Lean will figure out what
type \texttt{A} to use as the domain of the function. (If, for some
reason, you want to specify that the domain is some type \texttt{A}, you
can write \texttt{@id\ A} instead of \texttt{id}.) For any \texttt{x},
of any type, \texttt{id\ x} is definitionally equal to \texttt{x}, and
as a result the proof that \texttt{id} is an identity element for
composition of functions can also be done with the \texttt{rfl} tactic:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) : f ∘ id = f := }\KeywordTok{by} \KeywordTok{rfl}

\KeywordTok{example}\NormalTok{ \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) : id ∘ f = f := }\KeywordTok{by} \KeywordTok{rfl}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-10}{%
\subsection{Exercises}\label{exercises-10}}

\begin{numex}{1}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ func\_from\_graph\_ltr \{A B : }\KeywordTok{Type}\NormalTok{\} (F : Set (A × B)) :}
\NormalTok{    (∃ (f : A → B), graph f = F) → is\_func\_graph F := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{2}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_1\_13a}
\NormalTok{    \{A B C : }\KeywordTok{Type}\NormalTok{\} (R : Set (A × B)) (S : Set (B × C)) (f : A → C)}
\NormalTok{    (h1 : ∀ (b : B), b ∈ Ran R ∧ b ∈ Dom S) (h2 : graph f = comp S R) :}
\NormalTok{    is\_func\_graph S := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{3}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_1\_14a}
\NormalTok{    \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (R : BinRel A) (S : BinRel B)}
\NormalTok{    (h : ∀ (x y : A), R x y ↔ S (f x) (f y)) :}
\NormalTok{    reflexive S → reflexive R := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

4. Here is a putative theorem:

\begin{nthm}{Theorem?}
Suppose \(f : A \to B\), \(R\) is a binary relation on \(A\), and \(S\)
is the binary relation on \(B\) defined as follows: \[
\forall x \in B \forall y \in B(xSy \leftrightarrow \exists u \in A\exists v \in A(f(u) = x \wedge f(v) = y \wedge uRv)).
\] If \(R\) is reflexive then \(S\) is reflexive.

\end{nthm}

Is the theorem correct? Try to prove it in Lean. If you can't prove it,
see if you can find a counterexample.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-}You might not be able to complete this proof}
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_1\_15a}
\NormalTok{    \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (R : BinRel A) (S : BinRel B)}
\NormalTok{    (h : ∀ (x y : B), S x y ↔ ∃ (u v : A), f u = x ∧ f v = y ∧ R u v) :}
\NormalTok{    reflexive R → reflexive S := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

5. Here is a putative theorem with an incorrect proof:

\begin{nthm}{Theorem?}
Suppose \(f : A \to B\), \(R\) is a binary relation on \(A\), and \(S\)
is the binary relation on \(B\) defined as follows: \[
\forall x \in B \forall y \in B(xSy \leftrightarrow \exists u \in A\exists v \in A(f(u) = x \wedge f(v) = y \wedge uRv)).
\] If \(R\) is transitive then \(S\) is transitive.

\end{nthm}

\begin{npf}{Incorrect Proof}
Suppose \(R\) is transitive. Let \(x\), \(y\), and \(z\) be arbitrary
elements of \(B\). Assume that \(xSy\) and \(ySz\). By the definition of
\(S\), this means that there are \(u\), \(v\), and \(w\) in \(A\) such
that \(f(u) = x\), \(f(v) = y\), \(f(w) = z\), \(uRv\), and \(vRw\).
Since \(R\) is transitive, it follows that \(uRw\). Since \(f(u) = x\),
\(f(w) = z\), and \(uRw\), \(xSz\). Therefore \(S\) is transitive.
\excl{~□}\qedhere

\end{npf}

Find the mistake in the proof by attempting to write the proof in Lean.
Is the theorem correct?

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-}You might not be able to complete this proof}
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_1\_15c}
\NormalTok{    \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (R : BinRel A) (S : BinRel B)}
\NormalTok{    (h : ∀ (x y : B), S x y ↔ ∃ (u v : A), f u = x ∧ f v = y ∧ R u v) :}
\NormalTok{    transitive R → transitive S := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\begin{numex}{6}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_1\_16b}
\NormalTok{    \{A B : }\KeywordTok{Type}\NormalTok{\} (R : BinRel B) (S : BinRel (A → B))}
\NormalTok{    (h : ∀ (f g : A → B), S f g ↔ ∀ (x : A), R (f x) (g x)) :}
\NormalTok{    symmetric R → symmetric S := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{7}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_1\_17a \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A) (a : A)}
\NormalTok{    (h : ∀ (x : A), f x = a) : ∀ (g : A → A), f ∘ g = f := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{8}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_1\_17b \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A) (a : A)}
\NormalTok{    (h : ∀ (g : A → A), f ∘ g = f) :}
\NormalTok{    ∃ (y : A), ∀ (x : A), f x = y := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\hypertarget{one-to-one-and-onto}{%
\section{5.2. One-to-One and Onto}\label{one-to-one-and-onto}}

Section 5.2 of \emph{HTPI} introduces two important properties that a
function might have. A function \texttt{f\ :\ A\ →\ B} is called
\emph{onto} if for every \texttt{b} of type \texttt{B} there is at least
one \texttt{a} of type \texttt{A} such that \texttt{f\ a\ =\ b}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ onto \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  ∀ (y : B), ∃ (x : A), f x = y}
\end{Highlighting}
\end{Shaded}

It is called \emph{one-to-one} if there do \emph{not} exist distinct
\texttt{a1} and \texttt{a2} of type \texttt{A} such that
\texttt{f\ a1\ =\ f\ a2}. This phrasing of the definition makes it clear
what is at issue: Are there distinct objects in the domain to which the
function assigns the same value? But it is a negative statement, and
that would make it difficult to work with it in proofs. Fortunately, it
is not hard to rephrase the definition as an equivalent positive
statement, using quantifier negation, De Morgan, and conditional laws.
The resulting equivalent positive statement is given in Theorem 5.2.3 of
\emph{HTPI}, and we take it as our official definition of
\texttt{one\_to\_one} in Lean:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ one\_to\_one \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  ∀ (x1 x2 : A), f x1 = f x2 → x1 = x2}
\end{Highlighting}
\end{Shaded}

There is only one more theorem about these properties in Section 5.2 of
\emph{HTPI}. It says that a composition of one-to-one functions is
one-to-one, and a composition of onto functions is onto. It is
straightforward to carry out these proofs in Lean by simply applying the
definitions of the relevant concepts.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_5\_2\_5\_1 \{A B C : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (g : B → C) :}
\NormalTok{    one\_to\_one f → one\_to\_one g → one\_to\_one (g ∘ f) := }\KeywordTok{by}
  \KeywordTok{assume}\NormalTok{ h1 : one\_to\_one f}
  \KeywordTok{assume}\NormalTok{ h2 : one\_to\_one g}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1  }\CommentTok{{-}{-}h1 : ∀ (x1 x2 : A), f x1 = f x2 → x1 = x2}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2  }\CommentTok{{-}{-}h2 : ∀ (x1 x2 : B), g x1 = g x2 → x1 = x2}
  \KeywordTok{define}        \CommentTok{{-}{-}Goal : ∀ (x1 x2 : A), (g ∘ f) x1 = (g ∘ f) x2 → x1 = x2}
  \KeywordTok{fix}\NormalTok{ a1 : A}
  \KeywordTok{fix}\NormalTok{ a2 : A    }\CommentTok{{-}{-}Goal : (g ∘ f) a1 = (g ∘ f) a2 → a1 = a2}
  \KeywordTok{define}\NormalTok{ : (g ∘ f) a1; }\KeywordTok{define}\NormalTok{ : (g ∘ f) a2}
                \CommentTok{{-}{-}Goal : g (f a1) = g (f a2) → a1 = a2}
  \KeywordTok{assume}\NormalTok{ h3 : g (f a1) = g (f a2)}
  \KeywordTok{have}\NormalTok{ h4 : f a1 = f a2 := h2 (f a1) (f a2) h3}
  \KeywordTok{show}\NormalTok{ a1 = a2 }\KeywordTok{from}\NormalTok{ h1 a1 a2 h4}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

Notice that the tactic \texttt{define\ :\ (g\ ∘\ f)\ a1} replaces
\texttt{(g\ ∘\ f)\ a1} with its definition, \texttt{g\ (f\ a1)}. As
usual, this step isn't really needed---Lean will apply the definition on
its own when necessary, without being told. But using this tactic makes
the proof easier to read. Also, notice that \texttt{define\ :\ g\ ∘\ f}
produces a result that is much less useful. As we have observed before,
the \texttt{define} tactic works best when applied to a complete
expression, rather than just a part of an expression.

An alternative way to apply the definition of composition of functions
is to prove a lemma that can be used in the \texttt{rewrite} tactic. We
try out this approach for the second part of the theorem.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ comp\_def \{A B C : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (g : B → C) (x : A) :}
\NormalTok{    (g ∘ f) x = g (f x) := }\KeywordTok{by} \KeywordTok{rfl}

\KeywordTok{theorem}\NormalTok{ Theorem\_5\_2\_5\_2 \{A B C : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (g : B → C) :}
\NormalTok{    onto f → onto g → onto (g ∘ f) := }\KeywordTok{by}
  \KeywordTok{assume}\NormalTok{ h1 : onto f}
  \KeywordTok{assume}\NormalTok{ h2 : onto g}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1           }\CommentTok{{-}{-}h1 : ∀ (y : B), ∃ (x : A), f x = y}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2           }\CommentTok{{-}{-}h2 : ∀ (y : C), ∃ (x : B), g x = y}
  \KeywordTok{define}                 \CommentTok{{-}{-}Goal : ∀ (y : C), ∃ (x : A), (g ∘ f) x = y}
  \KeywordTok{fix}\NormalTok{ c : C}
  \KeywordTok{obtain}\NormalTok{ (b : B) (h3 : g b = c) }\KeywordTok{from}\NormalTok{ h2 c}
  \KeywordTok{obtain}\NormalTok{ (a : A) (h4 : f a = b) }\KeywordTok{from}\NormalTok{ h1 b}
  \KeywordTok{apply}\NormalTok{ Exists.intro a   }\CommentTok{{-}{-}Goal : (g ∘ f) a = c}
  \KeywordTok{rewrite}\NormalTok{ [comp\_def]     }\CommentTok{{-}{-}Goal : g (f a) = c}
  \KeywordTok{rewrite}\NormalTok{ [←h4] }\KeywordTok{at}\NormalTok{ h3}
  \KeywordTok{show}\NormalTok{ g (f a) = c }\KeywordTok{from}\NormalTok{ h3}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-11}{%
\subsection{Exercises}\label{exercises-11}}

\begin{numex}{1}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_2\_10a \{A B C : }\KeywordTok{Type}\NormalTok{\} (f: A → B) (g : B → C) :}
\NormalTok{    onto (g ∘ f) → onto g := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{2}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_2\_10b \{A B C : }\KeywordTok{Type}\NormalTok{\} (f: A → B) (g : B → C) :}
\NormalTok{    one\_to\_one (g ∘ f) → one\_to\_one f := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{3}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_2\_11a \{A B C : }\KeywordTok{Type}\NormalTok{\} (f: A → B) (g : B → C) :}
\NormalTok{    onto f → ¬(one\_to\_one g) → ¬(one\_to\_one (g ∘ f)) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{4}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_2\_11b \{A B C : }\KeywordTok{Type}\NormalTok{\} (f: A → B) (g : B → C) :}
\NormalTok{    ¬(onto f) → one\_to\_one g → ¬(onto (g ∘ f)) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{5}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_2\_12 \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (g : B → Set A)}
\NormalTok{    (h : ∀ (b : B), g b = \{ a : A | f a = b \}) :}
\NormalTok{    onto f → one\_to\_one g := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{6}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_2\_16 \{A B C : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (R : Set (A × B)) (S : Set (B × C)) (f : A → C) (g : B → C)}
\NormalTok{    (h1 : graph f = comp S R) (h2 : graph g = S) (h3 : one\_to\_one g) :}
\NormalTok{    is\_func\_graph R := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{7}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_2\_17a}
\NormalTok{    \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (R : BinRel A) (S : BinRel B)}
\NormalTok{    (h1 : ∀ (x y : B), S x y ↔ ∃ (u v : A), f u = x ∧ f v = y ∧ R u v)}
\NormalTok{    (h2 : onto f) : reflexive R → reflexive S := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{8}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_2\_17b}
\NormalTok{    \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (R : BinRel A) (S : BinRel B)}
\NormalTok{    (h1 : ∀ (x y : B), S x y ↔ ∃ (u v : A), f u = x ∧ f v = y ∧ R u v)}
\NormalTok{    (h2 : one\_to\_one f) : transitive R → transitive S := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{9}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_2\_21a \{A B C : }\KeywordTok{Type}\NormalTok{\} (f : B → C) (g h : A → B)}
\NormalTok{    (h1 : one\_to\_one f) (h2 : f ∘ g = f ∘ h) : g = h := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{10}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_2\_21b \{A B C : }\KeywordTok{Type}\NormalTok{\} (f : B → C) (a : A)}
\NormalTok{    (h1 : ∀ (g h : A → B), f ∘ g = f ∘ h → g = h) :}
\NormalTok{    one\_to\_one f := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\hypertarget{inverses-of-functions}{%
\section{5.3. Inverses of Functions}\label{inverses-of-functions}}

Section 5.3 of \emph{HTPI} is motivated by the following question: If
\(f\) is a function from \(A\) to \(B\), is \(f^{-1}\) a function from
\(B\) to \(A\)? Here is the first theorem in that section (\emph{HTPI}
p.~250):

\begin{nthm}{Theorem 5.3.1}
Suppose \(f : A \to B\). If \(f\) is one-to-one and onto, then
\(f^{-1} : B \to A\).

\end{nthm}

Of course, we will have to rephrase this theorem slightly to prove it in
Lean. If \texttt{f} has type \texttt{A\ →\ B}, then the inverse
operation \texttt{inv} cannot be applied to \texttt{f}, but it can be
applied to \texttt{graph\ f}. So we must rephrase the theorem like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_5\_3\_1 \{A B : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (f : A → B) (h1 : one\_to\_one f) (h2 : onto f) :}
\NormalTok{    ∃ (g : B → A), graph g = inv (graph f)}
\end{Highlighting}
\end{Shaded}

To prove this theorem, we will use the theorem
\texttt{func\_from\_graph} that was stated in Section 5.1. We can remind
ourselves of what that theorem says by using the command
\texttt{\#check\ @func\_from\_graph}, which gives the result:

\begin{ind}

\begin{verbatim}
@func_from_graph : ∀ {A B : Type} (F : Set (A × B)),
                    (∃ (f : A → B), graph f = F) ↔ is_func_graph F
\end{verbatim}

\end{ind}

This means that, in the context of the proof of
\texttt{Theorem\_5\_3\_1}, \texttt{func\_from\_graph\ (inv\ (graph\ f))}
is a proof of the statement

\begin{ind}

\begin{verbatim}
∃ (g : B → A), graph g = inv (graph f) ↔ is_func_graph (inv (graph f)).
\end{verbatim}

\end{ind}

Therefore the tactic
\texttt{rewrite\ {[}func\_from\_graph\ (inv\ (graph\ f)){]}} will change
the goal to \texttt{is\_func\_graph\ (inv\ (func\ f))}. In fact, we can
just use \texttt{rewrite\ {[}func\_from\_graph{]}}, and Lean will figure
out how to apply the theorem to rewrite the goal. The rest of the proof
is straightforward.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_5\_3\_1 \{A B : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (f : A → B) (h1 : one\_to\_one f) (h2 : onto f) :}
\NormalTok{    ∃ (g : B → A), graph g = inv (graph f) := }\KeywordTok{by}
  \KeywordTok{rewrite}\NormalTok{ [func\_from\_graph]   }\CommentTok{{-}{-}Goal : is\_func\_graph (inv (graph f))}
  \KeywordTok{define}        \CommentTok{{-}{-}Goal : ∀ (x : B), ∃! (y : A), (x, y) ∈ inv (graph f)}
  \KeywordTok{fix}\NormalTok{ b : B}
  \KeywordTok{exists\_unique}
\NormalTok{  · }\CommentTok{{-}{-} Existence}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2          }\CommentTok{{-}{-}h2 : ∀ (y : B), ∃ (x : A), f x = y}
    \KeywordTok{obtain}\NormalTok{ (a : A) (h4 : f a = b) }\KeywordTok{from}\NormalTok{ h2 b}
    \KeywordTok{apply}\NormalTok{ Exists.intro a  }\CommentTok{{-}{-}Goal : (b, a) ∈ inv (graph f)}
    \KeywordTok{define}                \CommentTok{{-}{-}Goal : f a = b}
    \KeywordTok{show}\NormalTok{ f a = b }\KeywordTok{from}\NormalTok{ h4}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Uniqueness}
    \KeywordTok{fix}\NormalTok{ a1 : A; }\KeywordTok{fix}\NormalTok{ a2 : A}
    \KeywordTok{assume}\NormalTok{ h3 : (b, a1) ∈ inv (graph f)}
    \KeywordTok{assume}\NormalTok{ h4 : (b, a2) ∈ inv (graph f) }\CommentTok{{-}{-}Goal : a1 = a2}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h3          }\CommentTok{{-}{-}h3 : f a1 = b}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h4          }\CommentTok{{-}{-}h4 : f a2 = b}
    \KeywordTok{rewrite}\NormalTok{ [←h4] }\KeywordTok{at}\NormalTok{ h3   }\CommentTok{{-}{-}h3 : f a1 = f a2}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1          }\CommentTok{{-}{-}h1 : ∀ (x1 x2 : A), f x1 = f x2 → x1 = x2}
    \KeywordTok{show}\NormalTok{ a1 = a2 }\KeywordTok{from}\NormalTok{ h1 a1 a2 h3}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

Suppose, now, that we have \texttt{f\ :\ A\ →\ B},
\texttt{g\ :\ B\ →\ A}, and \texttt{graph\ g\ =\ inv\ (graph\ f)}, as in
\texttt{Theorem\_5\_3\_1}. What can we say about the relationship
between \texttt{f} and \texttt{g}? One answer is that
\texttt{g\ ∘\ f\ =\ id} and \texttt{f\ ∘\ g\ =\ id}, as shown in Theorem
5.3.2 of \emph{HTPI}. We'll prove one of these facts, and leave the
other as an exercise for you.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_5\_3\_2\_1 \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (g : B → A)}
\NormalTok{    (h1 : graph g = inv (graph f)) : g ∘ f = id := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ funext           }\CommentTok{{-}{-}Goal : ∀ (x : A), (g ∘ f) x = id x}
  \KeywordTok{fix}\NormalTok{ a : A              }\CommentTok{{-}{-}Goal : (g ∘ f) a = id a}
  \KeywordTok{have}\NormalTok{ h2 : (f a, a) ∈ graph g := }\KeywordTok{by}
    \KeywordTok{rewrite}\NormalTok{ [h1]         }\CommentTok{{-}{-}Goal : (f a, a) ∈ inv (graph f)}
    \KeywordTok{define}               \CommentTok{{-}{-}Goal : f a = f a}
    \KeywordTok{rfl}
    \KeywordTok{done}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2           }\CommentTok{{-}{-}h2 : g (f a) = a}
  \KeywordTok{show}\NormalTok{ (g ∘ f) a = id a }\KeywordTok{from}\NormalTok{ h2}
  \KeywordTok{done}

\KeywordTok{theorem}\NormalTok{ Theorem\_5\_3\_2\_2 \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (g : B → A)}
\NormalTok{    (h1 : graph g = inv (graph f)) : f ∘ g = id := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

Combining the theorems above, we have shown that if \texttt{f} is
one-to-one and onto, then there is a function \texttt{g} such that
\texttt{g\ ∘\ f\ =\ id} and \texttt{f\ ∘\ g\ =\ id}. In fact, the
converse is true as well: if such a function \texttt{g} exists, then
\texttt{f} must be one-to-one and onto. Again, we'll prove one statement
and leave the second as an exercise.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_5\_3\_3\_1 \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (g : B → A)}
\NormalTok{    (h1 : g ∘ f = id) : one\_to\_one f := }\KeywordTok{by}
  \KeywordTok{define}              \CommentTok{{-}{-}Goal : ∀ (x1 x2 : A), f x1 = f x2 → x1 = x2}
  \KeywordTok{fix}\NormalTok{ a1 : A; }\KeywordTok{fix}\NormalTok{ a2 : A}
  \KeywordTok{assume}\NormalTok{ h2 : f a1 = f a2}
  \KeywordTok{show}\NormalTok{ a1 = a2 }\KeywordTok{from}
    \KeywordTok{calc}\NormalTok{ a1}
\NormalTok{      \_ = id a1 := }\KeywordTok{by} \KeywordTok{rfl}
\NormalTok{      \_ = (g ∘ f) a1 := }\KeywordTok{by} \KeywordTok{rw}\NormalTok{ [h1]}
\NormalTok{      \_ = g (f a1) := }\KeywordTok{by} \KeywordTok{rfl}
\NormalTok{      \_ = g (f a2) := }\KeywordTok{by} \KeywordTok{rw}\NormalTok{ [h2]}
\NormalTok{      \_ = (g ∘ f) a2 := }\KeywordTok{by} \KeywordTok{rfl}
\NormalTok{      \_ = id a2 := }\KeywordTok{by} \KeywordTok{rw}\NormalTok{ [h1]}
\NormalTok{      \_ = a2 := }\KeywordTok{by} \KeywordTok{rfl}
  \KeywordTok{done}

\KeywordTok{theorem}\NormalTok{ Theorem\_5\_3\_3\_2 \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (g : B → A)}
\NormalTok{    (h1 : f ∘ g = id) : onto f := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

We can combine the theorems above to show that if we have
\texttt{f\ :\ A\ →\ B}, \texttt{g\ :\ B\ →\ A}, \texttt{g\ ∘\ f\ =\ id},
and \texttt{f\ ∘\ g\ =\ id}, then \texttt{graph\ g} must be the inverse
of \texttt{graph\ f}. Compare the proof below to the proof of Theorem
5.3.5 in \emph{HTPI}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_5\_3\_5 \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (g : B → A)}
\NormalTok{    (h1 : g ∘ f = id) (h2 : f ∘ g = id) : graph g = inv (graph f) := }\KeywordTok{by}
  \KeywordTok{have}\NormalTok{ h3 : one\_to\_one f := Theorem\_5\_3\_3\_1 f g h1}
  \KeywordTok{have}\NormalTok{ h4 : onto f := Theorem\_5\_3\_3\_2 f g h2}
  \KeywordTok{obtain}\NormalTok{ (g\textquotesingle{} : B → A) (h5 : graph g\textquotesingle{} = inv (graph f))}
    \KeywordTok{from}\NormalTok{ Theorem\_5\_3\_1 f h3 h4}
  \KeywordTok{have}\NormalTok{ h6 : g\textquotesingle{} ∘ f = id := Theorem\_5\_3\_2\_1 f g\textquotesingle{} h5}
  \KeywordTok{have}\NormalTok{ h7 : g = g\textquotesingle{} :=}
    \KeywordTok{calc}\NormalTok{ g}
\NormalTok{      \_ = id ∘ g := }\KeywordTok{by} \KeywordTok{rfl}
\NormalTok{      \_ = (g\textquotesingle{} ∘ f) ∘ g := }\KeywordTok{by} \KeywordTok{rw}\NormalTok{ [h6]}
\NormalTok{      \_ = g\textquotesingle{} ∘ (f ∘ g) := }\KeywordTok{by} \KeywordTok{rfl}
\NormalTok{      \_ = g\textquotesingle{} ∘ id := }\KeywordTok{by} \KeywordTok{rw}\NormalTok{ [h2]}
\NormalTok{      \_ = g\textquotesingle{} := }\KeywordTok{by} \KeywordTok{rfl}
  \KeywordTok{rewrite}\NormalTok{ [←h7] }\KeywordTok{at}\NormalTok{ h5}
  \KeywordTok{show}\NormalTok{ graph g = inv (graph f) }\KeywordTok{from}\NormalTok{ h5}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-12}{%
\subsection{Exercises}\label{exercises-12}}

\begin{numex}{1}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_5\_3\_2\_2 \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (g : B → A)}
\NormalTok{    (h1 : graph g = inv (graph f)) : f ∘ g = id := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{2}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_5\_3\_3\_2 \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (g : B → A)}
\NormalTok{    (h1 : f ∘ g = id) : onto f := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{3}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_3\_11a \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (g : B → A) :}
\NormalTok{    one\_to\_one f → f ∘ g = id → graph g = inv (graph f) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{4}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_3\_11b \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (g : B → A) :}
\NormalTok{    onto f → g ∘ f = id → graph g = inv (graph f) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{5}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_3\_14a \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (g : B → A)}
\NormalTok{    (h : f ∘ g = id) : ∀ x ∈ Ran (graph g), g (f x) = x := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{6}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_3\_18 \{A B C : }\KeywordTok{Type}\NormalTok{\} (f : A → C) (g : B → C)}
\NormalTok{    (h1 : one\_to\_one g) (h2 : onto g) :}
\NormalTok{    ∃ (h : A → B), g ∘ h = f := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{mdsk}

\end{mdsk}

The next two exercises will use the following definition:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ conjugate (A : }\KeywordTok{Type}\NormalTok{) (f1 f2 : A → A) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  ∃ (g g\textquotesingle{} : A → A), (f1 = g\textquotesingle{} ∘ f2 ∘ g) ∧ (g ∘ g\textquotesingle{} = id) ∧ (g\textquotesingle{} ∘ g = id)}
\end{Highlighting}
\end{Shaded}

\begin{numex}{7}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_3\_17a \{A : }\KeywordTok{Type}\NormalTok{\} : symmetric (conjugate A) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{8}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_3\_17b \{A : }\KeywordTok{Type}\NormalTok{\} (f1 f2 : A → A)}
\NormalTok{    (h1 : conjugate A f1 f2) (h2 : ∃ (a : A), f1 a = a) :}
\NormalTok{    ∃ (a : A), f2 a = a := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\hypertarget{closures}{%
\section{5.4. Closures}\label{closures}}

Suppose we have \texttt{f\ :\ A\ →\ A} and \texttt{C\ :\ Set\ A}. We say
that \texttt{C} is \emph{closed} under \texttt{f} if the value of
\texttt{f} at any element of \texttt{C} is again an element of
\texttt{C}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ closed \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A) (C : Set A) : }\KeywordTok{Prop}\NormalTok{ := ∀ x ∈ C, f x ∈ C}
\end{Highlighting}
\end{Shaded}

According to this definition, \texttt{closed\ f\ C} means that
\texttt{C} is closed under \texttt{f}. Sometimes, if we have a set
\texttt{B} of type \texttt{Set\ A} that is not closed under \texttt{f},
we are interested in adding more elements to the set to make it closed.
The \emph{closure} of \texttt{B} under \texttt{f} is the smallest set
containing \texttt{B} that is closed under \texttt{f}. That is, it is
the smallest element of
\texttt{\{\ D\ :\ Set\ A\ \textbar{}\ B\ ⊆\ D\ ∧\ closed\ f\ D\ \}},
where we use the subset partial ordering on \texttt{Set\ A} to determine
which element is smallest. We will write \texttt{closure\ f\ B\ C} to
mean that the closure of \texttt{B} under \texttt{f} is \texttt{C}. We
can define this as follows:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ closure \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A) (B C : Set A) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  smallestElt (sub A) C \{ D : Set A | B ⊆ D ∧ closed f D \}}
\end{Highlighting}
\end{Shaded}

We know that smallest elements, when they exist, are unique, so it makes
sense to talk about \emph{the} closure of \texttt{B} under \texttt{f}.
But not every set has a smallest element. Does every set have a closure?
Theorem 5.4.5 in \emph{HTPI} says that the answer is yes. The idea
behind the proof is that, for any family of sets \texttt{F}, if
\texttt{F} has a smallest element under the subset partial order, then
that smallest element is equal to \texttt{⋂₀\ F}. (We'll ask you to
prove this in the exercises.)

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_5\_4\_5 \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A) (B : Set A) :}
\NormalTok{    ∃ (C : Set A), closure f B C := }\KeywordTok{by}
  \KeywordTok{set}\NormalTok{ F : Set (Set A) := \{ D : Set A | B ⊆ D ∧ closed f D \}}
  \KeywordTok{set}\NormalTok{ C : Set A := ⋂₀ F}
  \KeywordTok{apply}\NormalTok{ Exists.intro C    }\CommentTok{{-}{-}Goal : closure f B C}
  \KeywordTok{define}                  \CommentTok{{-}{-}Goal : C ∈ F ∧ ∀ x ∈ F, C ⊆ x}
  \KeywordTok{apply}\NormalTok{ And.intro}
\NormalTok{  · }\CommentTok{{-}{-} Proof that C ∈ F}
    \KeywordTok{define}                  \CommentTok{{-}{-}Goal : B ⊆ C ∧ closed f C}
    \KeywordTok{apply}\NormalTok{ And.intro}
\NormalTok{    · }\CommentTok{{-}{-} Proof that B ⊆ C}
      \KeywordTok{fix}\NormalTok{ a : A}
      \KeywordTok{assume}\NormalTok{ h1 : a ∈ B       }\CommentTok{{-}{-}Goal : a ∈ C}
      \KeywordTok{define}                  \CommentTok{{-}{-}Goal : ∀ t ∈ F, a ∈ t}
      \KeywordTok{fix}\NormalTok{ D : Set A}
      \KeywordTok{assume}\NormalTok{ h2 : D ∈ F}
      \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2            }\CommentTok{{-}{-}h2 : B ⊆ D ∧ closed f D}
      \KeywordTok{show}\NormalTok{ a ∈ D }\KeywordTok{from}\NormalTok{ h2.left h1}
      \KeywordTok{done}
\NormalTok{    · }\CommentTok{{-}{-} Proof that C is closed under f}
      \KeywordTok{define}                  \CommentTok{{-}{-}Goal : ∀ x ∈ C, f x ∈ C}
      \KeywordTok{fix}\NormalTok{ a : A}
      \KeywordTok{assume}\NormalTok{ h1 : a ∈ C       }\CommentTok{{-}{-}Goal : f a ∈ C}
      \KeywordTok{define}                  \CommentTok{{-}{-}Goal : ∀ t ∈ F, f a ∈ t}
      \KeywordTok{fix}\NormalTok{ D : Set A}
      \KeywordTok{assume}\NormalTok{ h2 : D ∈ F       }\CommentTok{{-}{-}Goal : f a ∈ D}
      \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1            }\CommentTok{{-}{-}h1 : ∀ t ∈ F, a ∈ t}
      \KeywordTok{have}\NormalTok{ h3 : a ∈ D := h1 D h2}
      \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2            }\CommentTok{{-}{-}h2 : B ⊆ D ∧ closed f D}
      \KeywordTok{have}\NormalTok{ h4 : closed f D := h2.right}
      \KeywordTok{define} \KeywordTok{at}\NormalTok{ h4            }\CommentTok{{-}{-}h4 : ∀ x ∈ D, f x ∈ D}
      \KeywordTok{show}\NormalTok{ f a ∈ D }\KeywordTok{from}\NormalTok{ h4 a h3}
      \KeywordTok{done}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Proof that C is smallest}
    \KeywordTok{fix}\NormalTok{ D : Set A}
    \KeywordTok{assume}\NormalTok{ h1 : D ∈ F      }\CommentTok{{-}{-}Goal : sub A C D}
    \KeywordTok{define}
    \KeywordTok{fix}\NormalTok{ a : A}
    \KeywordTok{assume}\NormalTok{ h2 : a ∈ C       }\CommentTok{{-}{-}Goal : a ∈ D}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2            }\CommentTok{{-}{-}h2 : ∀ t ∈ F, a ∈ t}
    \KeywordTok{show}\NormalTok{ a ∈ D }\KeywordTok{from}\NormalTok{ h2 D h1}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

The idea of the closure of a set under a function can also be applied to
functions of two variables. One way to represent a function of two
variables on a type \texttt{A} would be to use a function \texttt{g} of
type \texttt{(A\ ×\ A)\ →\ A}. If \texttt{a} and \texttt{b} have type
\texttt{A}, then \texttt{(a,\ b)} has type \texttt{A\ ×\ A}, and the
result of applying the function \texttt{g} to the pair of values
\texttt{a} and \texttt{b} would be written \texttt{g\ (a,\ b)}.

However, there is another way to represent a function of two variables
that turns out to be more convenient in Lean. Suppose \texttt{f} has
type \texttt{A\ →\ A\ →\ A}. As with the arrow used in conditional
propositions, the arrow for function types groups to the right, so
\texttt{A\ →\ A\ →\ A} means \texttt{A\ →\ (A\ →\ A)}. Thus, if
\texttt{a} has type \texttt{A}, then \texttt{f\ a} has type
\texttt{A\ →\ A}. In other words, \texttt{f\ a} is a function from
\texttt{A} to \texttt{A}, and therefore if \texttt{b} has type
\texttt{A} then \texttt{f\ a\ b} has type \texttt{A}. The upshot is that
if \texttt{f} is followed by two objects of type \texttt{A}, then the
resulting expression has type \texttt{A}, so \texttt{f} can be thought
of as a function that applies to a pair of objects of type \texttt{A}
and gives a value of type \texttt{A}.

For example, we can think of addition of integers as a function of two
variables. Here are three ways to define this function in Lean.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ plus (m n : Int) : Int := m + n}

\KeywordTok{def}\NormalTok{ plus\textquotesingle{} : Int → Int → Int := fun (m n : Int) =\textgreater{} m + n}

\KeywordTok{def}\NormalTok{ plus\textquotesingle{}\textquotesingle{} : Int → Int → Int := fun (m : Int) =\textgreater{} (fun (n : Int) =\textgreater{} m + n)}
\end{Highlighting}
\end{Shaded}

The third definition matches the description above most closely:
\texttt{plus\textquotesingle{}\textquotesingle{}} is a function that,
when applied to an integer \texttt{m}, produces a new function
\texttt{plus\textquotesingle{}\textquotesingle{}\ m\ :\ Int\ →\ Int}.
The function \texttt{plus\textquotesingle{}\textquotesingle{}\ m} is
defined to be the function that, when applied to an integer \texttt{n},
produces the value \texttt{m\ +\ n}. In other words,
\texttt{plus\textquotesingle{}\textquotesingle{}\ m\ n\ =\ m\ +\ n}. The
first two definitions are more convenient ways of defining exactly the
same function. Let's have Lean confirm this, and try out the function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ : plus = plus\textquotesingle{}\textquotesingle{} := }\KeywordTok{by} \KeywordTok{rfl}

\KeywordTok{example}\NormalTok{ : plus\textquotesingle{} = plus\textquotesingle{}\textquotesingle{} := }\KeywordTok{by} \KeywordTok{rfl}

\SpecialCharTok{++}\DocumentationTok{\#eval}\SpecialCharTok{::}\NormalTok{ plus 3 2     }\CommentTok{{-}{-}Answer: 5}
\end{Highlighting}
\end{Shaded}

There are two reasons why this way of representing functions of two
variables in Lean is more convenient. First, it saves us the trouble of
grouping the arguments of the function together into an ordered pair
before applying the function. If we have \texttt{f\ :\ A\ →\ A\ →\ A}
and \texttt{a\ b\ :\ A}, then to apply the function \texttt{f} to the
arguments \texttt{a} and \texttt{b} we can just write \texttt{f\ a\ b}.
Second, it allows for the possibility of ``partially applying'' the
function \texttt{f}. The expression \texttt{f\ a} is meaningful, and
denotes the function that, when applied to any \texttt{b\ :\ A},
produces the result \texttt{f\ a\ b}. For example, if \texttt{m} is an
integer, then \texttt{plus\ m} denotes the function that, when applied
to an integer \texttt{n}, produces the result \texttt{m\ +\ n}. We might
call \texttt{plus\ m} the ``add to \texttt{m}'' function.

We have actually been using these ideas for a long time. In Chapter 3,
we introduced the type \texttt{Pred\ U} of predicates applying to
objects of type \texttt{U}, but we did not explain how such predicates
are represented internally in Lean. In fact, \texttt{Pred\ U} is defined
to be the type \texttt{U\ →\ Prop}, so if \texttt{P} has type
\texttt{Pred\ U}, then \texttt{P} is a function from \texttt{U} to
\texttt{Prop}, and if \texttt{x} has type \texttt{U}, then the
proposition \texttt{P\ x} is the result of applying the function
\texttt{P} to \texttt{x}. Similarly, \texttt{Rel\ A\ B} stands for
\texttt{A\ →\ B\ →\ Prop}, so if \texttt{R} has type \texttt{Rel\ A\ B},
then \texttt{R} is a function of two variables, one of type \texttt{A}
and one of type \texttt{B}. Earlier in this section, we defined
\texttt{closed\ f\ C} to be the proposition asserting that \texttt{C} is
closed under \texttt{f}. This means that \texttt{closed} is a function
of two variables, the first a function \texttt{f} of type
\texttt{A\ →\ A} and the second a set \texttt{C} of type \texttt{Set\ A}
(where the type \texttt{A} is an implicit argument of \texttt{closed}).
But that means that the partial application \texttt{closed\ f} denotes a
function from \texttt{Set\ A} to \texttt{Prop}. In other words,
\texttt{closed\ f} is a predicate applying to sets of type
\texttt{Set\ A}; we could think of it as the ``is closed under
\texttt{f}'' predicate. Similarly, in Section 4.4 we defined
\texttt{sub} to be a function of three variables: if \texttt{A} is a
type and \texttt{X} and \texttt{Y} have type \texttt{Set\ A}, then
\texttt{sub\ A\ X\ Y} is the proposition \texttt{X\ ⊆\ Y}. Since then,
we have used the partial application \texttt{sub\ A}, which is the
subset relation on \texttt{Set\ A}. For example, we used it earlier in
this section in the definition of \texttt{closure}.

Returning to the subject of closures, here's how we can extend the idea
of closures to functions of two variables:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ closed2 \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A → A) (C : Set A) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  ∀ x ∈ C, ∀ y ∈ C, f x y ∈ C}

\KeywordTok{def}\NormalTok{ closure2 \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A → A) (B C : Set A) : }\KeywordTok{Prop}\NormalTok{ := }
\NormalTok{  smallestElt (sub A) C \{ D : Set A | B ⊆ D ∧ closed2 f D \}}
\end{Highlighting}
\end{Shaded}

We will leave it as an exercise for you to prove that closures under
functions of two variables also exist.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_5\_4\_9 \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A → A) (B : Set A) :}
\NormalTok{    ∃ (C : Set A), closure2 f B C := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-13}{%
\subsection{Exercises}\label{exercises-13}}

\begin{numex}{1}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ \{A : }\KeywordTok{Type}\NormalTok{\} (F : Set (Set A)) (B : Set A) :}
\NormalTok{    smallestElt (sub A) B F → B = ⋂₀ F := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

2. If \texttt{B} has type \texttt{Set\ A}, then \texttt{complement\ B}
is the set \texttt{\{\ a\ :\ A\ \textbar{}\ a\ ∉\ B\ \}}. Thus, for any
\texttt{a} of type \texttt{A}, \texttt{a\ ∈\ complement\ B} if and only
if \texttt{a\ ∉\ B}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ complement \{A : }\KeywordTok{Type}\NormalTok{\} (B : Set A) : Set A := \{ a : A | a ∉ B \}}
\end{Highlighting}
\end{Shaded}

Use this definition to prove the following theorem:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_4\_7 \{A : }\KeywordTok{Type}\NormalTok{\} (f g : A → A) (C : Set A)}
\NormalTok{    (h1 : f ∘ g = id) (h2 : closed f C) : closed g (complement C) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\begin{numex}{3}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_4\_9a \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A) (C1 C2 : Set A)}
\NormalTok{    (h1 : closed f C1) (h2 : closed f C2) : closed f (C1 ∪ C2) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{4}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_4\_10a \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A) (B1 B2 C1 C2 : Set A)}
\NormalTok{    (h1 : closure f B1 C1) (h2 : closure f B2 C2) :}
\NormalTok{    B1 ⊆ B2 → C1 ⊆ C2 := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{5}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_4\_10b \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A) (B1 B2 C1 C2 : Set A)}
\NormalTok{    (h1 : closure f B1 C1) (h2 : closure f B2 C2) :}
\NormalTok{    closure f (B1 ∪ B2) (C1 ∪ C2) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{6}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_5\_4\_9 \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A → A) (B : Set A) :}
\NormalTok{    ∃ (C : Set A), closure2 f B C := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

7. Suppose we define a set to be closed under a family of functions if
it is closed under all of the functions in the family. Of course, the
closure of a set \texttt{B} under a family of functions is the smallest
set containing \texttt{B} that is closed under the family.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ closed\_family \{A : }\KeywordTok{Type}\NormalTok{\} (F : Set (A → A)) (C : Set A) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  ∀ f ∈ F, closed f C}

\KeywordTok{def}\NormalTok{ closure\_family \{A : }\KeywordTok{Type}\NormalTok{\} (F : Set (A → A)) (B C : Set A) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  smallestElt (sub A) C \{ D : Set A | B ⊆ D ∧ closed\_family F D \}}
\end{Highlighting}
\end{Shaded}

Prove that the closure of a set under a family of functions always
exists:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_5\_4\_13a \{A : }\KeywordTok{Type}\NormalTok{\} (F : Set (A → A)) (B : Set A) :}
\NormalTok{    ∃ (C : Set A), closure\_family F B C := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\hypertarget{images-and-inverse-images-a-research-project}{%
\section{5.5. Images and Inverse Images: A Research
Project}\label{images-and-inverse-images-a-research-project}}

Section 5.5 of \emph{HTPI} introduces two new definitions (\emph{HTPI}
p.~268). Suppose \(f : A \to B\). If \(X \subseteq A\), then the
\emph{image} of \(X\) under \(f\) is the set \(f(X)\) defined as
follows: \[
f(X) = \{f(x) \mid x \in X\} = \{b \in B \mid \exists x \in X(f(x) = b)\}.
\] If \(Y \subseteq B\), then the \emph{inverse image} of \(Y\) under
\(f\) is the set \(f^{-1}(Y)\) defined as follows: \[
f^{-1}(Y) = \{a \in A \mid f(a) \in Y\}.
\]

Here are definitions of these concepts in Lean:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ image \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (X : Set A) : Set B :=}
\NormalTok{  \{ f x | x ∈ X \}}

\KeywordTok{def}\NormalTok{ inverse\_image \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (Y : Set B) : Set A :=}
\NormalTok{  \{ a : A | f a ∈ Y \}}

\CommentTok{{-}{-}The following theorems illustrate the meaning of these definitions:}
\KeywordTok{theorem}\NormalTok{ image\_def \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (X : Set A) (b : B) :}
\NormalTok{    b ∈ image f X ↔ ∃ x ∈ X, f x = b := }\KeywordTok{by} \KeywordTok{rfl}

\KeywordTok{theorem}\NormalTok{ inverse\_image\_def \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (Y : Set B) (a : A) :}
\NormalTok{    a ∈ inverse\_image f Y ↔ f a ∈ Y := }\KeywordTok{by} \KeywordTok{rfl}
\end{Highlighting}
\end{Shaded}

It is natural to wonder how these concepts interact with familiar
operations on sets. \emph{HTPI} gives an example of such an interaction
in Theorem 5.5.2. The theorem makes two assertions. Here are proofs of
the two parts of the theorem in Lean.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_5\_5\_2\_1 \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (W X : Set A) :}
\NormalTok{    image f (W ∩ X) ⊆ image f W ∩ image f X := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ y : B}
  \KeywordTok{assume}\NormalTok{ h1 : y ∈ image f (W ∩ X)  }\CommentTok{{-}{-}Goal : y ∈ image f W ∩ image f X}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1                     }\CommentTok{{-}{-}h1 : ∃ (x : A), x ∈ W ∩ X ∧ f x = y}
  \KeywordTok{obtain}\NormalTok{ (x : A) (h2 : x ∈ W ∩ X ∧ f x = y) }\KeywordTok{from}\NormalTok{ h1}
  \KeywordTok{define}\NormalTok{ : x ∈ W ∩ X }\KeywordTok{at}\NormalTok{ h2         }\CommentTok{{-}{-}h2 : (x ∈ W ∧ x ∈ X) ∧ f x = y}
  \KeywordTok{apply}\NormalTok{ And.intro}
\NormalTok{  · }\CommentTok{{-}{-} Proof that y ∈ image f W}
    \KeywordTok{define}                         \CommentTok{{-}{-}Goal : ∃ (x : A), x ∈ W ∧ f x = y}
    \KeywordTok{show}\NormalTok{ ∃ (x : A), x ∈ W ∧ f x = y }\KeywordTok{from}
\NormalTok{      Exists.intro x (And.intro h2.left.left h2.right)}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Proof that y ∈ image f X}
    \KeywordTok{show}\NormalTok{ y ∈ image f X }\KeywordTok{from}
\NormalTok{      Exists.intro x (And.intro h2.left.right h2.right)}
    \KeywordTok{done}
  \KeywordTok{done}

\KeywordTok{theorem}\NormalTok{ Theorem\_5\_5\_2\_2 \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (W X : Set A)}
\NormalTok{    (h1 : one\_to\_one f) : image f (W ∩ X) = image f W ∩ image f X := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ Set.ext}
  \KeywordTok{fix}\NormalTok{ y : B      }\CommentTok{{-}{-}Goal : y ∈ image f (W ∩ X) ↔ y ∈ image f W ∩ image f X}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-} (→)}
    \KeywordTok{assume}\NormalTok{ h2 : y ∈ image f (W ∩ X)}
    \KeywordTok{show}\NormalTok{ y ∈ image f W ∩ image f X }\KeywordTok{from}\NormalTok{ Theorem\_5\_5\_2\_1 f W X h2}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} (←)}
    \KeywordTok{assume}\NormalTok{ h2 : y ∈ image f W ∩ image f X  }\CommentTok{{-}{-}Goal : y ∈ image f (W ∩ X)}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2                  }\CommentTok{{-}{-}h2 : y ∈ image f W ∧ y ∈ image f X}
    \KeywordTok{rewrite}\NormalTok{ [image\_def, image\_def] }\KeywordTok{at}\NormalTok{ h2}
          \CommentTok{{-}{-}h2 : (∃ (x : A), x ∈ W ∧ f x = y) ∧ ∃ (x : A), x ∈ X ∧ f x = y}
    \KeywordTok{obtain}\NormalTok{ (x1 : A) (h3 : x1 ∈ W ∧ f x1 = y) }\KeywordTok{from}\NormalTok{ h2.left}
    \KeywordTok{obtain}\NormalTok{ (x2 : A) (h4 : x2 ∈ X ∧ f x2 = y) }\KeywordTok{from}\NormalTok{ h2.right}
    \KeywordTok{have}\NormalTok{ h5 : f x2 = y := h4.right}
    \KeywordTok{rewrite}\NormalTok{ [←h3.right] }\KeywordTok{at}\NormalTok{ h5  }\CommentTok{{-}{-}h5 : f x2 = f x1}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1               }\CommentTok{{-}{-}h1 : ∀ (x1 x2 : A), f x1 = f x2 → x1 = x2}
    \KeywordTok{have}\NormalTok{ h6 : x2 = x1 := h1 x2 x1 h5}
    \KeywordTok{rewrite}\NormalTok{ [h6] }\KeywordTok{at}\NormalTok{ h4           }\CommentTok{{-}{-}h4 : x1 ∈ X ∧ f x1 = y}
    \KeywordTok{show}\NormalTok{ y ∈ image f (W ∩ X) }\KeywordTok{from}
\NormalTok{      Exists.intro x1 (And.intro (And.intro h3.left h4.left) h3.right)}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

The rest of Section 5.5 of \emph{HTPI} consists of statements for you to
try to prove. Here are the statements, written as examples in Lean. Some
are correct and some are not; some can be made correct by adding
additional hypotheses or weakening the conclusion. Prove as much as you
can.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-}Warning!  Not all of these examples are correct!}

\KeywordTok{example}\NormalTok{ \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (W X : Set A) :}
\NormalTok{    image f (W ∪ X) = image f W ∪ image f X := }\ConstantTok{sorry}

\KeywordTok{example}\NormalTok{ \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (W X : Set A) :}
\NormalTok{    image f (W \textbackslash{} X) = image f W \textbackslash{} image f X := }\ConstantTok{sorry}

\KeywordTok{example}\NormalTok{ \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (W X : Set A) :}
\NormalTok{    W ⊆ X ↔ image f W ⊆ image f X := }\ConstantTok{sorry}

\KeywordTok{example}\NormalTok{ \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (Y Z : Set B) :}
\NormalTok{    inverse\_image f  (Y ∩ Z) =}
\NormalTok{        inverse\_image f Y ∩ inverse\_image f Z := }\ConstantTok{sorry}

\KeywordTok{example}\NormalTok{ \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (Y Z : Set B) :}
\NormalTok{    inverse\_image f  (Y ∪ Z) =}
\NormalTok{        inverse\_image f Y ∪ inverse\_image f Z := }\ConstantTok{sorry}

\KeywordTok{example}\NormalTok{ \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (Y Z : Set B) :}
\NormalTok{    inverse\_image f  (Y \textbackslash{} Z) =}
\NormalTok{        inverse\_image f Y \textbackslash{} inverse\_image f Z := }\ConstantTok{sorry}

\KeywordTok{example}\NormalTok{ \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (Y Z : Set B) :}
\NormalTok{    Y ⊆ Z ↔ inverse\_image f Y ⊆ inverse\_image f Z := }\ConstantTok{sorry}

\KeywordTok{example}\NormalTok{ \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (X : Set A) :}
\NormalTok{    inverse\_image f (image f X) = X := }\ConstantTok{sorry}

\KeywordTok{example}\NormalTok{ \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (Y : Set B) :}
\NormalTok{    image f (inverse\_image f Y) = Y := }\ConstantTok{sorry}

\KeywordTok{example}\NormalTok{ \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A) (C : Set A) :}
\NormalTok{    closed f C → image f C ⊆ C := }\ConstantTok{sorry}

\KeywordTok{example}\NormalTok{ \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A) (C : Set A) :}
\NormalTok{    image f C ⊆ C → C ⊆ inverse\_image f C := }\ConstantTok{sorry}

\KeywordTok{example}\NormalTok{ \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A) (C : Set A) :}
\NormalTok{    C ⊆ inverse\_image f C → closed f C := }\ConstantTok{sorry}

\KeywordTok{example}\NormalTok{ \{A B : }\KeywordTok{Type}\NormalTok{\} (f : A → B) (g : B → A) (Y : Set B)}
\NormalTok{    (h1 : f ∘ g = id) (h2 : g ∘ f = id) :}
\NormalTok{    inverse\_image f Y = image g Y := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\bookmarksetup{startatroot}

\hypertarget{additional-space}{%
\chapter{Additional space}\label{additional-space}}

\hypertarget{proof-by-mathematical-induction}{%
\section{6.1. Proof by Mathematical
Induction}\label{proof-by-mathematical-induction}}

Section 6.1 of \emph{HTPI} introduces a new proof technique called
\emph{mathematical induction}. It is used for proving statements of the
form \texttt{∀\ (n\ :\ Nat),\ P\ n}. Here is how it works (\emph{HTPI}
p.~273):

\hypertarget{to-prove-a-goal-of-the-form-n-nat-p-n}{%
\subsubsection{\texorpdfstring{To prove a goal of the form
\texttt{∀\ (n\ :\ Nat),\ P\ n}:}{To prove a goal of the form ∀ (n : Nat), P n:}}\label{to-prove-a-goal-of-the-form-n-nat-p-n}}

\begin{ind}
First prove \texttt{P\ 0}, and then prove
\texttt{∀\ (n\ :\ Nat),\ P\ n\ →\ P\ (n\ +\ 1)}. The first of these
proofs is sometimes called the \emph{base case} and the second the
\emph{induction step}.

\end{ind}

For an explanation of why this strategy works to establish the truth of
\texttt{∀\ (n\ :\ Nat),\ P\ n}, see \emph{HTPI}. Here we focus on using
mathematical induction in Lean.

To use mathematical induction in a Lean proof, we will use the tactic
\texttt{by\_induc}. If the goal has the form
\texttt{∀\ (n\ :\ Nat),\ P\ n}, then the \texttt{by\_induc} tactic
leaves the list of givens unchanged, but it replaces the goal with the
goals for the base case and induction step. Thus, the effect of the
tactic can be summarized as follows:

\begin{bef}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{ ⋮}
\NormalTok{⊢ ∀ (n : Nat), P n}
\end{Highlighting}
\end{Shaded}

\end{bef}

\begin{aft}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ Base\_Case}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{ ⋮}
\NormalTok{⊢ P 0}
\RegionMarkerTok{case}\NormalTok{ Induction\_Step}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{ ⋮}
\NormalTok{⊢ ∀ (n : Nat), P n → P (n + 1)}
\end{Highlighting}
\end{Shaded}

\end{aft}

To illustrate proof by mathematical induction in Lean, we turn first to
Example 6.1.2 in \emph{HTPI}, which gives a proof of the statement
\(\forall n \in \mathbb{N} (3 \mid (n^3 - n))\). For reasons that we
will explain a little later, we will prove a slightly different theorem:
\(\forall n \in \mathbb{N} (3 \mid (n^3 + 2n))\). Here is a proof of the
theorem, modeled on the proof in Example 6.1.2 of \emph{HTPI}
(\emph{HTPI} pp.~276--277).

\begin{thm}
For every natural number \(n\), \(3 \mid (n^3 + 2n)\).

\end{thm}

\begin{proof}

We use mathematical induction.

Base Case: If \(n = 0\), then \(n^3 + 2n = 0 = 3 \cdot 0\), so
\(3 \mid (n^3 + 2n)\).

Induction Step: Let \(n\) be an arbitrary natural number and suppose
\(3 \mid (n^3 + 2n)\). Then we can choose an integer \(k\) such that
\(3k = n^3 + 2n\). Thus, \begin{align*}
(n+1)^3 + 2(n+1) &= n^3 + 3n^2 + 3n + 1 + 2n + 2\\
&= (n^3 + 2n) + 3n^2 + 3n + 3\\
&= 3k + 3n^2 + 3n + 3\\
&= 3(k + n^2 + n + 1).
\end{align*} Therefore \(3 \mid ((n+1)^3 + 2(n+1))\), as required.
\excl{~□}\qedhere

\end{proof}

Now let's try writing the same proof in Lean. We start, of course, with
the \texttt{by\_induc} tactic.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Like\_Example\_6\_1\_2 :}
\NormalTok{    ∀ (n : Nat), 3 ∣ n \^{} 3 + 2 * n := }\KeywordTok{by}
  \KeywordTok{by\_induc}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ Base\_Case}
\NormalTok{⊢ 3 ∣ 0 \^{} 3 + 2 * 0}
\RegionMarkerTok{case}\NormalTok{ Induction\_Step}
\NormalTok{⊢ ∀ (n : ℕ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  3 ∣ n \^{} 3 + 2 * n →}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  3 ∣ (n + 1) \^{} 3 +}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{      2 * (n + 1)}
\end{Highlighting}
\end{Shaded}

\end{outpt}

The base case is easy: The \texttt{define} tactic tells us that the goal
means \texttt{∃\ (c\ :\ Nat),\ 0\ \^{}\ 3\ +\ 2\ *\ 0\ =\ 3\ *\ c}, and
then \texttt{apply\ Exists.intro\ 0} changes the goal to
\texttt{0\ \^{}\ 3\ +\ 2\ *\ 0\ =\ 3\ *\ 0}. Both sides are
definitionally equal to \texttt{0}, so \texttt{rfl} finishes off the
base case. For the induction step, we begin, as in the \emph{HTPI}
proof, by introducing an arbitrary natural number \texttt{n} and
assuming \texttt{3\ ∣\ n\ \^{}\ 3\ +\ 2\ *\ n}. This assumption is
called the \emph{inductive hypothesis}, so in the Lean proof we give it
the identifier \texttt{ih}. Our goal now is to prove
\texttt{3\ ∣\ (n\ +\ 1)\ \^{}\ 3\ +\ 2\ *\ (n\ +\ 1)}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Like\_Example\_6\_1\_2 :}
\NormalTok{    ∀ (n : Nat), 3 ∣ n \^{} 3 + 2 * n := }\KeywordTok{by}
  \KeywordTok{by\_induc}
\NormalTok{  · }\CommentTok{{-}{-} Base Case}
    \KeywordTok{define}
    \KeywordTok{apply}\NormalTok{ Exists.intro 0}
    \KeywordTok{rfl}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Induction Step}
    \KeywordTok{fix}\NormalTok{ n : Nat}
    \KeywordTok{assume}\NormalTok{ ih : 3 ∣ n \^{} 3 + 2 * n}
    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ Induction\_Step}
\InformationTok{n }\NormalTok{: ℕ}
\InformationTok{ih }\NormalTok{: 3 ∣ n \^{} 3 + 2 * n}
\NormalTok{⊢ 3 ∣ (n + 1) \^{} 3 +}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{      2 * (n + 1)}
\end{Highlighting}
\end{Shaded}

\end{outpt}

The rest of the Lean proof follows the model of the \emph{HTPI} proof:
we use the inductive hypothesis to introduce a \texttt{k} such that
\texttt{n\ \^{}\ 3\ +\ 2\ *\ n\ =\ 3\ *\ k}, and then we use a
calculational proof to show that
\texttt{(n\ +\ 1)\ \^{}\ 3\ +\ 2\ *\ (n\ +\ 1)\ =\ 3\ *\ (k\ +\ n\ \^{}\ 2\ +\ n\ +\ 1)}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Like\_Example\_6\_1\_2 :}
\NormalTok{    ∀ (n : Nat), 3 ∣ n \^{} 3 + 2 * n := }\KeywordTok{by}
  \KeywordTok{by\_induc}
\NormalTok{  · }\CommentTok{{-}{-} Base Case}
    \KeywordTok{define}         \CommentTok{{-}{-}Goal : ∃ (c : Nat), 0 \^{} 3 + 2 * 0 = 3 * c}
    \KeywordTok{apply}\NormalTok{ Exists.intro 0}
    \KeywordTok{rfl}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Induction Step}
    \KeywordTok{fix}\NormalTok{ n : Nat}
    \KeywordTok{assume}\NormalTok{ ih : 3 ∣ n \^{} 3 + 2 * n}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ ih   }\CommentTok{{-}{-}ih : ∃ (c : Nat), n \^{} 3 + 2 * n = 3 * c}
    \KeywordTok{obtain}\NormalTok{ (k : Nat) (h1 : n \^{} 3 + 2 * n = 3 * k) }\KeywordTok{from}\NormalTok{ ih}
    \KeywordTok{define}         \CommentTok{{-}{-}Goal : ∃ (c : Nat), (n + 1) \^{} 3 + 2 * (n + 1) = 3 * c}
    \KeywordTok{apply}\NormalTok{ Exists.intro (k + n \^{} 2 + n + 1)}
    \KeywordTok{show}\NormalTok{ (n + 1) \^{} 3 + 2 * (n + 1) = 3 * (k + n \^{} 2 + n + 1) }\KeywordTok{from}
      \KeywordTok{calc}\NormalTok{ (n + 1) \^{} 3 + 2 * (n + 1)}
\NormalTok{        \_ = n \^{} 3 + 2 * n + 3 * n \^{} 2 + 3 * n + 3 := }\KeywordTok{by} \KeywordTok{ring}
\NormalTok{        \_ = 3 * k + 3 * n \^{} 2 + 3 * n + 3 := }\KeywordTok{by} \KeywordTok{rw}\NormalTok{ [h1]}
\NormalTok{        \_ = 3 * (k + n \^{} 2 + n + 1) := }\KeywordTok{by} \KeywordTok{ring}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

Next we'll look at Example 6.1.1 in \emph{HTPI}, which proves that for
every natural number \(n\), \(2^0 + 2^1 + \cdots + 2^n = 2^{n+1} - 1\).
Once again, we will change the theorem slightly before proving it in
Lean. What we will prove is that for every \(n\),
\((2^0 + 2^1 + \cdots + 2^n) + 1 = 2^{n+1}\). To understand this theorem
you must be able to recognize what the ``\(\cdots\)'' stands for. A
human reader will probably realize that the numbers being added up here
are the numbers of the form \(2^i\), where \(i\) runs through all of the
natural numbers from 0 to \(n\). But Lean can't be expected to figure
out this pattern, so we must be more explicit.

Section 6.3 of \emph{HTPI} introduces the explicit notation that
mathematicians usually use for such sums. If \(f\) is a function whose
domain is the natural numbers, then \[
\sum_{i=0}^n f(i) = f(0) + f(1) + \cdots + f(n).
\] More generally, if \(k \le n\) then \[
\sum_{i=k}^n f(i) = f(k) + f(k+1) + \cdots + f(n).
\]

The notation we will use in Lean for this sum is
\texttt{Sum\ i\ from\ k\ to\ n,\ f\ i}. Thus, a mathematician would
state our theorem like this:

\begin{thm}
For every natural number \(n\), \[
\left(\sum_{i=0}^n 2^i\right) + 1 = 2^{n+1}.
\]

\end{thm}

And to state the same theorem in Lean, we will write:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Like\_Example\_6\_1\_1 :}
\NormalTok{    ∀ (n : Nat), (}\KeywordTok{Sum}\NormalTok{ i }\KeywordTok{from}\NormalTok{ 0 }\KeywordTok{to}\NormalTok{ n, 2 \^{} i) + 1 = 2 \^{} (n + 1)}
\end{Highlighting}
\end{Shaded}

We will have more to say later about how the notation
\texttt{Sum\ i\ from\ k\ to\ n,\ f\ i} is defined. But to use the
notation in a proof, we will just need to know a few theorems. The
\texttt{\#check} command will tell us the meanings of the theorems
\texttt{sum\_base}, \texttt{sum\_step}, and
\texttt{sum\_from\_zero\_step}:

\begin{ind}

\begin{verbatim}
@sum_base : ∀ {A : Type} [inst : AddZeroClass A] {k : ℕ} {f : ℕ → A},
            Sum i from k to k, f i = f k

@sum_step : ∀ {A : Type} [inst : AddZeroClass A] {k n : ℕ} {f : ℕ → A},
            k ≤ n → Sum i from k to n + 1, f i =
              (Sum i from k to n, f i) + f (n + 1)

@sum_from_zero_step :
            ∀ {A : Type} [inst : AddZeroClass A] {n : ℕ} {f : ℕ → A},
            Sum i from 0 to n + 1, f i =
              (Sum i from 0 to n, f i) + f (n + 1)
\end{verbatim}

\end{ind}

As usual, we don't need to pay too much attention to the implicit
arguments in the first line of each statement. What is important is that
\texttt{sum\_base} can be used to prove any statement of the form

\begin{ind}

\begin{verbatim}
Sum i from k to k, f i = f k
\end{verbatim}

\end{ind}

and \texttt{sum\_step} proves any statement of the form

\begin{ind}

\begin{verbatim}
k ≤ n → Sum i from k to n + 1, f i = (Sum i from k to n, f i) + f (n + 1).
\end{verbatim}

\end{ind}

In the case \texttt{k\ =\ 0}, we have the simpler theorem
\texttt{sum\_from\_zero\_step}, which proves

\begin{ind}

\begin{verbatim}
Sum i from 0 to n + 1, f i = (Sum i from 0 to n, f i) + f (n + 1).
\end{verbatim}

\end{ind}

With that preparation, we can start on the proof. Once again we begin
with the \texttt{by\_induc} tactic. Our goal for the base case is
\texttt{(Sum\ i\ from\ 0\ to\ 0,\ 2\ \^{}\ i)\ +\ 1\ =\ 2\ \^{}\ (0\ +\ 1)}.
To deal with the term \texttt{Sum\ i\ from\ 0\ to\ 0,\ 2\ \^{}\ i}, we
use that fact that \texttt{sum\_base} proves
\texttt{Sum\ i\ from\ 0\ to\ 0,\ 2\ \^{}\ i\ =\ 2\ \^{}\ 0}. It follows
that the tactic \texttt{rewrite\ {[}sum\_base{]}} will change the goal
to \texttt{2\ \^{}\ 0\ +\ 1\ =\ 2\ \^{}\ (0\ +\ 1)}. Of course, this
means \texttt{2\ =\ 2}, so \texttt{rfl} finishes the base case. For the
induction step, we start by introducing an arbitrary natural number
\texttt{n} and assuming the inductive hypothesis.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Like\_Example\_6\_1\_1 :}
\NormalTok{    ∀ (n : Nat), (}\KeywordTok{Sum}\NormalTok{ i }\KeywordTok{from}\NormalTok{ 0 }\KeywordTok{to}\NormalTok{ n, 2 \^{} i) + 1 = 2 \^{} (n + 1) := }\KeywordTok{by}
  \KeywordTok{by\_induc}
\NormalTok{  · }\CommentTok{{-}{-} Base Case}
    \KeywordTok{rewrite}\NormalTok{ [sum\_base]}
    \KeywordTok{rfl}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Induction Step}
    \KeywordTok{fix}\NormalTok{ n : Nat}
    \KeywordTok{assume}\NormalTok{ ih : (}\KeywordTok{Sum}\NormalTok{ i }\KeywordTok{from}\NormalTok{ 0 }\KeywordTok{to}\NormalTok{ n, 2 \^{} i) + 1 = 2 \^{} (n + 1)}
    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

Our goal is now
\texttt{(Sum\ i\ from\ 0\ to\ n\ +\ 1,\ 2\ \^{}\ i)\ +\ 1\ =\ 2\ \^{}\ (n\ +\ 1\ +\ 1)},
and we use a calculational proof to prove this. Often the key to the
proof of the induction step is to find a relationship between the
inductive hypothesis and the goal. In this case, that means finding a
relationship between \texttt{Sum\ i\ from\ 0\ to\ n,\ 2\ \^{}\ i} and
\texttt{Sum\ i\ from\ 0\ to\ n\ +\ 1,\ 2\ \^{}\ i}. The relationship we
need is given by the theorem \texttt{sum\_from\_zero\_step}. The tactic
\texttt{rewrite\ {[}sum\_from\_zero\_step{]}} will replace
\texttt{Sum\ i\ from\ 0\ to\ n\ +\ 1,\ 2\ \^{}\ i} with
\texttt{(Sum\ i\ from\ 0\ to\ n,\ 2\ \^{}\ i)\ +\ 2\ \^{}\ (n\ +\ 1)}.
The rest of the calculation proof involves straightforward algebra,
handled by the \texttt{ring} tactic, together with an application of the
inductive hypothesis.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Like\_Example\_6\_1\_1 :}
\NormalTok{    ∀ (n : Nat), (}\KeywordTok{Sum}\NormalTok{ i }\KeywordTok{from}\NormalTok{ 0 }\KeywordTok{to}\NormalTok{ n, 2 \^{} i) + 1 = 2 \^{} (n + 1) := }\KeywordTok{by}
  \KeywordTok{by\_induc}
\NormalTok{  · }\CommentTok{{-}{-} Base Case}
    \KeywordTok{rewrite}\NormalTok{ [sum\_base]}
    \KeywordTok{rfl}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Induction Step}
    \KeywordTok{fix}\NormalTok{ n : Nat}
    \KeywordTok{assume}\NormalTok{ ih : (}\KeywordTok{Sum}\NormalTok{ i }\KeywordTok{from}\NormalTok{ 0 }\KeywordTok{to}\NormalTok{ n, 2 \^{} i) + 1 = 2 \^{} (n + 1)}
    \KeywordTok{show}\NormalTok{ (}\KeywordTok{Sum}\NormalTok{ i }\KeywordTok{from}\NormalTok{ 0 }\KeywordTok{to}\NormalTok{ n + 1, 2 \^{} i) + 1 = 2 \^{} (n + 1 + 1) }\KeywordTok{from}
      \KeywordTok{calc}\NormalTok{ (}\KeywordTok{Sum}\NormalTok{ i }\KeywordTok{from}\NormalTok{ 0 }\KeywordTok{to}\NormalTok{ n + 1, 2 \^{} i) + 1}
\NormalTok{        \_ = (}\KeywordTok{Sum}\NormalTok{ i }\KeywordTok{from}\NormalTok{ 0 }\KeywordTok{to}\NormalTok{ n, 2 \^{} i) + 2 \^{} (n + 1) + 1 := }\KeywordTok{by}
              \KeywordTok{rw}\NormalTok{ [sum\_from\_zero\_step]}
\NormalTok{        \_ = (}\KeywordTok{Sum}\NormalTok{ i }\KeywordTok{from}\NormalTok{ 0 }\KeywordTok{to}\NormalTok{ n, 2 \^{} i) + 1 + 2 \^{} (n + 1) := }\KeywordTok{by} \KeywordTok{ring}
\NormalTok{        \_ = 2 \^{} (n + 1) + 2 \^{} (n + 1) := }\KeywordTok{by} \KeywordTok{rw}\NormalTok{ [ih]}
\NormalTok{        \_ = 2 \^{} (n + 1 + 1) := }\KeywordTok{by} \KeywordTok{ring}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

The last example in Section 6.1 of \emph{HTPI} gives a proof of the
statement \(\forall n \ge 5 (2^n > n^2)\). The proof is by mathematical
induction, but since we are only interested in natural numbers greater
than or equal to 5, it uses 5 in the base case instead of 0. Here are
the theorem and proof from \emph{HTPI} (\emph{HTPI} p.~278):

\begin{thm}
For every natural number \(n \ge 5\), \(2^n > n^2\).

\end{thm}

\begin{proof}

By mathematical induction.

Base case: When \(n = 5\) we have \(2^n = 32 > 25 = n^2\).

Induction step: Let \(n \ge 5\) be arbitrary, and suppose that
\(2^n > n^2\). Then \begin{align*}
2^{n+1} &= 2 \cdot 2^n\\
&> 2n^2 &&\text{(inductive hypothesis)}\\
&= n^2 + n^2\\
&\ge n^2 + 5n &&\text{(since $n \ge 5$)}\\
&= n^2 + 2n + 3n\\
&> n^2 + 2n + 1 = (n+1)^2. &&\Box
\end{align*} \renewcommand{\qed}{}

\end{proof}

Notice that the sequence of calculations at the end of the proof mixes
\(=\), \(>\), and \(\ge\) in a way that establishes the final conclusion
\(2^{n+1} > (n+1)^2\). As we'll see, such a mixture is allowed in
calculational proofs in Lean as well.

To write this proof in Lean, there is no need to specify that the base
case should be \texttt{n\ =\ 5}; the \texttt{by\_induc} tactic is smart
enough to figure that out on its own, as you can see in the tactic state
below. (Notice that, as in \emph{HTPI}, in Lean we can write
\texttt{∀\ n\ ≥\ k,\ P\ n} as an abbreviation for
\texttt{∀\ (n\ :\ Nat),\ n\ ≥\ k\ →\ P\ n}.)

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_6\_1\_3 :}
\NormalTok{    ∀ n ≥ 5, 2 \^{} n \textgreater{} n \^{} 2 := }\KeywordTok{by}
  \KeywordTok{by\_induc}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ Base\_Case}
\NormalTok{⊢ 2 \^{} 5 \textgreater{} 5 \^{} 2}
\RegionMarkerTok{case}\NormalTok{ Induction\_Step}
\NormalTok{⊢ ∀ (n : ℕ), n ≥ 5 →}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  2 \^{} n \textgreater{} n \^{} 2 →}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  2 \^{} (n + 1) \textgreater{}}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{      (n + 1) \^{} 2}
\end{Highlighting}
\end{Shaded}

\end{outpt}

To complete this proof we'll use two tactics we haven't used before:
\texttt{norm\_num} and \texttt{linarith}. The base case can be proven by
simply doing the arithmetic necessary to check that the inequality holds
when \texttt{n\ =\ 5}. The tactic \texttt{norm\_num} does such numerical
calculations, and it proves the base case.

For the induction step, we introduce an arbitrary natural number
\texttt{n}, assume \texttt{n\ ≥\ 5}, and assume the inductive
hypothesis, \texttt{2\ \^{}\ n\ \textgreater{}\ n\ \^{}\ 2}. Then we use
a calculational proof to imitate the reasoning at the end of the
\emph{HTPI} proof. The tactic \texttt{linarith} makes inferences that
involve combining linear equations and inequalities. It is able to prove
almost all of the inequalities in the calculational proof. The exception
is \texttt{n\ *\ n\ ≥\ 5\ *\ n} (which is not linear because of the term
\texttt{n\ *\ n}). So we prove that inequality separately, using a
theorem from Lean's library, \texttt{Nat.mul\_le\_mul\_right}. The
command \texttt{\#check\ @Nat.mul\_le\_mul\_right} tells us the meaning
of that theorem:

\begin{ind}

\begin{verbatim}
@Nat.mul_le_mul_right : ∀ {n m : ℕ} (k : ℕ), n ≤ m → n * k ≤ m * k
\end{verbatim}

\end{ind}

Thus, \texttt{Nat.mul\_le\_mul\_right\ n} can be used to prove the
statement \texttt{5\ ≤\ n\ →\ 5\ *\ n\ ≤\ n\ *\ n}. Lean recognizes
\texttt{x\ ≥\ y} as meaning the same thing as \texttt{y\ ≤\ x}, so we
can apply this statement to our assumption \texttt{n\ ≥\ 5} to prove
that \texttt{n\ *\ n\ ≥\ 5\ *\ n}. Once we have proven that inequality,
the \texttt{linarith} tactic can use it to complete the required
inequality reasoning.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_6\_1\_3 : ∀ n ≥ 5, 2 \^{} n \textgreater{} n \^{} 2 := }\KeywordTok{by}
  \KeywordTok{by\_induc}
\NormalTok{  · }\CommentTok{{-}{-} Base Case}
    \KeywordTok{norm\_num}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Induction Step}
    \KeywordTok{fix}\NormalTok{ n : Nat}
    \KeywordTok{assume}\NormalTok{ h1 : n ≥ 5}
    \KeywordTok{assume}\NormalTok{ ih : 2 \^{} n \textgreater{} n \^{} 2}
    \KeywordTok{have}\NormalTok{ h2 : n * n ≥ 5 * n := Nat.mul\_le\_mul\_right n h1}
    \KeywordTok{show}\NormalTok{ 2 \^{} (n + 1) \textgreater{} (n + 1) \^{} 2 }\KeywordTok{from}
      \KeywordTok{calc}\NormalTok{ 2 \^{} (n + 1)}
\NormalTok{        \_ = 2 * 2 \^{} n := }\KeywordTok{by} \KeywordTok{ring}
\NormalTok{        \_ \textgreater{} 2 * n \^{} 2 := }\KeywordTok{by} \KeywordTok{linarith}
\NormalTok{        \_ ≥ n \^{} 2 + 5 * n := }\KeywordTok{by} \KeywordTok{linarith}
\NormalTok{        \_ \textgreater{} n \^{} 2 + 2 * n + 1 := }\KeywordTok{by} \KeywordTok{linarith}
\NormalTok{        \_ = (n + 1) \^{} 2 := }\KeywordTok{by} \KeywordTok{ring}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

Finally, we turn to the question of why we made small changes in two of
the examples from \emph{HTPI}. Perhaps you have guessed by now that we
were trying to avoid the use of subtraction. All of the numbers in the
examples in this section were natural numbers, and subtraction of
natural numbers is problematic. In the natural numbers, \texttt{3\ -\ 2}
is equal to \texttt{1}, but what is \texttt{2\ -\ 3}? Lean's answer is
\texttt{0}.

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{++}\DocumentationTok{\#eval}\SpecialCharTok{::}\NormalTok{ 2 {-} 3     }\CommentTok{{-}{-}Answer: 0}
\end{Highlighting}
\end{Shaded}

In Lean, if \texttt{a} and \texttt{b} are natural numbers and
\texttt{a\ \textless{}\ b}, then \texttt{a\ -\ b} is defined to be
\texttt{0}. As a result, the algebraic laws of natural number
subtraction are complicated. For example,
\texttt{2\ -\ 3\ +\ 1\ =\ 0\ +\ 1\ =\ 1}, but
\texttt{2\ +\ 1\ -\ 3\ =\ 3\ -\ 3\ =\ 0}, so it is not true that for all
natural numbers \texttt{a}, \texttt{b}, and \texttt{c},
\texttt{a\ -\ b\ +\ c\ =\ a\ +\ c\ -\ b}.

If you thought that the answer to the subtraction problem
\texttt{2\ -\ 3} was \texttt{-1}, then you automatically switched from
the natural numbers to the integers. (Recall that the natural numbers
are the numbers 0, 1, 2, \ldots, while the integers are the numbers
\ldots, --3, --2, --1, 0, 1, 2, 3, \ldots.) To a human mathematician,
this is a perfectly natural thing to do: the natural numbers are a
subset of the integers, so \texttt{2} and \texttt{3} are not only
natural numbers but also integers, and we can compute \texttt{2\ -\ 3}
in the integers.

However, that's not how things work in Lean. In Lean, different types
are completely separate. In particular, \texttt{Nat} and \texttt{Int}
are separate types, and therefore the natural numbers are not a subset
of the integers. Of course, there is an integer 2, but it is different
from the natural number 2. By default, Lean assumes that \texttt{2}
denotes the natural number 2, but you can specify that you want the
integer 2 by writing \texttt{(2\ :\ Int)}. Subtraction of integers in
Lean is the subtraction you are familiar with, and it has all the
algebraic properties you would expect. If we want to use subtraction in
the theorems in this section, we are better off using familiar integer
subtraction rather than funky natural number subtraction.

To prove the theorem in Example 6.1.1 as it appears in \emph{HTPI}, we
could state the theorem like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_6\_1\_1 :}
\NormalTok{    ∀ (n : Nat), }\KeywordTok{Sum}\NormalTok{ i }\KeywordTok{from}\NormalTok{ 0 }\KeywordTok{to}\NormalTok{ n, (2 : Int) \^{} i =}
\NormalTok{    (2 : Int) \^{} (n + 1) {-} (1 : Int)}
\end{Highlighting}
\end{Shaded}

The expression \texttt{Sum\ i\ from\ 0\ to\ n,\ (2\ :\ Int)\ \^{}\ i}
denotes a sum of integers, so it is an integer. Similarly, the right
side of the equation is an integer, and the equation asserts the
equality of two integers. The subtraction on the right side of the
equation is integer subtraction, so we can use the usual algebraic laws
to reason about it. In fact, the proof of the theorem in this form is
not hard:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_6\_1\_1 :}
\NormalTok{    ∀ (n : Nat), }\KeywordTok{Sum}\NormalTok{ i }\KeywordTok{from}\NormalTok{ 0 }\KeywordTok{to}\NormalTok{ n, (2 : Int) \^{} i =}
\NormalTok{    (2 : Int) \^{} (n + 1) {-} (1 : Int) := }\KeywordTok{by}
  \KeywordTok{by\_induc}
\NormalTok{  · }\CommentTok{{-}{-} Base Case}
    \KeywordTok{rewrite}\NormalTok{ [sum\_base]}
    \KeywordTok{rfl}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Induction Step}
    \KeywordTok{fix}\NormalTok{ n : Nat}
    \KeywordTok{assume}\NormalTok{ ih : }\KeywordTok{Sum}\NormalTok{ i }\KeywordTok{from}\NormalTok{ 0 }\KeywordTok{to}\NormalTok{ n, (2 : Int) \^{} i =}
\NormalTok{        (2 : Int) \^{} (n + 1) {-} (1 : Int)}
    \KeywordTok{show} \KeywordTok{Sum}\NormalTok{ i }\KeywordTok{from}\NormalTok{ 0 }\KeywordTok{to}\NormalTok{ n + 1, (2 : Int) \^{} i =}
\NormalTok{        (2 : Int) \^{} (n + 1 + 1) {-} (1 : Int) }\KeywordTok{from}
      \KeywordTok{calc} \KeywordTok{Sum}\NormalTok{ i }\KeywordTok{from}\NormalTok{ 0 }\KeywordTok{to}\NormalTok{ n + 1, (2 : Int) \^{} i}
\NormalTok{        \_ = (}\KeywordTok{Sum}\NormalTok{ i }\KeywordTok{from}\NormalTok{ 0 }\KeywordTok{to}\NormalTok{ n, (2 : Int) \^{} i)}
\NormalTok{            + (2 : Int) \^{} (n + 1) := }\KeywordTok{by} \KeywordTok{rw}\NormalTok{ [sum\_from\_zero\_step]}
\NormalTok{        \_ = (2 : Int) \^{} (n + 1) {-} (1 : Int)}
\NormalTok{            + (2 : Int) \^{} (n + 1) := }\KeywordTok{by} \KeywordTok{rw}\NormalTok{ [ih]}
\NormalTok{        \_ = (2 : Int) \^{} (n + 1 + 1) {-} (1 : Int) := }\KeywordTok{by} \KeywordTok{ring}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

If you change \texttt{(2\ :\ Int)} and \texttt{(1\ :\ Int)} to
\texttt{2} and \texttt{1}, then the right side of the equation will be a
difference of two natural numbers, and Lean will interpret the
subtraction as natural number subtraction. The proof won't work because
the \texttt{ring} tactic is not able to deal with the peculiar algebraic
properties of natural number subtraction. (The theorem is still true,
but the proof is harder.)

\hypertarget{exercises-14}{%
\subsection{Exercises}\label{exercises-14}}

\begin{numex}{1}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Like\_Exercise\_6\_1\_1 :}
\NormalTok{    ∀ (n : Nat), 2 * }\KeywordTok{Sum}\NormalTok{ i }\KeywordTok{from}\NormalTok{ 0 }\KeywordTok{to}\NormalTok{ n, i = n * (n + 1) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{2}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Like\_Exercise\_6\_1\_4 :}
\NormalTok{    ∀ (n : Nat), }\KeywordTok{Sum}\NormalTok{ i }\KeywordTok{from}\NormalTok{ 0 }\KeywordTok{to}\NormalTok{ n, 2 * i + 1 = (n + 1) \^{} 2 := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{3}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_6\_1\_9a : ∀ (n : Nat), 2 ∣ n \^{} 2 + n := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{4}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_6\_1\_13 :}
\NormalTok{    ∀ (a b : Int) (n : Nat), (a {-} b) ∣ (a \^{} n {-} b \^{} n) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{5}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_6\_1\_15 : ∀ n ≥ 10, 2 \^{} n \textgreater{} n \^{} 3 := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{6}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ nonzero\_is successor :}
\NormalTok{    ∀ (n : Nat), n ≠ 0 → ∃ (m : Nat), n = m + 1 := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

For the next two exercises you will need the following definitions:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ nat\_even (n : Nat) : }\KeywordTok{Prop}\NormalTok{ := ∃ (k : Nat), n = 2 * k}

\KeywordTok{def}\NormalTok{ nat\_odd (n : Nat) : }\KeywordTok{Prop}\NormalTok{ := ∃ (k : Nat), n = 2 * k + 1}
\end{Highlighting}
\end{Shaded}

\begin{numex}{7}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_6\_1\_16a1 :}
\NormalTok{    ∀ (n : Nat), nat\_even n ∨ nat\_odd n := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{8}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-}Hint:  You may find the lemma nonzero\_is\_successor}
\CommentTok{{-}{-}from a previous exercise useful, as well as Nat.add\_right\_cancel.}
\KeywordTok{theorem}\NormalTok{ Exercise\_6\_1\_16a2 :}
\NormalTok{    ∀ (n : Nat), ¬(nat\_even n ∧ nat\_odd n) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\hypertarget{more-examples}{%
\section{6.2. More Examples}\label{more-examples}}

We saw in the last section that mathematical induction can be used to
prove theorems about calculations involving natural numbers. But
mathematical induction has a much wider range of uses. Section 6.2 of
\emph{HTPI} illustrates this by proving two theorems about finite sets.

How can mathematical induction be used to prove a statement about finite
sets? To say that a set is finite means that it has \(n\) elements, for
some natural number \(n\). Thus, to say that all finite sets have some
property, we can say that for every natural number \(n\), every set with
\(n\) elements has the property. Since this statement starts with ``for
every natural number \(n\),'' we can use mathematical induction to try
to prove it.

What does it mean to say that a set ``has \(n\) elements''? Section 6.2
of \emph{HTPI} says that for the proofs in that section, ``an intuitive
understanding of this concept will suffice.'' Unfortunately, intuition
is not Lean's strong suit! So we'll need to be more explicit about how
to talk about finite sets in Lean.

In Chapter 8, we'll define \texttt{numElts\ A\ n} to be a proposition
saying that the set \texttt{A} has \texttt{n} elements, and we'll prove
several theorems involving that proposition. Those theorems make precise
and explicit the intuitive ideas that we'll need in this section. We'll
state those theorems here and use them in our proofs, but you'll have to
wait until Section 8.1½ to see how they are proven. Here are the
theorems we'll need:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ zero\_elts\_iff\_empty \{U : }\KeywordTok{Type}\NormalTok{\} (A : Set U) :}
\NormalTok{    numElts A 0 ↔ empty A}

\KeywordTok{theorem}\NormalTok{ one\_elt\_iff\_singleton \{U : }\KeywordTok{Type}\NormalTok{\} (A : Set U) :}
\NormalTok{    numElts A 1 ↔ ∃ (x : U), A = \{x\}}

\KeywordTok{theorem}\NormalTok{ nonempty\_of\_pos\_numElts \{U : }\KeywordTok{Type}\NormalTok{\} \{A : Set U\} \{n : Nat\}}
\NormalTok{    (h1 : numElts A n) (h2 : n \textgreater{} 0) : ∃ (x : U), x ∈ A}

\KeywordTok{theorem}\NormalTok{ remove\_one\_numElts \{U : }\KeywordTok{Type}\NormalTok{\} \{A : Set U\} \{n : Nat\} \{a : U\}}
\NormalTok{    (h1 : numElts A (n + 1)) (h2 : a ∈ A) : numElts (A \textbackslash{} \{a\}) n}
\end{Highlighting}
\end{Shaded}

These theorems should make intuitive sense. The first says that a set
has zero elements if and only if it is empty, and the second says that a
set has one element if and only if it is a singleton set. The third
theorem says that if a set has a positive number of elements, then there
is something in the set. And the fourth says that if a set has \(n + 1\)
elements and you remove one element, then the resulting set has \(n\)
elements. You can probably guess that we'll be using the last theorem in
the induction steps of our proofs.

Our first theorem about finite sets says that if \(R\) is a partial
order on \(A\), then every finite, nonempty subset of \(A\) has an
\(R\)-minimal element. (This is not true in general for infinite subsets
of \(A\). Can you think of an example of an infinite subset of a
partially ordered set that has no minimal element?) To say that a set is
finite and nonempty we can say that it has \(n\) elements for some
\(n \ge 1\). So here's how we state our theorem in Lean:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_6\_2\_1 \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (h : partial\_order R) :}
\NormalTok{    ∀ n ≥ 1, ∀ (B : Set A), numElts B n →}
\NormalTok{      ∃ (x : A), minimalElt R x B}
\end{Highlighting}
\end{Shaded}

When we use mathematical induction to prove this theorem, the base case
will be \texttt{n\ =\ 1}. To write the proof for the base case, we start
by assuming \texttt{B} is a set with one element. We can then use the
theorem \texttt{one\_elt\_iff\_singleton} to conclude that
\texttt{B\ =\ \{b\}}, for some \texttt{b} of type \texttt{A}. We need to
prove that \texttt{B} has a minimal element, and the only possibility
for the minimal element is \texttt{b}. Verifying that
\texttt{minimalElt\ R\ b\ B} is straightforward. Here is the proof of
the base case:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_6\_2\_1 \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (h : partial\_order R) :}
\NormalTok{    ∀ n ≥ 1, ∀ (B : Set A), numElts B n →}
\NormalTok{      ∃ (x : A), minimalElt R x B := }\KeywordTok{by}
  \KeywordTok{by\_induc}
\NormalTok{  · }\CommentTok{{-}{-} Base Case}
    \KeywordTok{fix}\NormalTok{ B : Set A}
    \KeywordTok{assume}\NormalTok{ h2 : numElts B 1}
    \KeywordTok{rewrite}\NormalTok{ [one\_elt\_iff\_singleton] }\KeywordTok{at}\NormalTok{ h2}
    \KeywordTok{obtain}\NormalTok{ (b : A) (h3 : B = \{b\}) }\KeywordTok{from}\NormalTok{ h2}
    \KeywordTok{apply}\NormalTok{ Exists.intro b}
    \KeywordTok{define}         \CommentTok{{-}{-}Goal : b ∈ B ∧ ¬∃ (x : A), x ∈ B ∧ R x b ∧ x ≠ b}
    \KeywordTok{apply}\NormalTok{ And.intro}
\NormalTok{    · }\CommentTok{{-}{-} Proof that b ∈ B}
      \KeywordTok{rewrite}\NormalTok{ [h3]    }\CommentTok{{-}{-}Goal : b ∈ \{b\}}
      \KeywordTok{define}          \CommentTok{{-}{-}Goal : b = b}
      \KeywordTok{rfl}
      \KeywordTok{done}
\NormalTok{    · }\CommentTok{{-}{-} Proof that nothing in B is smaller than b}
      \KeywordTok{by\_contra}\NormalTok{ h4}
      \KeywordTok{obtain}\NormalTok{ (x : A) (h5 : x ∈ B ∧ R x b ∧ x ≠ b) }\KeywordTok{from}\NormalTok{ h4}
      \KeywordTok{have}\NormalTok{ h6 : x ∈ B := h5.left}
      \KeywordTok{rewrite}\NormalTok{ [h3] }\KeywordTok{at}\NormalTok{ h6   }\CommentTok{{-}{-}h6 : x ∈ \{b\}}
      \KeywordTok{define} \KeywordTok{at}\NormalTok{ h6         }\CommentTok{{-}{-}h6 : x = b}
      \KeywordTok{show}\NormalTok{ False }\KeywordTok{from}\NormalTok{ h5.right.right h6}
      \KeywordTok{done}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Induction Step}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

Notice that since the definition of \texttt{minimalElt\ R\ b\ B}
involves a negative statement, we found it convenient to use proof by
contradiction to prove it.

For the induction step, we assume that \texttt{n\ ≥\ 1} and that every
set with \texttt{n} elements has an \texttt{R}-minimal element. We must
prove that every set with \texttt{n\ +\ 1} elements has a minimal
element, so we let \texttt{B} be an arbitrary set with \texttt{n\ +\ 1}
elements. To apply the inductive hypothesis, we need a set with
\texttt{n} elements. So we pick some \texttt{b\ ∈\ B} (using the theorem
\texttt{nonempty\_of\_pos\_numElts}) and then remove it from \texttt{B}
to get the set
\texttt{B\textquotesingle{}\ =\ B\ \textbackslash{}\ \{b\}}. The theorem
\texttt{remove\_one\_numElts} tells us that \texttt{B\textquotesingle{}}
has \texttt{n} elements, so by the inductive hypothesis, we can then let
\texttt{c} be a minimal element of \texttt{B\textquotesingle{}}. We now
know about two elements of \texttt{B}: \texttt{b} and \texttt{c}. Which
will be a minimal element of \texttt{B}? As explained in \emph{HTPI}, it
depends on whether or not \texttt{R\ b\ c}. We'll prove that if
\texttt{R\ b\ c}, then \texttt{b} is a minimal element of \texttt{B},
and if not, then \texttt{c} is a minimal element. It will be convenient
to prove these last two facts separately as lemmas. The first lemma says
that in the situation at this point in the proof, if \texttt{R\ b\ c},
then \texttt{b} is an \texttt{R}-minimal element of \texttt{B}. Here is
the proof.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ Lemma\_6\_2\_1\_1 \{A : }\KeywordTok{Type}\NormalTok{\} \{R : BinRel A\} \{B : Set A\} \{b c : A\}}
\NormalTok{    (h1 : partial\_order R) (h2 : b ∈ B) (h3 : minimalElt R c (B \textbackslash{} \{b\}))}
\NormalTok{    (h4 : R b c) : minimalElt R b B := }\KeywordTok{by}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h3}
    \CommentTok{{-}{-}h3 : c ∈ B \textbackslash{} \{b\} ∧ ¬∃ (x : A), x ∈ B \textbackslash{} \{b\} ∧ R x c ∧ x ≠ c}
  \KeywordTok{define}  \CommentTok{{-}{-}Goal : b ∈ B ∧ ¬∃ (x : A), x ∈ B ∧ R x b ∧ x ≠ b}
  \KeywordTok{apply}\NormalTok{ And.intro h2    }\CommentTok{{-}{-}Goal : ¬∃ (x : A), x ∈ B ∧ R x b ∧ x ≠ b}
  \KeywordTok{contradict}\NormalTok{ h3.right }\KeywordTok{with}\NormalTok{ h5}
  \KeywordTok{obtain}\NormalTok{ (x : A) (h6 : x ∈ B ∧ R x b ∧ x ≠ b) }\KeywordTok{from}\NormalTok{ h5}
  \KeywordTok{apply}\NormalTok{ Exists.intro x  }\CommentTok{{-}{-}Goal : x ∈ B \textbackslash{} \{b\} ∧ R x c ∧ x ≠ c}
  \KeywordTok{apply}\NormalTok{ And.intro}
\NormalTok{  · }\CommentTok{{-}{-} Proof that x ∈ B \textbackslash{} \{b\}}
    \KeywordTok{show}\NormalTok{ x ∈ B \textbackslash{} \{b\} }\KeywordTok{from}\NormalTok{ And.intro h6.left h6.right.right}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Proof that R x c ∧ x ≠ c}
    \KeywordTok{have}\NormalTok{ Rtrans : transitive R := h1.right.left}
    \KeywordTok{have}\NormalTok{ h7 : R x c := Rtrans x b c h6.right.left h4}
    \KeywordTok{apply}\NormalTok{ And.intro h7}
    \KeywordTok{by\_contra}\NormalTok{ h8}
    \KeywordTok{rewrite}\NormalTok{ [h8] }\KeywordTok{at}\NormalTok{ h6  }\CommentTok{{-}{-}h6 : c ∈ B ∧ R c b ∧ c ≠ b}
    \KeywordTok{have}\NormalTok{ Rantisymm : antisymmetric R := h1.right.right}
    \KeywordTok{have}\NormalTok{ h9 : c = b := Rantisymm c b h6.right.left h4}
    \KeywordTok{show}\NormalTok{ False }\KeywordTok{from}\NormalTok{ h6.right.right h9}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

The second lemma says that if \texttt{¬R\ b\ c}, then \texttt{c} is an
\texttt{R}-minimal element of \texttt{B}. We'll leave the proof as an
exercise for you:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ Lemma\_6\_2\_1\_2 \{A : }\KeywordTok{Type}\NormalTok{\} \{R : BinRel A\} \{B : Set A\} \{b c : A\}}
\NormalTok{    (h1 : partial\_order R) (h2 : b ∈ B) (h3 : minimalElt R c (B \textbackslash{} \{b\}))}
\NormalTok{    (h4 : ¬R b c) : minimalElt R c B := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

With this preparation, we are finally ready to give the proof of the
induction step of \texttt{Example\_6\_2\_1}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_6\_2\_1 \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (h : partial\_order R) :}
\NormalTok{    ∀ n ≥ 1, ∀ (B : Set A), numElts B n →}
\NormalTok{      ∃ (x : A), minimalElt R x B := }\KeywordTok{by}
  \KeywordTok{by\_induc}
\NormalTok{  · }\CommentTok{{-}{-} Base Case}
\NormalTok{    ...}
\NormalTok{  · }\CommentTok{{-}{-} Induction Step}
    \KeywordTok{fix}\NormalTok{ n : Nat}
    \KeywordTok{assume}\NormalTok{ h2 : n ≥ 1}
    \KeywordTok{assume}\NormalTok{ ih : ∀ (B : Set A), numElts B n → ∃ (x : A), minimalElt R x B}
    \KeywordTok{fix}\NormalTok{ B : Set A}
    \KeywordTok{assume}\NormalTok{ h3 : numElts B (n + 1)}
    \KeywordTok{have}\NormalTok{ h4 : n + 1 \textgreater{} 0 := }\KeywordTok{by} \KeywordTok{linarith}
    \KeywordTok{obtain}\NormalTok{ (b : A) (h5 : b ∈ B) }\KeywordTok{from}\NormalTok{ nonempty\_of\_pos\_numElts h3 h4}
    \KeywordTok{set}\NormalTok{ B\textquotesingle{} : Set A := B \textbackslash{} \{b\}}
    \KeywordTok{have}\NormalTok{ h6 : numElts B\textquotesingle{} n := remove\_one\_numElts h3 h5}
    \KeywordTok{obtain}\NormalTok{ (c : A) (h7 : minimalElt R c B\textquotesingle{}) }\KeywordTok{from}\NormalTok{ ih B\textquotesingle{} h6}
    \KeywordTok{by\_cases}\NormalTok{ h8 : R b c}
\NormalTok{    · }\CommentTok{{-}{-} Case 1. h8 : R b c}
      \KeywordTok{have}\NormalTok{ h9 : minimalElt R b B := Lemma\_6\_2\_1\_1 h h5 h7 h8}
      \KeywordTok{show}\NormalTok{ ∃ (x : A), minimalElt R x B }\KeywordTok{from}\NormalTok{ Exists.intro b h9}
      \KeywordTok{done}
\NormalTok{    · }\CommentTok{{-}{-} Case 2. h8 : ¬R b c}
      \KeywordTok{have}\NormalTok{ h9 : minimalElt R c B := Lemma\_6\_2\_1\_2 h h5 h7 h8}
      \KeywordTok{show}\NormalTok{ ∃ (x : A), minimalElt R x B }\KeywordTok{from}\NormalTok{ Exists.intro c h9}
      \KeywordTok{done}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

We'll consider one more theorem from Section 6.2 of \emph{HTPI}. Example
6.2.2 proves that a partial order on a finite set can always be extended
to a total order. Rather than give that proof, we are going to prove the
more general theorem that is stated in Exercise 2 in Section 6.2 of
\emph{HTPI}. To explain the theorem in that exercise, it will be helpful
to introduce a bit of terminology. Suppose \texttt{R} is a partial order
on \texttt{A} and \texttt{b} has type \texttt{A}. We will say that
\texttt{b} is \emph{\texttt{R}-comparable to everything} if
\texttt{∀\ (x\ :\ A),\ R\ b\ x\ ∨\ R\ x\ b}. If \texttt{B} is a set of
objects of type \texttt{A}, we say that \texttt{B} is
\emph{\texttt{R}-comparable to everything} if every element of
\texttt{B} is \texttt{R}-comparable to everything; that is, if
\texttt{∀\ b\ ∈\ B,\ ∀\ (x\ :\ A),\ R\ b\ x\ ∨\ R\ x\ b}. Finally, we
say that another binary relation \texttt{T} \emph{extends} \texttt{R} if
\texttt{∀\ (x\ y\ :\ A),\ R\ x\ y\ →\ T\ x\ y}. We are going to prove
that if \texttt{R} is a partial order on \texttt{A} and \texttt{B} is a
finite set of objects of type \texttt{A}, then there is a partial order
\texttt{T} that extends \texttt{R} such that \texttt{B} is
\texttt{T}-comparable to everything. In other words, we are going to
prove the following theorem:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_6\_2\_2 \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (h : partial\_order R) :}
\NormalTok{    ∀ (n : Nat) (B : Set A), numElts B n → ∃ (T : BinRel A),}
\NormalTok{    partial\_order T ∧ (∀ (x y : A), R x y → T x y) ∧}
\NormalTok{    ∀ x ∈ B, ∀ (y : A), T x y ∨ T y x}
\end{Highlighting}
\end{Shaded}

In the exercises, we will ask you to show that this implies the theorem
in Example 6.2.2.

It will be helpful to begin with a warm-up exercise. We'll show that a
partial order can always be extended to make a single object comparable
to everything. In other words, we'll show that if \texttt{R} is a
partial order on \texttt{A} and \texttt{b} has type \texttt{A}, then we
can define a partial order \texttt{T} extending \texttt{R} such that
\texttt{b} is \texttt{T}-comparable to everything. To define \texttt{T},
we will need to make sure that for every \texttt{x} of type \texttt{A},
either \texttt{T\ b\ x} or \texttt{T\ x\ b}. If \texttt{R\ x\ b}, then
since \texttt{T} must extend \texttt{R}, we must have \texttt{T\ x\ b}.
If \texttt{¬R\ x\ b}, then we will define \texttt{T} so that
\texttt{T\ b\ x}. But notice that if we follow this plan, then for any
\texttt{x} and \texttt{y}, if we have \texttt{R\ x\ b} and
\texttt{¬R\ y\ b}, then we will have \texttt{T\ x\ b} and
\texttt{T\ b\ y}, and since \texttt{T} must be transitive, we must then
have \texttt{T\ x\ y}. Summing up, if we have \texttt{R\ x\ y} then we
must have \texttt{T\ x\ y}, and if we have \texttt{R\ x\ b} and
\texttt{¬R\ y\ b} then we will also need to have \texttt{T\ x\ y}. So
let's try defining \texttt{T\ x\ y} to mean
\texttt{R\ x\ y\ ∨\ (R\ x\ b\ ∧\ ¬R\ y\ b)}.

It will be useful to have a name for this relation \texttt{T}. Since it
is an extension of \texttt{R} determined by the element \texttt{b}, we
will give it the name \texttt{extendPO\ R\ b}. Here is the definition of
this relation:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ extendPO \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (b : A) (x y : A) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  R x y ∨ (R x b ∧ ¬R y b)}
\end{Highlighting}
\end{Shaded}

We need to prove a number of things about \texttt{extendPO\ R\ b}. First
of all, we need to prove that it is a partial order. We'll leave most of
the details as exercises for you:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ extendPO\_is\_ref \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (b : A)}
\NormalTok{    (h : partial\_order R) : reflexive (extendPO R b) := }\ConstantTok{sorry}

\KeywordTok{lemma}\NormalTok{ extendPO\_is\_trans \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (b : A)}
\NormalTok{    (h : partial\_order R) : transitive (extendPO R b) := }\ConstantTok{sorry}

\KeywordTok{lemma}\NormalTok{ extendPO\_is\_antisymm \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (b : A)}
\NormalTok{    (h : partial\_order R) : antisymmetric (extendPO R b) := }\ConstantTok{sorry}

\KeywordTok{lemma}\NormalTok{ extendPO\_is\_po \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (b : A)}
\NormalTok{    (h : partial\_order R) : partial\_order (extendPO R b) := }
\NormalTok{  And.intro (extendPO\_is\_ref R b h)}
\NormalTok{    (And.intro (extendPO\_is\_trans R b h) (extendPO\_is\_antisymm R b h))}
\end{Highlighting}
\end{Shaded}

It is easy to prove that \texttt{extendPO\ R\ b} extends \texttt{R}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ extendPO\_extends \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (b : A) (x y : A) :}
\NormalTok{    R x y → extendPO R b x y := }\KeywordTok{by}
  \KeywordTok{assume}\NormalTok{ h1 : R x y}
  \KeywordTok{define}
  \KeywordTok{show}\NormalTok{ R x y ∨ R x b ∧ ¬R y b }\KeywordTok{from}\NormalTok{ Or.inl h1}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

Finally, we verify that \texttt{extendPO\ R\ b} does what it was
supposed to do: it makes \texttt{b} comparable with everything:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ extendPO\_all\_comp \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (b : A)}
\NormalTok{    (h : partial\_order R) :}
\NormalTok{    ∀ (x : A), extendPO R b b x ∨ extendPO R b x b := }\KeywordTok{by}
  \KeywordTok{have}\NormalTok{ Rref : reflexive R := h.left}
  \KeywordTok{fix}\NormalTok{ x : A}
  \KeywordTok{or\_left} \KeywordTok{with}\NormalTok{ h1}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1     }\CommentTok{{-}{-}h1 : ¬(R x b ∨ R x b ∧ ¬R b b)}
  \KeywordTok{demorgan} \KeywordTok{at}\NormalTok{ h1   }\CommentTok{{-}{-}h1 : ¬R x b ∧ ¬(R x b ∧ ¬R b b)}
  \KeywordTok{define}           \CommentTok{{-}{-}Goal : R b x ∨ R b b ∧ ¬R x b}
  \KeywordTok{apply}\NormalTok{ Or.inr}
  \KeywordTok{show}\NormalTok{ R b b ∧ ¬R x b }\KeywordTok{from}\NormalTok{ And.intro (Rref b) h1.left}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

With this preparation, we can finally return to our theorem
\texttt{Exercise\_6\_2\_2}. We will prove it by mathematical induction.
In the base case we must show that if \texttt{B} has 0 elements then we
can extend \texttt{R} to make everything in \texttt{B} comparable to
everything. Of course, no extension is necessary, since it is vacuously
true that all elements of \texttt{B} are \texttt{R}-comparable to
everything. For the induction step, after assuming the inductive
hypothesis, we must prove that if \texttt{B} has \texttt{n\ +\ 1}
elements then we can extend \texttt{R} to make all elements of
\texttt{B} comparable to everything. As before, we choose
\texttt{b\ ∈\ B} and let
\texttt{B\textquotesingle{}\ =\ B\ \textbackslash{}\ \{b\}}. By
inductive hypothesis, we can find an extension
\texttt{T\textquotesingle{}} of \texttt{R} that makes all elements of
\texttt{B\textquotesingle{}} comparable to everything, so we just have
to extend \texttt{T\textquotesingle{}} further to make \texttt{b}
comparable to everything. But as we have just seen, we can do this with
\texttt{extendPO\ T\textquotesingle{}\ b}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_6\_2\_2 \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (h : partial\_order R) :}
\NormalTok{    ∀ (n : Nat) (B : Set A), numElts B n → ∃ (T : BinRel A),}
\NormalTok{    partial\_order T ∧ (∀ (x y : A), R x y → T x y) ∧}
\NormalTok{    ∀ x ∈ B, ∀ (y : A), T x y ∨ T y x := }\KeywordTok{by}
  \KeywordTok{by\_induc}
\NormalTok{  · }\CommentTok{{-}{-} Base Case}
    \KeywordTok{fix}\NormalTok{ B : Set A}
    \KeywordTok{assume}\NormalTok{ h2 : numElts B 0}
    \KeywordTok{rewrite}\NormalTok{ [zero\_elts\_iff\_empty] }\KeywordTok{at}\NormalTok{ h2}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2     }\CommentTok{{-}{-}h2 : ¬∃ (x : A), x ∈ B}
    \KeywordTok{apply}\NormalTok{ Exists.intro R}
    \KeywordTok{apply}\NormalTok{ And.intro h}
    \KeywordTok{apply}\NormalTok{ And.intro}
\NormalTok{    · }\CommentTok{{-}{-} Proof that R extends R}
      \KeywordTok{fix}\NormalTok{ x : A; }\KeywordTok{fix}\NormalTok{ y : A}
      \KeywordTok{assume}\NormalTok{ h3 : R x y}
      \KeywordTok{show}\NormalTok{ R x y }\KeywordTok{from}\NormalTok{ h3}
      \KeywordTok{done}
\NormalTok{    · }\CommentTok{{-}{-} Proof that everything in B comparable to everything under R}
      \KeywordTok{fix}\NormalTok{ x : A}
      \KeywordTok{assume}\NormalTok{ h3 : x ∈ B}
      \KeywordTok{contradict}\NormalTok{ h2}
      \KeywordTok{show}\NormalTok{ ∃ (x : A), x ∈ B }\KeywordTok{from}\NormalTok{ Exists.intro x h3}
      \KeywordTok{done}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Induction Step}
    \KeywordTok{fix}\NormalTok{ n : Nat}
    \KeywordTok{assume}\NormalTok{ ih : ∀ (B : Set A), numElts B n → ∃ (T : BinRel A),}
\NormalTok{      partial\_order T ∧ (∀ (x y : A), R x y → T x y) ∧}
\NormalTok{      ∀ (x : A), x ∈ B → ∀ (y : A), T x y ∨ T y x}
    \KeywordTok{fix}\NormalTok{ B : Set A}
    \KeywordTok{assume}\NormalTok{ h2 : numElts B (n + 1)}
    \KeywordTok{have}\NormalTok{ h3 : n + 1 \textgreater{} 0 := }\KeywordTok{by} \KeywordTok{linarith}
    \KeywordTok{obtain}\NormalTok{ (b : A) (h4 : b ∈ B) }\KeywordTok{from}\NormalTok{ nonempty\_of\_pos\_numElts h2 h3}
    \KeywordTok{set}\NormalTok{ B\textquotesingle{} : Set A := B \textbackslash{} \{b\}}
    \KeywordTok{have}\NormalTok{ h5 : numElts B\textquotesingle{} n := remove\_one\_numElts h2 h4}
    \KeywordTok{have}\NormalTok{ h6 : ∃ (T : BinRel A), partial\_order T ∧}
\NormalTok{      (∀ (x y : A), R x y → T x y) ∧}
\NormalTok{      ∀ (x : A), x ∈ B\textquotesingle{} → ∀ (y : A), T x y ∨ T y x := ih B\textquotesingle{} h5}
    \KeywordTok{obtain}\NormalTok{ (T\textquotesingle{} : BinRel A)}
\NormalTok{      (h7 : partial\_order T\textquotesingle{} ∧ (∀ (x y : A), R x y → T\textquotesingle{} x y) ∧}
\NormalTok{      ∀ (x : A), x ∈ B\textquotesingle{} → ∀ (y : A), T\textquotesingle{} x y ∨ T\textquotesingle{} y x) }\KeywordTok{from}\NormalTok{ h6}
    \KeywordTok{have}\NormalTok{ T\textquotesingle{}po : partial\_order T\textquotesingle{} := h7.left}
    \KeywordTok{have}\NormalTok{ T\textquotesingle{}extR : ∀ (x y : A), R x y → T\textquotesingle{} x y := h7.right.left}
    \KeywordTok{have}\NormalTok{ T\textquotesingle{}compB\textquotesingle{} : ∀ (x : A), x ∈ B\textquotesingle{} →}
\NormalTok{      ∀ (y : A), T\textquotesingle{} x y ∨ T\textquotesingle{} y x := h7.right.right}
    \KeywordTok{set}\NormalTok{ T : BinRel A := extendPO T\textquotesingle{} b}
    \KeywordTok{apply}\NormalTok{ Exists.intro T}
    \KeywordTok{apply}\NormalTok{ And.intro (extendPO\_is\_po T\textquotesingle{} b T\textquotesingle{}po)}
    \KeywordTok{apply}\NormalTok{ And.intro}
\NormalTok{    · }\CommentTok{{-}{-} Proof that T extends R}
      \KeywordTok{fix}\NormalTok{ x : A; }\KeywordTok{fix}\NormalTok{ y : A}
      \KeywordTok{assume}\NormalTok{ h8 : R x y}
      \KeywordTok{have}\NormalTok{ h9 : T\textquotesingle{} x y := T\textquotesingle{}extR x y h8}
      \KeywordTok{show}\NormalTok{ T x y }\KeywordTok{from}\NormalTok{ (extendPO\_extends T\textquotesingle{} b x y h9)}
      \KeywordTok{done}
\NormalTok{    · }\CommentTok{{-}{-} Proof that everything in B comparable to everything under T}
      \KeywordTok{fix}\NormalTok{ x : A}
      \KeywordTok{assume}\NormalTok{ h8 : x ∈ B}
      \KeywordTok{by\_cases}\NormalTok{ h9 : x = b}
\NormalTok{      · }\CommentTok{{-}{-} Case 1. h9 : x = b}
        \KeywordTok{rewrite}\NormalTok{ [h9]}
        \KeywordTok{show}\NormalTok{ ∀ (y : A), T b y ∨ T y b }\KeywordTok{from}\NormalTok{ extendPO\_all\_comp T\textquotesingle{} b T\textquotesingle{}po}
        \KeywordTok{done}
\NormalTok{      · }\CommentTok{{-}{-} Case 2. h9 : x ≠ b}
        \KeywordTok{have}\NormalTok{ h10 : x ∈ B\textquotesingle{} := And.intro h8 h9}
        \KeywordTok{fix}\NormalTok{ y : A}
        \KeywordTok{have}\NormalTok{ h11 : T\textquotesingle{} x y ∨ T\textquotesingle{} y x := T\textquotesingle{}compB\textquotesingle{} x h10 y}
        \KeywordTok{by\_cases} \KeywordTok{on}\NormalTok{ h11}
\NormalTok{        · }\CommentTok{{-}{-} Case 2.1. h11 : T\textquotesingle{} x y}
          \KeywordTok{show}\NormalTok{ T x y ∨ T y x }\KeywordTok{from}
\NormalTok{            Or.inl (extendPO\_extends T\textquotesingle{} b x y h11)}
          \KeywordTok{done}
\NormalTok{        · }\CommentTok{{-}{-} Case 2.2. h11 : T\textquotesingle{} y x}
          \KeywordTok{show}\NormalTok{ T x y ∨ T y x }\KeywordTok{from}
\NormalTok{            Or.inr (extendPO\_extends T\textquotesingle{} b y x h11)}
          \KeywordTok{done}
        \KeywordTok{done}
      \KeywordTok{done}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-15}{%
\subsection{Exercises}\label{exercises-15}}

\begin{numex}{1}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ Lemma\_6\_2\_1\_2 \{A : }\KeywordTok{Type}\NormalTok{\} \{R : BinRel A\} \{B : Set A\} \{b c : A\}}
\NormalTok{    (h1 : partial\_order R) (h2 : b ∈ B) (h3 : minimalElt R c (B \textbackslash{} \{b\}))}
\NormalTok{    (h4 : ¬R b c) : minimalElt R c B := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{2}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ extendPO\_is\_ref \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (b : A)}
\NormalTok{    (h : partial\_order R) : reflexive (extendPO R b) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{3}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ extendPO\_is\_trans \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (b : A)}
\NormalTok{    (h : partial\_order R) : transitive (extendPO R b) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{4}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ extendPO\_is\_antisymm \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A) (b : A)}
\NormalTok{    (h : partial\_order R) : antisymmetric (extendPO R b) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{5}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_6\_2\_3 (A : }\KeywordTok{Type}\NormalTok{) (R : BinRel A)}
\NormalTok{    (h : total\_order R) : ∀ n ≥ 1, ∀ (B : Set A),}
\NormalTok{    numElts B n → ∃ (b : A), smallestElt R b B := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{6}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-}Hint:  First prove that R is reflexive.}
\KeywordTok{theorem}\NormalTok{ Exercise\_6\_2\_4a \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A)}
\NormalTok{    (h : ∀ (x y : A), R x y ∨ R y x) : ∀ n ≥ 1, ∀ (B : Set A),}
\NormalTok{    numElts B n → ∃ x ∈ B, ∀ y ∈ B, ∃ (z : A), R x z ∧ R z y := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{7}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Like\_Exercise\_6\_2\_16 \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A)}
\NormalTok{    (h : one\_to\_one f) : ∀ (n : Nat) (B : Set A), numElts B n →}
\NormalTok{    closed f B → ∀ y ∈ B, ∃ x ∈ B, f x = y := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{8}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-}Hint:  Use Exercise\_6\_2\_2.}
\KeywordTok{theorem}\NormalTok{ Example\_6\_2\_2 \{A : }\KeywordTok{Type}\NormalTok{\} (R : BinRel A)}
\NormalTok{    (h1 : ∃ (n : Nat), numElts \{ x : A | x = x \} n)}
\NormalTok{    (h2 : partial\_order R) : ∃ (T : BinRel A),}
\NormalTok{      total\_order T ∧ ∀ (x y : A), R x y → T x y := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\hypertarget{recursion}{%
\section{6.3. Recursion}\label{recursion}}

In the last two sections, we saw that we can prove that all natural
numbers have some property by proving that 0 has the property, and also
that for every natural number \(n\), if \(n\) has the property then so
does \(n + 1\). In this section we will see that a similar idea can be
used to define a function whose domain is the natural numbers. We can
define a function \(f\) with domain \(\mathbb{N}\) by specifying the
value of \(f(0)\), and also saying how to compute \(f(n+1)\) if you
already know the value of \(f(n)\).

For example, we can define a function \(f : \mathbb{N} \to \mathbb{N}\)
as follows:

\begin{quote}
\(f(0) = 1\);\newline for every \(n \in \mathbb{N}\),
\(f(n+1) = (n+1) \cdot f(n)\).

\end{quote}

Here is the same definition written in Lean. (For reasons that will
become clear shortly, we have given the function the name
\texttt{fact}.)

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ fact (k : Nat) : Nat :=}
  \KeywordTok{match}\NormalTok{ k }\KeywordTok{with}
\NormalTok{    | 0 =\textgreater{} 1}
\NormalTok{    | n + 1 =\textgreater{} (n + 1) * fact n}
\end{Highlighting}
\end{Shaded}

Lean can use this definition to compute \texttt{fact\ k} for any natural
number \texttt{k}. The \texttt{match} statement tells Lean to try to
match the input \texttt{k} with one of the two patterns \texttt{0} and
\texttt{n\ +\ 1}, and then to use the corresponding formula after
\texttt{=\textgreater{}} to compute \texttt{fact\ k}. For example, if we
ask Lean for \texttt{fact\ 4}, it first checks if \texttt{4} matches
\texttt{0}. Since it doesn't, it goes on to the next line and determines
that \texttt{4} matches the pattern \texttt{n\ +\ 1}, with
\texttt{n\ =\ 3}, so it uses the formula
\texttt{fact\ 4\ =\ 4\ *\ fact\ 3}. Of course, now it must compute
\texttt{fact\ 3}, which it does in the same way: \texttt{3} matches
\texttt{n\ +\ 1} with \texttt{n\ =\ 2}, so
\texttt{fact\ 3\ =\ 3\ *\ fact\ 2}. Continuing in this way, Lean
determines that

\begin{ind}

\begin{verbatim}
fact 4 = 4 * fact 3 = 4 * (3 * fact 2) = 4 * (3 * (2 * fact 1))
       = 4 * (3 * (2 * (1 * fact 0))) = 4 * (3 * (2 * (1 * 1))) = 24.
\end{verbatim}

\end{ind}

You can confirm this with the \texttt{\#eval} command:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{\#eval}\NormalTok{ fact 4   }\CommentTok{{-}{-}Answer: 24}
\end{Highlighting}
\end{Shaded}

Of course, by now you have probably guessed why we used the name
\texttt{fact} for his function: \texttt{fact\ k} is \texttt{k}
factorial---the product of all the numbers from 1 to \texttt{k}.

This style of definition is called a \emph{recursive} definition. If a
function is defined by a recursive definition, then theorems about that
function are often most easily proven by induction. For example, here is
a theorem about the factorial function. It is Example 6.3.1 in
\emph{HTPI}, and we begin the Lean proof by imitating the proof in
\emph{HTPI}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem} \SpecialCharTok{??}\AnnotationTok{Example\_6\_3\_1}\SpecialCharTok{::}\NormalTok{ : ∀ n ≥ 4, fact n \textgreater{} 2 \^{} n := }\KeywordTok{by}
  \KeywordTok{by\_induc}
\NormalTok{  · }\CommentTok{{-}{-} Base Case}
    \KeywordTok{norm\_num}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Induction Step}
    \KeywordTok{fix}\NormalTok{ n : Nat}
    \KeywordTok{assume}\NormalTok{ h1 : n ≥ 4}
    \KeywordTok{assume}\NormalTok{ ih : fact n \textgreater{} 2 \^{} n}
    \KeywordTok{show}\NormalTok{ fact (n + 1) \textgreater{} 2 \^{} (n + 1) }\KeywordTok{from}
      \KeywordTok{calc}\NormalTok{ fact (n + 1)}
\NormalTok{        \_ = (n + 1) * fact n := }\KeywordTok{by} \KeywordTok{rfl}
\NormalTok{        \_ \textgreater{} (n + 1) * 2 \^{} n := }\ConstantTok{sorry}
\NormalTok{        \_ \textgreater{} 2 * 2 \^{} n := }\ConstantTok{sorry}
\NormalTok{        \_ = 2 \^{} (n + 1) := }\KeywordTok{by} \KeywordTok{ring}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

There are two steps in the calculational proof at the end that require
justification. The first says that
\texttt{(n\ +\ 1)\ *\ fact\ n\ \textgreater{}\ (n\ +\ 1)\ *\ 2\ \^{}\ n},
which should follow from the inductive hypothesis
\texttt{ih\ :\ fact\ n\ \textgreater{}\ 2\ \^{}\ n} by multiplying both
sides by \texttt{n\ +\ 1}. Is there a theorem that would justify this
inference?

This may remind you of a step in \texttt{Example\_6\_1\_3} where we used
the theorem \texttt{Nat.mul\_le\_mul\_right}, which says
\texttt{∀\ \{n\ m\ :\ ℕ\}\ (k\ :\ ℕ),\ n\ ≤\ m\ →\ n\ *\ k\ ≤\ m\ *\ k}.
Our situation in this example is similar, but it involves a strict
inequality (\texttt{\textgreater{}} rather than \texttt{≥}) and it
involves multiplying on the left rather than the right. Many theorems
about inequalities in Lean's library contain either \texttt{le} (for
``less than or equal to'') or \texttt{lt} (for ``less than'') in their
names, but they can also be used to prove statements involving
\texttt{≥} or \texttt{\textgreater{}}. Perhaps the theorem we need is
named something like \texttt{Nat.mul\_lt\_mul\_left}. If you type
\texttt{\#check\ @Nat.mul\_lt\_mul} into VS Code, a pop-up window will
appear listing several theorems that begin with
\texttt{Nat.mul\_lt\_mul}. There is no \texttt{Nat.mul\_lt\_mul\_left},
but there is a theorem called \texttt{Nat.mul\_lt\_mul\_of\_pos\_left},
and its meaning is

\begin{ind}

\begin{verbatim}
@Nat.mul_lt_mul_of_pos_left : ∀ {n m k : ℕ},
                                n < m → k > 0 → k * n < k * m
\end{verbatim}

\end{ind}

Lean has correctly reminded us that, to multiply both sides of a strict
inequality by a number \texttt{k}, we need to know that
\texttt{k\ \textgreater{}\ 0}. So in our case, we'll need to prove that
\texttt{n\ +\ 1\ \textgreater{}\ 0}. Once we have that, we can use the
theorem \texttt{Nat.mul\_lt\_mul\_of\_pos\_left} to eliminate the first
\texttt{sorry}.

The second \texttt{sorry} is similar:
\texttt{(n\ +\ 1)\ *\ 2\ \^{}\ n\ \textgreater{}\ 2\ *\ 2\ \^{}\ n}
should follow from \texttt{n\ +\ 1\ \textgreater{}\ 2} and
\texttt{2\ \^{}\ n\ \textgreater{}\ 0}, and you can verify that the
theorem that will justify this inference is
\texttt{Nat.mul\_lt\_mul\_of\_pos\_right}.

So we have three inequalities that we need to prove before we can
justify the steps of the calculational proof:
\texttt{n\ +\ 1\ \textgreater{}\ 0},
\texttt{n\ +\ 1\ \textgreater{}\ 2}, and
\texttt{2\ \^{}\ n\ \textgreater{}\ 0}. We'll insert \texttt{have} steps
before the calculational proof to assert these three inequalities. If
you try it, you'll find that \texttt{linarith} can prove the first two,
but not the third.

How can we prove \texttt{2\ \^{}\ n\ \textgreater{}\ 0}? It is often
helpful to think about whether there is a general principle that is
behind a statement we are trying to prove. In our case, the inequality
\texttt{2\ \^{}\ n\ \textgreater{}\ 0} is an instance of the general
fact that if \texttt{m} and \texttt{n} are any natural numbers with
\texttt{m\ \textgreater{}\ 0}, then
\texttt{m\ \^{}\ n\ \textgreater{}\ 0}. Maybe that fact is in Lean's
library:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (m n : Nat) (h : m \textgreater{} 0) : m \^{} n \textgreater{} 0 := }\KeywordTok{by} \SpecialCharTok{++}\DocumentationTok{apply?}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

The \texttt{apply?} tactic comes up with
\texttt{exact\ Nat.pos\_pow\_of\_pos\ n\ h}, and
\texttt{\#check\ @pos\_pow\_of\_pos} gives the result

\begin{ind}

\begin{verbatim}
@Nat.pos_pow_of_pos : ∀ {n : ℕ} (m : ℕ), 0 < n → 0 < n ^ m
\end{verbatim}

\end{ind}

That means that we can use \texttt{Nat.pos\_pow\_of\_pos} to prove
\texttt{2\ \^{}\ n\ \textgreater{}\ 0}, but first we'll need to prove
that \texttt{2\ \textgreater{}\ 0}. We now have all the pieces we need;
putting them together leads to this proof:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_6\_3\_1 : ∀ n ≥ 4, fact n \textgreater{} 2 \^{} n := }\KeywordTok{by}
  \KeywordTok{by\_induc}
\NormalTok{  · }\CommentTok{{-}{-} Base Case}
    \KeywordTok{norm\_num}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Induction Step}
    \KeywordTok{fix}\NormalTok{ n : Nat}
    \KeywordTok{assume}\NormalTok{ h1 : n ≥ 4}
    \KeywordTok{assume}\NormalTok{ ih : fact n \textgreater{} 2 \^{} n}
    \KeywordTok{have}\NormalTok{ h2 : n + 1 \textgreater{} 0 := }\KeywordTok{by} \KeywordTok{linarith}
    \KeywordTok{have}\NormalTok{ h3 : n + 1 \textgreater{} 2 := }\KeywordTok{by} \KeywordTok{linarith}
    \KeywordTok{have}\NormalTok{ h4 : 2 \textgreater{} 0 := }\KeywordTok{by} \KeywordTok{linarith}
    \KeywordTok{have}\NormalTok{ h5 : 2 \^{} n \textgreater{} 0 := Nat.pos\_pow\_of\_pos n h4}
    \KeywordTok{show}\NormalTok{ fact (n + 1) \textgreater{} 2 \^{} (n + 1) }\KeywordTok{from}
      \KeywordTok{calc}\NormalTok{ fact (n + 1)}
\NormalTok{        \_ = (n + 1) * fact n := }\KeywordTok{by} \KeywordTok{rfl}
\NormalTok{        \_ \textgreater{} (n + 1) * 2 \^{} n := Nat.mul\_lt\_mul\_of\_pos\_left ih h2}
\NormalTok{        \_ \textgreater{} 2 * 2 \^{} n := Nat.mul\_lt\_mul\_of\_pos\_right h3 h5}
\NormalTok{        \_ = 2 \^{} (n + 1) := }\KeywordTok{by} \KeywordTok{ring}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

But there is an easier way. Look at the two ``\textgreater{}'' steps in
the calculational proof at the end of \texttt{Example\_6\_3\_1}. In both
cases, we took a known relationship between two quantities and did
something to both sides that preserved the relationship. In the first
case, the known relationship was
\texttt{ih\ :\ fact\ n\ \textgreater{}\ 2\ \^{}\ n}, and we multiplied
both sides by \texttt{n\ +\ 1} on the left; in the second, the known
relationship was \texttt{h3\ :\ n\ +\ 1\ \textgreater{}\ 2}, and we
multiplied both sides by \texttt{2\ \^{}\ n} on the right. To justify
these steps, we had to find the right theorems in Lean's library, and we
ended up needing auxiliary positivity facts:
\texttt{h2\ :\ n\ +\ 1\ \textgreater{}\ 0} in the first case and
\texttt{h5\ :\ 2\ \^{}\ n\ \textgreater{}\ 0} in the second. There is a
tactic that can simplify these steps: if \texttt{h} is a proof of a
statement asserting a relationship between two quantities, then the
tactic \texttt{rel\ {[}h{]}} will attempt to prove any statement
obtained from that relationship by applying the same operation to both
sides. The tactic will try to find a theorem in Lean's library that says
that the operation preserves the relationship, and if the theorem
requires auxiliary positivity facts, it will try to prove those facts as
well. The \texttt{rel} tactic doesn't always succeed, but when it does,
it saves you the trouble of searching through the library for the
necessary theorems. In this case, the tactic allows us to give a much
simpler proof of \texttt{Example\_6\_3\_1}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_6\_3\_1 : ∀ n ≥ 4, fact n \textgreater{} 2 \^{} n := }\KeywordTok{by}
  \KeywordTok{by\_induc}
\NormalTok{  · }\CommentTok{{-}{-} Base Case}
    \KeywordTok{norm\_num}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Induction Step}
    \KeywordTok{fix}\NormalTok{ n : Nat}
    \KeywordTok{assume}\NormalTok{ h1 : n ≥ 4}
    \KeywordTok{assume}\NormalTok{ ih : fact n \textgreater{} 2 \^{} n}
    \KeywordTok{have}\NormalTok{ h2 : n + 1 \textgreater{} 2 := }\KeywordTok{by} \KeywordTok{linarith}
    \KeywordTok{show}\NormalTok{ fact (n + 1) \textgreater{} 2 \^{} (n + 1) }\KeywordTok{from}
      \KeywordTok{calc}\NormalTok{ fact (n + 1)}
\NormalTok{        \_ = (n + 1) * fact n := }\KeywordTok{by} \KeywordTok{rfl}
\NormalTok{        \_ \textgreater{} (n + 1) * 2 \^{} n := }\KeywordTok{by} \KeywordTok{rel}\NormalTok{ [ih]}
\NormalTok{        \_ \textgreater{} 2 * 2 \^{} n := }\KeywordTok{by} \KeywordTok{rel}\NormalTok{ [h2]}
\NormalTok{        \_ = 2 \^{} (n + 1) := }\KeywordTok{by} \KeywordTok{ring}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

The next example in \emph{HTPI} is a proof of one of the laws of
exponents: \texttt{a\ \^{}\ (m\ +\ n)\ =\ a\ \^{}\ m\ *\ a\ \^{}\ n}.
Lean's definition of exponentiation with natural number exponents is
recursive. For some reason, the definitions are slightly different for
different kinds of bases. The definitions Lean uses are essentially as
follows:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-}For natural numbers b and k, b \^{} k = nat\_pow b k:}
\KeywordTok{def}\NormalTok{ nat\_pow (b k : Nat) : Nat :=}
  \KeywordTok{match}\NormalTok{ k }\KeywordTok{with}
\NormalTok{    | 0 =\textgreater{} 1}
\NormalTok{    | n + 1 =\textgreater{} (nat\_pow b n) * b}

\CommentTok{{-}{-}For a real number b and a natural number k, b \^{} k = real\_pow b k:}
\KeywordTok{def}\NormalTok{ real\_pow (b : Real) (k : Nat) : Real :=}
  \KeywordTok{match}\NormalTok{ k }\KeywordTok{with}
\NormalTok{    | 0 =\textgreater{} 1}
\NormalTok{    | n + 1 =\textgreater{} b * (real\_pow b n)}
\end{Highlighting}
\end{Shaded}

Let's prove the addition law for exponents:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_6\_3\_2\_cheating : ∀ (a : Real) (m n : Nat),}
\NormalTok{    a \^{} (m + n) = a \^{} m * a \^{} n := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ a : Real; }\KeywordTok{fix}\NormalTok{ m : Nat; }\KeywordTok{fix}\NormalTok{ n : Nat}
  \KeywordTok{ring}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

Well, that wasn't really fair. The \texttt{ring} tactic knows the laws
of exponents, so it has no trouble proving this theorem. But we want to
know \emph{why} the law holds, so let's see if we can prove it without
using \texttt{ring}. The following proof is essentially the same as the
proof in \emph{HTPI}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_6\_3\_2 : ∀ (a : Real) (m n : Nat),}
\NormalTok{    a \^{} (m + n) = a \^{} m * a \^{} n := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ a : Real; }\KeywordTok{fix}\NormalTok{ m : Nat}
    \CommentTok{{-}{-}Goal : ∀ (n : Nat), a \^{} (m + n) = a \^{} m * a \^{} n}
  \KeywordTok{by\_induc}
\NormalTok{  · }\CommentTok{{-}{-} Base Case}
    \KeywordTok{show}\NormalTok{ a \^{} (m + 0) = a \^{} m * a \^{} 0 }\KeywordTok{from}
      \KeywordTok{calc}\NormalTok{ a \^{} (m + 0)}
\NormalTok{        \_ = a \^{} m := }\KeywordTok{by} \KeywordTok{rfl}
\NormalTok{        \_ = a \^{} m * 1 := (mul\_one (a \^{} m)).symm}
\NormalTok{        \_ = a \^{} m * a \^{} 0 := }\KeywordTok{by} \KeywordTok{rfl}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Induction Step}
    \KeywordTok{fix}\NormalTok{ n : Nat}
    \KeywordTok{assume}\NormalTok{ ih : a \^{} (m + n) = a \^{} m * a \^{} n}
    \KeywordTok{show}\NormalTok{ a \^{} (m + (n + 1)) = a \^{} m * a \^{} (n + 1) }\KeywordTok{from}
      \KeywordTok{calc}\NormalTok{ a \^{} (m + (n + 1))}
\NormalTok{        \_ = a \^{} ((m + n) + 1) := }\KeywordTok{by} \KeywordTok{rw}\NormalTok{ [add\_assoc]}
\NormalTok{        \_ = a * a \^{} (m + n) := }\KeywordTok{by} \KeywordTok{rfl}
\NormalTok{        \_ = a * (a \^{} m * a \^{} n) := }\KeywordTok{by} \KeywordTok{rw}\NormalTok{ [ih]}
\NormalTok{        \_ = a \^{} m * (a * a \^{} n) := }\KeywordTok{by}
              \KeywordTok{rw}\NormalTok{ [←mul\_assoc, mul\_comm a, mul\_assoc]}
\NormalTok{        \_ = a \^{} m * (a \^{} (n + 1)) := }\KeywordTok{by} \KeywordTok{rfl}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

Finally, we'll prove the theorem in Example 6.3.4 of \emph{HTPI}, which
again involves exponentiation with natural number exponents. Here's the
beginning of the proof:

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_6\_3\_4 : ∀ (x : Real), x \textgreater{} {-}1 →}
\NormalTok{    ∀ (n : Nat), (1 + x) \^{} n ≥ 1 + n * x := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ x : Real}
  \KeywordTok{assume}\NormalTok{ h1 : x \textgreater{} {-}1}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{x }\NormalTok{: ℝ}
\InformationTok{h1 }\NormalTok{: x \textgreater{} {-}1}
\NormalTok{⊢ ∀ (n : ℕ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  (1 + x) \^{} n ≥}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    1 + ↑n * x}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Look carefully at the goal in the tactic state. Why is there a
\texttt{↑} before the last \texttt{n}? The reason has to do with types.
The variable \texttt{x} has type \texttt{Real} and \texttt{n} has type
\texttt{Nat}, so how can Lean multiply \texttt{n} by \texttt{x}?
Remember, in Lean, the natural numbers are not a subset of the real
numbers. The two types are completely separate, but for each natural
number, there is a corresponding real number. To multiply \texttt{n} by
\texttt{x}, Lean had to convert \texttt{n} to the corresponding real
number, through a process called \emph{coercion}. The notation
\texttt{↑n} denotes the result of \emph{coercing} (or \emph{casting})
\texttt{n} to another type---in this case, \texttt{Real}. Since
\texttt{↑n} and \texttt{x} are both real numbers, Lean can use the
multiplication operation on the real numbers to multiply them. (To type
\texttt{↑} in VSCode, type \texttt{\textbackslash{}uparrow}, or just
\texttt{\textbackslash{}u}.)

As we will see, the need for coercion in this example will make the
proof a bit more complicated, because we'll need to use some theorems
about coercions. Theorems about coercion of natural numbers to some
other type often have names that start \texttt{Nat.cast}.

Continuing with the proof, since exponentiation is defined recursively,
let's try mathematical induction:

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_6\_3\_4 : ∀ (x : Real), x \textgreater{} {-}1 →}
\NormalTok{    ∀ (n : Nat), (1 + x) \^{} n ≥ 1 + n * x := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ x : Real}
  \KeywordTok{assume}\NormalTok{ h1 : x \textgreater{} {-}1}
  \KeywordTok{by\_induc}
\NormalTok{  · }\CommentTok{{-}{-} Base Case}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\NormalTok{  · }\CommentTok{{-}{-} Induction Step}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}  
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ Base\_Case}
\InformationTok{x }\NormalTok{: ℝ}
\InformationTok{h1 }\NormalTok{: x \textgreater{} {-}1}
\NormalTok{⊢ (1 + x) \^{} 0 ≥}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  1 + ↑0 * x}
\end{Highlighting}
\end{Shaded}

\end{outpt}

You might think that \texttt{linarith} could prove the goal for the base
case, but it can't. The problem is the \texttt{↑0}, which denotes the
result of coercing the natural number \texttt{0} to a real number. Of
course, that should be the real number \texttt{0}, but is it? Yes, but
the \texttt{linarith} tactic doesn't know that. The theorem
\texttt{Nat.cast\_zero} says that \texttt{↑0\ =\ 0} (where the
\texttt{0} on the right side of the equation is the \emph{real number}
\texttt{0}), so the tactic \texttt{rewrite\ {[}Nat.cast\_zero{]}} will
convert \texttt{↑0} to \texttt{0}. After that step, \texttt{linarith}
can complete the proof of the base case, and we can start on the
induction step.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_6\_3\_4 : ∀ (x : Real), x \textgreater{} {-}1 →}
\NormalTok{    ∀ (n : Nat), (1 + x) \^{} n ≥ 1 + n * x := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ x : Real}
  \KeywordTok{assume}\NormalTok{ h1 : x \textgreater{} {-}1}
  \KeywordTok{by\_induc}
\NormalTok{  · }\CommentTok{{-}{-} Base Case}
    \KeywordTok{rewrite}\NormalTok{ [Nat.cast\_zero]}
    \KeywordTok{linarith}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Induction Step}
    \KeywordTok{fix}\NormalTok{ n : Nat}
    \KeywordTok{assume}\NormalTok{ ih : (1 + x) \^{} n ≥ 1 + n * x}
    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\RegionMarkerTok{case}\NormalTok{ Induction\_Step}
\InformationTok{x }\NormalTok{: ℝ}
\InformationTok{h1 }\NormalTok{: x \textgreater{} {-}1}
\InformationTok{n }\NormalTok{: ℕ}
\InformationTok{ih }\NormalTok{: (1 + x) \^{} n ≥}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    1 + ↑n * x}
\NormalTok{⊢ (1 + x) \^{} (n + 1) ≥}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  1 + ↑(n + 1) * x}
\end{Highlighting}
\end{Shaded}

\end{outpt}

Once again, there's a complication caused by coercion. The inductive
hypothesis talks about \texttt{↑n}, but the goal involves
\texttt{↑(n\ +\ 1)}. What is the relationship between these? Surely it
should be the case that \texttt{↑(n\ +\ 1)\ =\ ↑n\ +\ 1}; that is, the
result of coercing the natural number \texttt{n\ +\ 1} to a real number
should be one larger than the result of coercing \texttt{n} to a real
number. The theorem \texttt{Nat.cast\_succ} says exactly that, so
\texttt{rewrite\ {[}Nat.cast\_succ{]}} will change the
\texttt{↑(n\ +\ 1)} in the goal to \texttt{↑n\ +\ 1}. (The number
\texttt{n\ +\ 1} is sometimes called the \emph{successor} of \texttt{n},
and \texttt{succ} is short for ``successor.'') With that change, we can
continue with the proof. The following proof is modeled on the proof in
\emph{HTPI}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem} \SpecialCharTok{??}\AnnotationTok{Example\_6\_3\_4}\SpecialCharTok{::}\NormalTok{ : ∀ (x : Real), x \textgreater{} {-}1 →}
\NormalTok{    ∀ (n : Nat), (1 + x) \^{} n ≥ 1 + n * x := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ x : Real}
  \KeywordTok{assume}\NormalTok{ h1 : x \textgreater{} {-}1}
  \KeywordTok{by\_induc}
\NormalTok{  · }\CommentTok{{-}{-} Base Case}
    \KeywordTok{rewrite}\NormalTok{ [Nat.cast\_zero]}
    \KeywordTok{linarith}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Induction Step}
    \KeywordTok{fix}\NormalTok{ n : Nat}
    \KeywordTok{assume}\NormalTok{ ih : (1 + x) \^{} n ≥ 1 + n * x}
    \KeywordTok{rewrite}\NormalTok{ [Nat.cast\_succ]}
    \KeywordTok{show}\NormalTok{ (1 + x) \^{} (n + 1) ≥ 1 + (n + 1) * x }\KeywordTok{from}
      \KeywordTok{calc}\NormalTok{ (1 + x) \^{} (n + 1)}
\NormalTok{        \_ = (1 + x) * (1 + x) \^{} n := }\KeywordTok{by} \KeywordTok{rfl}
\NormalTok{        \_ ≥ (1 + x) * (1 + n * x) := }\ConstantTok{sorry}
\NormalTok{        \_ = 1 + x + n * x + n * x \^{} 2 := }\KeywordTok{by} \KeywordTok{ring}
\NormalTok{        \_ ≥ 1 + x + n * x + 0 := }\ConstantTok{sorry}
\NormalTok{        \_ = 1 + (n + 1) * x := }\KeywordTok{by} \KeywordTok{ring}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

Note that in the calculational proof, each \texttt{n} or
\texttt{n\ +\ 1} that is multiplied by \texttt{x} is really \texttt{↑n}
or \texttt{↑n\ +\ 1}, but we don't need to say so explicitly; Lean fills
in coercions automatically when they are required.

All that's left is to replace the two occurrences of \texttt{sorry} with
justifications. The first \texttt{sorry} step should follow from the
inductive hypothesis by multiplying both sides by \texttt{1\ +\ x}, so a
natural attempt to justify it would be \texttt{by\ rel\ {[}ih{]}}.
Unfortunately, we get an error message saying that \texttt{rel} failed.
The error message tells us that \texttt{rel} needed to know that
\texttt{0\ ≤\ 1\ +\ x}, and it was unable to prove it, so we'll have to
provide a proof of that statement ourselves. Fortunately,
\texttt{linarith} can handle it (deducing it from
\texttt{h1\ :\ x\ \textgreater{}\ -1}), and once we fill in that
additional step, the \texttt{rel} tactic succeeds.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem} \SpecialCharTok{??}\AnnotationTok{Example\_6\_3\_4}\SpecialCharTok{::}\NormalTok{ : ∀ (x : Real), x \textgreater{} {-}1 →}
\NormalTok{    ∀ (n : Nat), (1 + x) \^{} n ≥ 1 + n * x := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ x : Real}
  \KeywordTok{assume}\NormalTok{ h1 : x \textgreater{} {-}1}
  \KeywordTok{by\_induc}
\NormalTok{  · }\CommentTok{{-}{-} Base Case}
    \KeywordTok{rewrite}\NormalTok{ [Nat.cast\_zero]}
    \KeywordTok{linarith}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Induction Step}
    \KeywordTok{fix}\NormalTok{ n : Nat}
    \KeywordTok{assume}\NormalTok{ ih : (1 + x) \^{} n ≥ 1 + n * x}
    \KeywordTok{rewrite}\NormalTok{ [Nat.cast\_succ]}
    \KeywordTok{have}\NormalTok{ h2 : 0 ≤ 1 + x := }\KeywordTok{by} \KeywordTok{linarith}
    \KeywordTok{show}\NormalTok{ (1 + x) \^{} (n + 1) ≥ 1 + (n + 1) * x }\KeywordTok{from}
      \KeywordTok{calc}\NormalTok{ (1 + x) \^{} (n + 1)}
\NormalTok{        \_ = (1 + x) * (1 + x) \^{} n := }\KeywordTok{by} \KeywordTok{rfl}
\NormalTok{        \_ ≥ (1 + x) * (1 + n * x) := }\KeywordTok{by} \KeywordTok{rel}\NormalTok{ [ih]}
\NormalTok{        \_ = 1 + x + n * x + n * x \^{} 2 := }\KeywordTok{by} \KeywordTok{ring}
\NormalTok{        \_ ≥ 1 + x + n * x + 0 := }\ConstantTok{sorry}
\NormalTok{        \_ = 1 + (n + 1) * x := }\KeywordTok{by} \KeywordTok{ring}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

For the second \texttt{sorry} step, we'll need to know that
\texttt{n\ *\ x\ \^{}\ 2\ ≥\ 0}. To prove it, we start with the fact
that the square of any real number is nonnegative:

\begin{ind}

\begin{verbatim}
@sq_nonneg : ∀ {R : Type u_1} [inst : LinearOrderedRing R]
              (a : R), 0 ≤ a ^ 2
\end{verbatim}

\end{ind}

As usual, we don't need to pay much attention to the implicit arguments;
what is important is the last line, which tells us that
\texttt{sq\_nonneg\ x} is a proof of \texttt{x\ \^{}\ 2\ ≥\ 0}. To get
\texttt{n\ *\ x\ \^{}\ 2\ ≥\ 0} we just have to multiply both sides by
\texttt{n}, which we can justify with the \texttt{rel} tactic, and then
one more application of \texttt{rel} will handle the remaining
\texttt{sorry}. Here is the complete proof:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_6\_3\_4 : ∀ (x : Real), x \textgreater{} {-}1 →}
\NormalTok{    ∀ (n : Nat), (1 + x) \^{} n ≥ 1 + n * x := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ x : Real}
  \KeywordTok{assume}\NormalTok{ h1 : x \textgreater{} {-}1}
  \KeywordTok{by\_induc}
\NormalTok{  · }\CommentTok{{-}{-} Base Case}
    \KeywordTok{rewrite}\NormalTok{ [Nat.cast\_zero]}
    \KeywordTok{linarith}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Induction Step}
    \KeywordTok{fix}\NormalTok{ n : Nat}
    \KeywordTok{assume}\NormalTok{ ih : (1 + x) \^{} n ≥ 1 + n * x}
    \KeywordTok{rewrite}\NormalTok{ [Nat.cast\_succ]}
    \KeywordTok{have}\NormalTok{ h2 : 0 ≤ 1 + x := }\KeywordTok{by} \KeywordTok{linarith}
    \KeywordTok{have}\NormalTok{ h3 : x \^{} 2 ≥ 0 := sq\_nonneg x}
    \KeywordTok{have}\NormalTok{ h4 : n * x \^{} 2 ≥ 0 :=}
      \KeywordTok{calc}\NormalTok{ n * x \^{} 2}
\NormalTok{        \_ ≥ n * 0 := }\KeywordTok{by} \KeywordTok{rel}\NormalTok{ [h3]}
\NormalTok{        \_ = 0 := }\KeywordTok{by} \KeywordTok{ring}
    \KeywordTok{show}\NormalTok{ (1 + x) \^{} (n + 1) ≥ 1 + (n + 1) * x }\KeywordTok{from}
      \KeywordTok{calc}\NormalTok{ (1 + x) \^{} (n + 1)}
\NormalTok{        \_ = (1 + x) * (1 + x) \^{} n := }\KeywordTok{by} \KeywordTok{rfl}
\NormalTok{        \_ ≥ (1 + x) * (1 + n * x) := }\KeywordTok{by} \KeywordTok{rel}\NormalTok{ [ih]}
\NormalTok{        \_ = 1 + x + n * x + n * x \^{} 2 := }\KeywordTok{by} \KeywordTok{ring}
\NormalTok{        \_ ≥ 1 + x + n * x + 0 := }\KeywordTok{by} \KeywordTok{rel}\NormalTok{ [h4]}
\NormalTok{        \_ = 1 + (n + 1) * x := }\KeywordTok{by} \KeywordTok{ring}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

Before ending this section, we'll return to a topic left unexplained
before. We can now describe how \texttt{Sum\ i\ from\ k\ to\ n,\ f\ i}
is defined. The key is a function \texttt{sum\_seq}, which is defined by
recursion:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ sum\_seq \{A : }\KeywordTok{Type}\NormalTok{\} [AddZeroClass A]}
\NormalTok{    (m k : Nat) (f : Nat → A) : A :=}
  \KeywordTok{match}\NormalTok{ m }\KeywordTok{with}
\NormalTok{    | 0 =\textgreater{} 0}
\NormalTok{    | n + 1 =\textgreater{} sum\_seq n k f + f (k + n)}
\end{Highlighting}
\end{Shaded}

To get an idea of what this definition means, let's try evaluating
\texttt{sum\_seq\ 3\ k\ f}:

\begin{ind}

\begin{verbatim}
sum_seq 3 k f = sum_seq 2 k f + f (k + 2)
              = sum_seq 1 k f + f (k + 1) + f (k + 2)
              = sum_seq 0 k f + f (k + 0) + f (k + 1) + f (k + 2)
              = 0 + f (k + 0) + f (k + 1) + f (k + 2)
              = f k + f (k + 1) + f (k + 2).
\end{verbatim}

\end{ind}

So \texttt{sum\_seq\ 3\ k\ f} adds up three consecutive values of
\texttt{f}, starting with \texttt{f\ k}. More generally,
\texttt{sum\_seq\ n\ k\ f} adds up a sequence of \texttt{n} consecutive
values of \texttt{f}, starting with \texttt{f\ k}. (The implicit
arguments say that the type of the values of \texttt{f} can be any type
for which \texttt{+} and \texttt{0} make sense.) The notation
\texttt{Sum\ i\ from\ k\ to\ n,\ f\ i} is now defined to be a shorthand
for \texttt{sum\_seq\ (n\ +\ 1\ -\ k)\ k\ f}. We'll leave it to you to
puzzle out why that gives the desired result.

\hypertarget{exercises-16}{%
\subsection{Exercises}\label{exercises-16}}

\begin{numex}{1}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_6\_3\_4 : ∀ (n : Nat),}
\NormalTok{    3 * (}\KeywordTok{Sum}\NormalTok{ i }\KeywordTok{from}\NormalTok{ 0 }\KeywordTok{to}\NormalTok{ n, (2 * i + 1) \^{} 2) =}
\NormalTok{    (n + 1) * (2 * n + 1) * (2 * n + 3) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{2}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_6\_3\_7b (f : Nat → Real) (c : Real) : ∀ (n : Nat),}
    \KeywordTok{Sum}\NormalTok{ i }\KeywordTok{from}\NormalTok{ 0 }\KeywordTok{to}\NormalTok{ n, c * f i = c * }\KeywordTok{Sum}\NormalTok{ i }\KeywordTok{from}\NormalTok{ 0 }\KeywordTok{to}\NormalTok{ n, f i := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{3}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ fact\_pos : ∀ (n : Nat), fact n ≥ 1 := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{4}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-}Hint:  Use the theorem fact\_pos from the previous exercise.}
\KeywordTok{theorem}\NormalTok{ Exercise\_6\_3\_13a (k : Nat) : ∀ (n : Nat),}
\NormalTok{    fact (k \^{} 2 + n) ≥ k \^{} (2 * n) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{5}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-}Hint:  Use the theorem in the previous exercise.}
\CommentTok{{-}{-}You may find it useful to first prove a lemma:}
\CommentTok{{-}{-}∀ (k : Nat), 2 * k \^{} 2 + 1 ≥ k}
\KeywordTok{theorem}\NormalTok{ Exercise\_6\_3\_13b (k : Nat) : ∀ n ≥ 2 * k \^{} 2,}
\NormalTok{    fact n ≥ k \^{} n := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

6. A sequence is defined recursively as follows:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ seq\_6\_3\_15 (k : Nat) : Int :=}
  \KeywordTok{match}\NormalTok{ k }\KeywordTok{with}
\NormalTok{    | 0 =\textgreater{} 0}
\NormalTok{    | n + 1 =\textgreater{} 2 * seq\_6\_3\_15 n + n}
\end{Highlighting}
\end{Shaded}

Prove the following theorem about this sequence:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_6\_3\_15 : ∀ (n : Nat),}
\NormalTok{    seq\_6\_3\_15 n = 2 \^{} n {-} n {-} 1 := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

7. A sequence is defined recursively as follows:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ seq\_6\_3\_16 (k : Nat) : Nat :=}
  \KeywordTok{match}\NormalTok{ k }\KeywordTok{with}
\NormalTok{    | 0 =\textgreater{} 2}
\NormalTok{    | n + 1 =\textgreater{} (seq\_6\_3\_16 n) \^{} 2}
\end{Highlighting}
\end{Shaded}

Find a formula for \texttt{seq\_6\_3\_16\ n}. Fill in the blank in the
theorem below with your formula and then prove the theorem.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_6\_3\_16 : ∀ (n : Nat),}
\NormalTok{    seq\_6\_3\_16 n = \_\_\_ := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\hypertarget{strong-induction}{%
\section{6.4. Strong Induction}\label{strong-induction}}

In the induction step of a proof by mathematical induction, we prove
that a natural number has some property from the assumption that the
previous number has the property. Section 6.4 of \emph{HTPI} introduces
a version of mathematical induction in which we get to assume that
\emph{all} smaller numbers have the property. Since this is a stronger
assumption, this version of induction is called \emph{strong induction}.
Here is how strong induction works (\emph{HTPI} p.~304):

\hypertarget{to-prove-a-goal-of-the-form-n-nat-p-n-1}{%
\subsubsection{\texorpdfstring{To prove a goal of the form
\texttt{∀\ (n\ :\ Nat),\ P\ n}:}{To prove a goal of the form ∀ (n : Nat), P n:}}\label{to-prove-a-goal-of-the-form-n-nat-p-n-1}}

\begin{ind}
Prove that
\texttt{∀\ (n\ :\ Nat),\ (∀\ n\_1\ \textless{}\ n,\ P\ n\_1)\ →\ P\ n}.

\end{ind}

To write a proof by strong induction in Lean, we use the tactic
\texttt{by\_strong\_induc}, whose effect on the tactic state can be
illustrated as follows.

\begin{bef}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{ ⋮}
\NormalTok{⊢ ∀ (n : Nat), P n}
\end{Highlighting}
\end{Shaded}

\end{bef}

\begin{aft}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{ ⋮}
\NormalTok{⊢  ∀ (n : Nat),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  (∀ n\_1 \textless{} n, P n\_1) → P n}
\end{Highlighting}
\end{Shaded}

\end{aft}

To illustrate this, we begin with Example 6.4.1 of \emph{HTPI}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_6\_4\_1 : ∀ m \textgreater{} 0, ∀ (n : Nat),}
\NormalTok{    ∃ (q r : Nat), n = m * q + r ∧ r \textless{} m}
\end{Highlighting}
\end{Shaded}

Imitating the strategy of the proof in \emph{HTPI}, we let \texttt{m} be
an arbitrary natural number, assume \texttt{m\ \textgreater{}\ 0}, and
then prove the statement
\texttt{∀\ (n\ :\ Nat),\ ∃\ (q\ r\ :\ Nat),\ n\ =\ m\ *\ q\ +\ r\ ∧\ r\ \textless{}\ m}
by strong induction. That means that after introducing an arbitrary
natural number \texttt{n}, we assume the inductive hypothesis, which
says
\texttt{∀\ n\_1\ \textless{}\ n,\ ∃\ (q\ r\ :\ Nat),\ n\_1\ =\ m\ *\ q\ +\ r\ ∧\ r\ \textless{}\ m}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_6\_4\_1 : ∀ m \textgreater{} 0, ∀ (n : Nat),}
\NormalTok{    ∃ (q r : Nat), n = m * q + r ∧ r \textless{} m := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ m : Nat}
  \KeywordTok{assume}\NormalTok{ h1 : m \textgreater{} 0}
  \KeywordTok{by\_strong\_induc}
  \KeywordTok{fix}\NormalTok{ n : Nat}
  \KeywordTok{assume}\NormalTok{ ih : ∀ n\_1 \textless{} n, ∃ (q r : Nat), n\_1 = m * q + r ∧ r \textless{} m}
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

Our goal now is to prove that
\texttt{∃\ (q\ r\ :\ Nat),\ n\ =\ m\ *\ q\ +\ r\ ∧\ r\ \textless{}\ m}.
Although strong induction does not require a base case, it is not
uncommon for proofs by strong induction to involve reasoning by cases.
The proof in \emph{HTPI} uses cases based on whether or not
\texttt{n\ \textless{}\ m}. If \texttt{n\ \textless{}\ m}, then the
proof is easy: the numbers \texttt{q\ =\ 0} and
\texttt{r\hspace{0pt}\ =\ n} clearly have the required properties. If
\texttt{¬n\ \textless{}\ m}, then we can write \texttt{n} as
\texttt{n\ =\ k\ +\ m}, for some natural number \texttt{k}. Since
\texttt{m\ \textgreater{}\ 0}, we have \texttt{k\ \textless{}\ n}, so we
can apply the inductive hypothesis to \texttt{k}. Notice that if
\texttt{m\ \textgreater{}\ 1}, then \texttt{k} is not the number
immediately preceding \texttt{n}; that's why this proof uses strong
induction rather than ordinary induction.

How do we come up with the number \texttt{k} in the previous paragraph?
We'll use a theorem from Lean's library. There are two slightly
different versions of the theorem---notice that the first ends with
\texttt{m\ +\ k} and the second ends with \texttt{k\ +\ m}:

\begin{ind}

\begin{verbatim}
@Nat.exists_eq_add_of_le : ∀ {m n : ℕ}, m ≤ n → ∃ (k : ℕ), n = m + k

@Nat.exists_eq_add_of_le' : ∀ {m n : ℕ}, m ≤ n → ∃ (k : ℕ), n = k + m
\end{verbatim}

\end{ind}

We'll use the second version in our proof.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Example\_6\_4\_1 : ∀ m \textgreater{} 0, ∀ (n : Nat),}
\NormalTok{    ∃ (q r : Nat), n = m * q + r ∧ r \textless{} m := }\KeywordTok{by}
  \KeywordTok{fix}\NormalTok{ m : Nat}
  \KeywordTok{assume}\NormalTok{ h1 : m \textgreater{} 0}
  \KeywordTok{by\_strong\_induc}
  \KeywordTok{fix}\NormalTok{ n : Nat}
  \KeywordTok{assume}\NormalTok{ ih : ∀ n\_1 \textless{} n, ∃ (q r : Nat), n\_1 = m * q + r ∧ r \textless{} m}
  \KeywordTok{by\_cases}\NormalTok{ h2 : n \textless{} m}
\NormalTok{  · }\CommentTok{{-}{-} Case 1. h2 : n \textless{} m}
    \KeywordTok{apply}\NormalTok{ Exists.intro 0}
    \KeywordTok{apply}\NormalTok{ Exists.intro n     }\CommentTok{{-}{-}Goal : n = m * 0 + n ∧ n \textless{} m}
    \KeywordTok{apply}\NormalTok{ And.intro \_ h2}
    \KeywordTok{ring}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Case 2. h2 : ¬n \textless{} m}
    \KeywordTok{have}\NormalTok{ h3 : m ≤ n := }\KeywordTok{by} \KeywordTok{linarith}
    \KeywordTok{obtain}\NormalTok{ (k : Nat) (h4 : n = k + m) }\KeywordTok{from}\NormalTok{ Nat.exists\_eq\_add\_of\_le\textquotesingle{} h3}
    \KeywordTok{have}\NormalTok{ h5 : k \textless{} n := }\KeywordTok{by} \KeywordTok{linarith}
    \KeywordTok{have}\NormalTok{ h6 : ∃ (q r : Nat), k = m * q + r ∧ r \textless{} m := ih k h5}
    \KeywordTok{obtain}\NormalTok{ (q\textquotesingle{} : Nat)}
\NormalTok{      (h7 : ∃ (r : Nat), k = m * q\textquotesingle{} + r ∧ r \textless{} m) }\KeywordTok{from}\NormalTok{ h6}
    \KeywordTok{obtain}\NormalTok{ (r\textquotesingle{} : Nat) (h8 : k = m * q\textquotesingle{} + r\textquotesingle{} ∧ r\textquotesingle{} \textless{} m) }\KeywordTok{from}\NormalTok{ h7}
    \KeywordTok{apply}\NormalTok{ Exists.intro (q\textquotesingle{} + 1)}
    \KeywordTok{apply}\NormalTok{ Exists.intro r\textquotesingle{}     }\CommentTok{{-}{-}Goal : n = m * (q\textquotesingle{} + 1) + r\textquotesingle{} ∧ r\textquotesingle{} \textless{} m}
    \KeywordTok{apply}\NormalTok{ And.intro \_ h8.right}
    \KeywordTok{show}\NormalTok{ n = m * (q\textquotesingle{} + 1) + r\textquotesingle{} }\KeywordTok{from}
      \KeywordTok{calc}\NormalTok{ n}
\NormalTok{        \_ = k + m := h4}
\NormalTok{        \_ = m * q\textquotesingle{} + r\textquotesingle{} + m := }\KeywordTok{by} \KeywordTok{rw}\NormalTok{ [h8.left]}
\NormalTok{        \_ = m * (q\textquotesingle{} + 1) + r\textquotesingle{} := }\KeywordTok{by} \KeywordTok{ring}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

The numbers \texttt{q} and \texttt{r} in \texttt{Example\_6\_4\_1} are
called the \emph{quotient} and \emph{remainder} when \texttt{n} is
divided by \texttt{m}. Lean knows how to compute these numbers: if
\texttt{n} and \texttt{m} are natural numbers, then in Lean,
\texttt{n\ /\ m} denotes the quotient when \texttt{n} is divided by
\texttt{m}, and \texttt{n\ \%\ m} denotes the remainder. (The number
\texttt{n\ \%\ m} is also sometimes called \texttt{n} \emph{modulo}
\texttt{m}, or \texttt{n} \emph{mod} \texttt{m}.) And Lean knows
theorems stating that these numbers have the properties specified in
\texttt{Example\_6\_4\_1}:

\begin{ind}

\begin{verbatim}
@Nat.div_add_mod : ∀ (m n : ℕ), n * (m / n) + m % n = m

@Nat.mod_lt : ∀ (x : ℕ) {y : ℕ}, y > 0 → x % y < y
\end{verbatim}

\end{ind}

By the way, although we are unlikely to want to use the notation
\texttt{n\ /\ 0} or \texttt{n\ \%\ 0}, Lean uses the definitions
\texttt{n\ /\ 0\ =\ 0} and \texttt{n\ \%\ 0\ =\ n}. As a result, the
equation \texttt{n\ *\ (m\ /\ n)\ +\ m\ \%\ n\ =\ m} is true even if
\texttt{n\ =\ 0}. That's why the theorem \texttt{Nat.div\_add\_mod}
doesn't include a requirement that \texttt{n\ \textgreater{}\ 0}. It is
important to keep in mind that division of natural numbers is not the
same as division of real numbers. For example, dividing the natural
number \texttt{5} by the natural number \texttt{2} gives a quotient of
\texttt{2} (with a remainder of \texttt{1}), so
\texttt{(5\ :\ Nat)\ /\ (2\ :\ Nat)} is \texttt{2}, but
\texttt{(5\ :\ Real)\ /\ (2\ :\ Real)} is \texttt{2.5}.

There is also a strong form of recursion. As an example of this, here is
a recursive definition of a sequence of numbers called the
\emph{Fibonacci numbers}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ Fib (n : Nat) : Nat :=}
  \KeywordTok{match}\NormalTok{ n }\KeywordTok{with}
\NormalTok{    | 0 =\textgreater{} 0}
\NormalTok{    | 1 =\textgreater{} 1}
\NormalTok{    | k + 2 =\textgreater{} Fib k + Fib (k + 1)}
\end{Highlighting}
\end{Shaded}

Notice that the formula for \texttt{Fib\ (k\ +\ 2)} involves the
\emph{two} previous values of \texttt{Fib}, not just the immediately
preceding value. That is the sense in which the recursion is
\emph{strong}. Not surprisingly, theorems about the Fibonacci numbers
are often proven by induction---either ordinary or strong. We'll
illustrate this with a proof by strong induction that
\texttt{∀\ (n\ :\ Nat),\ Fib\ n\ \textless{}\ 2\ \^{}\ n}. This time
we'll need to treat the cases \texttt{n\ =\ 0} and \texttt{n\ =\ 1}
separately, since these values are treated separately in the definition
of \texttt{Fib\ n}. And we'll need to know that if \texttt{n} doesn't
fall into either of those cases, then it falls into the third case:
\texttt{n\ =\ k\ +\ 2} for some natural number \texttt{k}. Since similar
ideas will come up several times in the rest of this book, it will be
useful to begin by proving lemmas that will help with this kind of
reasoning.

We'll need two theorems from Lean's library, the second of which has two
slightly different versions:

\begin{ind}

\begin{verbatim}
@Nat.pos_of_ne_zero : ∀ {n : ℕ}, n ≠ 0 → 0 < n

@lt_of_le_of_ne : ∀ {α : Type u_1} [inst : PartialOrder α] {a b : α},
                    a ≤ b → a ≠ b → a < b

@lt_of_le_of_ne' : ∀ {α : Type u_1} [inst : PartialOrder α] {a b : α},
                    a ≤ b → b ≠ a → a < b
\end{verbatim}

\end{ind}

If we have \texttt{h1\ :\ n\ ≠\ 0}, then
\texttt{Nat.pos\_of\_ne\_zero\ h1} is a proof of
\texttt{0\ \textless{}\ n}. But for natural numbers \texttt{a} and
\texttt{b}, Lean treats \texttt{a\ \textless{}\ b} as meaning the same
thing as \texttt{a\ +\ 1\ ≤\ b}, so this is also a proof of
\texttt{1\ ≤\ n}. If we also have \texttt{h2\ :\ n\ ≠\ 1}, then we can
use \texttt{lt\_of\_le\_of\_ne\textquotesingle{}} to conclude
\texttt{1\ \textless{}\ n}, which is definitionally equal to
\texttt{2\ ≤\ n}. Combining this reasoning with the theorem
\texttt{Nat.exists\_eq\_add\_of\_le\textquotesingle{}}, which we used in
the last example, we can prove two lemmas that will be helpful for
reasoning in which the first one or two natural numbers have to be
treated separately.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ exists\_eq\_add\_one\_of\_ne\_zero \{n : Nat\}}
\NormalTok{    (h1 : n ≠ 0) : ∃ (k : Nat), n = k + 1 := }\KeywordTok{by}
  \KeywordTok{have}\NormalTok{ h2 : 1 ≤ n := Nat.pos\_of\_ne\_zero h1}
  \KeywordTok{show}\NormalTok{ ∃ (k : Nat), n = k + 1 }\KeywordTok{from}\NormalTok{ Nat.exists\_eq\_add\_of\_le\textquotesingle{} h2}
  \KeywordTok{done}

\KeywordTok{theorem}\NormalTok{ exists\_eq\_add\_two\_of\_ne\_zero\_one \{n : Nat\}}
\NormalTok{    (h1 : n ≠ 0) (h2 : n ≠ 1) : ∃ (k : Nat), n = k + 2 := }\KeywordTok{by}
  \KeywordTok{have}\NormalTok{ h3 : 1 ≤ n := Nat.pos\_of\_ne\_zero h1}
  \KeywordTok{have}\NormalTok{ h4 : 2 ≤ n := lt\_of\_le\_of\_ne\textquotesingle{} h3 h2}
  \KeywordTok{show}\NormalTok{ ∃ (k : Nat), n = k + 2 }\KeywordTok{from}\NormalTok{ Nat.exists\_eq\_add\_of\_le\textquotesingle{} h4}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

With this preparation, we can present the proof:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ : ∀ (n : Nat), Fib n \textless{} 2 \^{} n := }\KeywordTok{by}
  \KeywordTok{by\_strong\_induc}
  \KeywordTok{fix}\NormalTok{ n : Nat}
  \KeywordTok{assume}\NormalTok{ ih : ∀ (n\_1 : Nat), n\_1 \textless{} n → Fib n\_1 \textless{} 2 \^{} n\_1}
  \KeywordTok{by\_cases}\NormalTok{ h1 : n = 0}
\NormalTok{  · }\CommentTok{{-}{-} Case 1. h1 : n = 0}
    \KeywordTok{rewrite}\NormalTok{ [h1]   }\CommentTok{{-}{-}Goal : Fib 0 \textless{} 2 \^{} 0}
    \KeywordTok{norm\_num}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Case 2. h1 : ¬n = 0}
    \KeywordTok{by\_cases}\NormalTok{ h2 : n = 1}
\NormalTok{    · }\CommentTok{{-}{-} Case 2.1. h2 : n = 1}
      \KeywordTok{rewrite}\NormalTok{ [h2]}
      \KeywordTok{norm\_num}
      \KeywordTok{done}
\NormalTok{    · }\CommentTok{{-}{-} Case 2.2. h2 : ¬n = 1}
      \KeywordTok{obtain}\NormalTok{ (k : Nat) (h3 : n = k + 2) }\KeywordTok{from}
\NormalTok{        exists\_eq\_add\_two\_of\_ne\_zero\_one h1 h2}
      \KeywordTok{have}\NormalTok{ h4 : k \textless{} n := }\KeywordTok{by} \KeywordTok{linarith}
      \KeywordTok{have}\NormalTok{ h5 : Fib k \textless{} 2 \^{} k := ih k h4}
      \KeywordTok{have}\NormalTok{ h6 : k + 1 \textless{} n := }\KeywordTok{by} \KeywordTok{linarith}
      \KeywordTok{have}\NormalTok{ h7 : Fib (k + 1) \textless{} 2 \^{} (k + 1) := ih (k + 1) h6}
      \KeywordTok{rewrite}\NormalTok{ [h3]            }\CommentTok{{-}{-}Goal : Fib (k + 2) \textless{} 2 \^{} (k + 2)}
      \KeywordTok{show}\NormalTok{ Fib (k + 2) \textless{} 2 \^{} (k + 2) }\KeywordTok{from}
        \KeywordTok{calc}\NormalTok{ Fib (k + 2)}
\NormalTok{          \_ = Fib k + Fib (k + 1) := }\KeywordTok{by} \KeywordTok{rfl}
\NormalTok{          \_ \textless{} 2 \^{} k + Fib (k + 1) := }\KeywordTok{by} \KeywordTok{rel}\NormalTok{ [h5]}
\NormalTok{          \_ \textless{} 2 \^{} k + 2 \^{} (k + 1) := }\KeywordTok{by} \KeywordTok{rel}\NormalTok{ [h7]}
\NormalTok{          \_ ≤ 2 \^{} k + 2 \^{} (k + 1) + 2 \^{} k := }\KeywordTok{by} \KeywordTok{linarith}
\NormalTok{          \_ = 2 \^{} (k + 2) := }\KeywordTok{by} \KeywordTok{ring}
      \KeywordTok{done}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

As with ordinary induction, strong induction can be useful for proving
statements that do not at first seem to have the form
\texttt{∀\ (n\ :\ Nat),\ ...}. To illustrate this, we'll prove the
\emph{well-ordering principle}, which says that if a set
\texttt{S\ :\ Set\ Nat} is nonempty, then it has a smallest element.
We'll prove the contrapositive: if \texttt{S} has no smallest element,
then it is empty. To say that \texttt{S} is empty means
\texttt{∀\ (n\ :\ Nat),\ n\ ∉\ S}, and that's the statement to which we
will apply strong induction.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ well\_ord\_princ (S : Set Nat) : (∃ (n : Nat), n ∈ S) →}
\NormalTok{    ∃ (n : Nat), n ∈ S ∧ ∀ (m : Nat), m ∈ S → n ≤ m := }\KeywordTok{by}
  \KeywordTok{contrapos}
  \KeywordTok{assume}\NormalTok{ h1 : ¬∃ (n : Nat), n ∈ S ∧ ∀ (m : Nat), m ∈ S → n ≤ m}
  \KeywordTok{quant\_neg}                   \CommentTok{{-}{-}Goal : ∀ (n : Nat), ¬n ∈ S}
  \KeywordTok{by\_strong\_induc}
  \KeywordTok{fix}\NormalTok{ n : Nat}
  \KeywordTok{assume}\NormalTok{ ih : ∀ (n\_1 : Nat), n\_1 \textless{} n → ¬n\_1 ∈ S  }\CommentTok{{-}{-}Goal : ¬n ∈ S}
  \KeywordTok{contradict}\NormalTok{ h1 }\KeywordTok{with}\NormalTok{ h2       }\CommentTok{{-}{-}h2 : n ∈ S}
    \CommentTok{{-}{-}Goal : ∃ (n : Nat), n ∈ S ∧ ∀ (m : Nat), m ∈ S → n ≤ m}
  \KeywordTok{apply}\NormalTok{ Exists.intro n}
  \KeywordTok{apply}\NormalTok{ And.intro h2          }\CommentTok{{-}{-}Goal : ∀ (m : Nat), m ∈ S → n ≤ m}
  \KeywordTok{fix}\NormalTok{ m : Nat}
  \KeywordTok{assume}\NormalTok{ h3 : m ∈ S}
  \KeywordTok{have}\NormalTok{ h4 : m \textless{} n → ¬m ∈ S := ih m}
  \KeywordTok{contrapos} \KeywordTok{at}\NormalTok{ h4             }\CommentTok{{-}{-}h4 : m ∈ S → ¬m \textless{} n}
  \KeywordTok{have}\NormalTok{ h5 : ¬m \textless{} n := h4 h3}
  \KeywordTok{linarith}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

Section 6.4 of \emph{HTPI} ends with an example of an application of the
well ordering principle. The example gives a proof that \(\sqrt{2}\) is
irrational. If \(\sqrt{2}\) were rational, then there would be natural
numbers \(p\) and \(q\) such that \(q \ne 0\) and \(p/q = \sqrt{2}\),
and therefore \(p^2 = 2q^2\). So we can prove that \(\sqrt{2}\) is
irrational by showing that there do not exist natural numbers \(p\) and
\(q\) such that \(q \ne 0\) and \(p^2 = 2q^2\).

The proof uses a definition from the exercises of Section 6.1:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ nat\_even (n : Nat) : }\KeywordTok{Prop}\NormalTok{ := ∃ (k : Nat), n = 2 * k}
\end{Highlighting}
\end{Shaded}

We will also use the following lemma, whose proof we leave as an
exercise for you:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ sq\_even\_iff\_even (n : Nat) : nat\_even (n * n) ↔ nat\_even n := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

And we'll need another theorem that we haven't seen before:

\begin{ind}

\begin{verbatim}
@mul_left_cancel_iff_of_pos : ∀ {α : Type u_1} {a b c : α}
                    [inst : MulZeroClass α] [inst_1 : PartialOrder α]
                    [inst_2 : PosMulMonoRev α],
                    0 < a → (a * b = a * c ↔ b = c)
\end{verbatim}

\end{ind}

To show that \(\sqrt{2}\) is irrational, we will prove the statement

\begin{quote}

\begin{verbatim}
¬∃ (q p : Nat), p * p = 2 * (q * q) ∧ q ≠ 0
\end{verbatim}

\end{quote}

We proceed by contradiction. If this statement were false, then the set

\begin{quote}

\begin{verbatim}
S = { q : Nat | ∃ (p : Nat), p * p = 2 * (q * q) ∧ q ≠ 0 }
\end{verbatim}

\end{quote}

would be nonempty, and therefore, by the well ordering principle, it
would have a smallest element. We then show that this leads to a
contradiction. Here is the proof.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_6\_4\_5 :}
\NormalTok{    ¬∃ (q p : Nat), p * p = 2 * (q * q) ∧ q ≠ 0 := }\KeywordTok{by}
  \KeywordTok{set}\NormalTok{ S : Set Nat :=}
\NormalTok{    \{ q : Nat | ∃ (p : Nat), p * p = 2 * (q * q) ∧ q ≠ 0 \}}
  \KeywordTok{by\_contra}\NormalTok{ h1}
  \KeywordTok{have}\NormalTok{ h2 : ∃ (q : Nat), q ∈ S := h1}
  \KeywordTok{have}\NormalTok{ h3 : ∃ (q : Nat), q ∈ S ∧ ∀ (r : Nat), r ∈ S → q ≤ r :=}
\NormalTok{    well\_ord\_princ S h2}
  \KeywordTok{obtain}\NormalTok{ (q : Nat) (h4 : q ∈ S ∧ ∀ (r : Nat), r ∈ S → q ≤ r) }\KeywordTok{from}\NormalTok{ h3}
  \KeywordTok{have}\NormalTok{ qinS : q ∈ S := h4.left}
  \KeywordTok{have}\NormalTok{ qleast : ∀ (r : ℕ), r ∈ S → q ≤ r := h4.right}
  \KeywordTok{define} \KeywordTok{at}\NormalTok{ qinS     }\CommentTok{{-}{-}qinS : ∃ (p : Nat), p * p = 2 * (q * q) ∧ q ≠ 0}
  \KeywordTok{obtain}\NormalTok{ (p : Nat) (h5 : p * p = 2 * (q * q) ∧ q ≠ 0) }\KeywordTok{from}\NormalTok{ qinS}
  \KeywordTok{have}\NormalTok{ pqsqrt2 : p * p = 2 * (q * q) := h5.left}
  \KeywordTok{have}\NormalTok{ qne0 : q ≠ 0 := h5.right}
  \KeywordTok{have}\NormalTok{ h6 : nat\_even (p * p) := Exists.intro (q * q) pqsqrt2}
  \KeywordTok{rewrite}\NormalTok{ [sq\_even\_iff\_even p] }\KeywordTok{at}\NormalTok{ h6    }\CommentTok{{-}{-}h6 : nat\_even p}
  \KeywordTok{obtain}\NormalTok{ (p\textquotesingle{} : Nat) (p\textquotesingle{}halfp : p = 2 * p\textquotesingle{}) }\KeywordTok{from}\NormalTok{ h6}
  \KeywordTok{have}\NormalTok{ h7 : 2 * (2 * (p\textquotesingle{} * p\textquotesingle{})) = 2 * (q * q) := }\KeywordTok{by}
    \KeywordTok{rewrite}\NormalTok{ [←pqsqrt2, p\textquotesingle{}halfp]}
    \KeywordTok{ring}
    \KeywordTok{done}
  \KeywordTok{have}\NormalTok{ h8 : 2 \textgreater{} 0 := }\KeywordTok{by} \KeywordTok{norm\_num}
  \KeywordTok{rewrite}\NormalTok{ [mul\_left\_cancel\_iff\_of\_pos h8] }\KeywordTok{at}\NormalTok{ h7}
    \CommentTok{{-}{-}h7 : 2 * (p\textquotesingle{} * p\textquotesingle{}) = q * q}
  \KeywordTok{have}\NormalTok{ h9 : nat\_even (q * q) := Exists.intro (p\textquotesingle{} * p\textquotesingle{}) h7.symm}
  \KeywordTok{rewrite}\NormalTok{ [sq\_even\_iff\_even q] }\KeywordTok{at}\NormalTok{ h9   }\CommentTok{{-}{-}h9 : nat\_even q}
  \KeywordTok{obtain}\NormalTok{ (q\textquotesingle{} : Nat) (q\textquotesingle{}halfq : q = 2 * q\textquotesingle{}) }\KeywordTok{from}\NormalTok{ h9}
  \KeywordTok{have}\NormalTok{ h10 : 2 * (p\textquotesingle{} * p\textquotesingle{}) = 2 * (2 * (q\textquotesingle{} * q\textquotesingle{})) := }\KeywordTok{by}
    \KeywordTok{rewrite}\NormalTok{ [h7, q\textquotesingle{}halfq]}
    \KeywordTok{ring}
    \KeywordTok{done}
  \KeywordTok{rewrite}\NormalTok{ [mul\_left\_cancel\_iff\_of\_pos h8] }\KeywordTok{at}\NormalTok{ h10}
    \CommentTok{{-}{-}h10 : p\textquotesingle{} * p\textquotesingle{} = 2 * (q\textquotesingle{} * q\textquotesingle{})}
  \KeywordTok{have}\NormalTok{ q\textquotesingle{}ne0 : q\textquotesingle{} ≠ 0 := }\KeywordTok{by}
    \KeywordTok{contradict}\NormalTok{ qne0 }\KeywordTok{with}\NormalTok{ h11}
    \KeywordTok{rewrite}\NormalTok{ [q\textquotesingle{}halfq, h11]}
    \KeywordTok{rfl}
    \KeywordTok{done}
  \KeywordTok{have}\NormalTok{ q\textquotesingle{}inS : q\textquotesingle{} ∈ S := Exists.intro p\textquotesingle{} (And.intro h10 q\textquotesingle{}ne0)}
  \KeywordTok{have}\NormalTok{ qleq\textquotesingle{} : q ≤ q\textquotesingle{} := qleast q\textquotesingle{} q\textquotesingle{}inS}
  \KeywordTok{rewrite}\NormalTok{ [q\textquotesingle{}halfq] }\KeywordTok{at}\NormalTok{ qleq\textquotesingle{}        }\CommentTok{{-}{-}qleq\textquotesingle{} : 2 * q\textquotesingle{} ≤ q\textquotesingle{}}
  \KeywordTok{contradict}\NormalTok{ q\textquotesingle{}ne0}
  \KeywordTok{linarith}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-17}{%
\subsection{Exercises}\label{exercises-17}}

\begin{numex}{1}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-}Hint: Use Exercise\_6\_1\_16a1 and Exercise\_6\_1\_16a2}
\CommentTok{{-}{-}from the exercises of Section 6.1.}
\KeywordTok{lemma}\NormalTok{ sq\_even\_iff\_even (n : Nat) :}
\NormalTok{    nat\_even (n * n) ↔ nat\_even n := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{2}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-}This theorem proves that the square root of 6 is irrational}
\KeywordTok{theorem}\NormalTok{ Exercise\_6\_4\_4a :}
\NormalTok{    ¬∃ (q p : Nat), p * p = 6 * (q * q) ∧ q ≠ 0 := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{3}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_6\_4\_5 :}
\NormalTok{    ∀ n ≥ 12, ∃ (a b : Nat), 3 * a + 7 * b = n := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{4}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_6\_4\_7a : ∀ (n : Nat),}
\NormalTok{    (}\KeywordTok{Sum}\NormalTok{ i }\KeywordTok{from}\NormalTok{ 0 }\KeywordTok{to}\NormalTok{ n, Fib i) + 1 = Fib (n + 2) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{5}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_6\_4\_7c : ∀ (n : Nat),}
    \KeywordTok{Sum}\NormalTok{ i }\KeywordTok{from}\NormalTok{ 0 }\KeywordTok{to}\NormalTok{ n, Fib (2 * i + 1) = Fib (2 * n + 2) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{6}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_6\_4\_8a : ∀ (m n : Nat),}
\NormalTok{    Fib (m + n + 1) = Fib m * Fib n + Fib (m + 1) * Fib (n + 1) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{7}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_6\_4\_8d : ∀ (m k : Nat), Fib m ∣ Fib (m * k) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

Hint for \#7: Let \texttt{m} be an arbitrary natural number, and then
use induction on \texttt{k}. For the induction step, you must prove
\texttt{Fib\ m\ ∣\ Fib\ (m\ *\ (k\ +\ 1))}. If
\texttt{m\ =\ 0\ ∨\ k\ =\ 0}, then this is easy. If not, then use
\texttt{exists\_eq\_add\_one\_of\_ne\_zero} to obtain a natural number
\texttt{j} such that \texttt{m\ *\ k\ =\ j\ +\ 1}, and therefore
\texttt{m\ *\ (k\ +\ 1)\ =\ j\ +\ m\ +\ 1}, and then apply
\texttt{Exercise\_6\_4\_8a}.

\end{numex}

\begin{numex}{8}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ Fib\_like (n : Nat) : Nat :=}
  \KeywordTok{match}\NormalTok{ n }\KeywordTok{with}
\NormalTok{    | 0 =\textgreater{} 1}
\NormalTok{    | 1 =\textgreater{} 2}
\NormalTok{    | k + 2 =\textgreater{} 2 * (Fib\_like k) + Fib\_like (k + 1)}

\KeywordTok{theorem}\NormalTok{ Fib\_like\_formula : ∀ (n : Nat), Fib\_like n = 2 \^{} n := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{9}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ triple\_rec (n : Nat) : Nat :=}
  \KeywordTok{match}\NormalTok{ n }\KeywordTok{with}
\NormalTok{    | 0 =\textgreater{} 0}
\NormalTok{    | 1 =\textgreater{} 2}
\NormalTok{    | 2 =\textgreater{} 4}
\NormalTok{    | k + 3 =\textgreater{} 4 * triple\_rec k +}
\NormalTok{                6 * triple\_rec (k + 1) + triple\_rec (k + 2)}

\KeywordTok{theorem}\NormalTok{ triple\_rec\_formula :}
\NormalTok{    ∀ (n : Nat), triple\_rec n = 2 \^{} n * Fib n := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

10. In this exercise you will prove that the numbers \texttt{q} and
\texttt{r} in \texttt{Example\_6\_4\_1} are unique. It is helpful to
prove a lemma first.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ quot\_rem\_unique\_lemma \{m q r q\textquotesingle{} r\textquotesingle{} : Nat\}}
\NormalTok{    (h1 : m * q + r = m * q\textquotesingle{} + r\textquotesingle{}) (h2 : r\textquotesingle{} \textless{} m) : q ≤ q\textquotesingle{} := }\ConstantTok{sorry}

\KeywordTok{theorem}\NormalTok{ quot\_rem\_unique (m q r q\textquotesingle{} r\textquotesingle{} : Nat)}
\NormalTok{    (h1 : m * q + r = m * q\textquotesingle{} + r\textquotesingle{}) (h2 : r \textless{} m) (h3 : r\textquotesingle{} \textless{} m) :}
\NormalTok{    q = q\textquotesingle{} ∧ r = r\textquotesingle{} := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

11. Use the theorem in the previous exercise to prove the following
characterization of \texttt{n\ /\ m} and \texttt{n\ \%\ m}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ div\_mod\_char (m n q r : Nat)}
\NormalTok{    (h1 : n = m * q + r) (h2 : r \textless{} m) : q = n / m ∧ r = n \% m := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\hypertarget{closures-again}{%
\section{6.5. Closures Again}\label{closures-again}}

Section 6.5 of \emph{HTPI} gives one more application of recursion and
induction: another proof of the existence of closures of sets under
functions. Recall from Section 5.4 that if \texttt{f\ :\ A\ →\ A} and
\texttt{B\ :\ Set\ A}, then the \emph{closure} of \texttt{B} under
\texttt{f} is the smallest set containing \texttt{B} that is closed
under \texttt{f}. In Section 5.4, we constructed the closure of
\texttt{B} under \texttt{f} by taking the intersection of all sets
containing \texttt{B} that are closed under \texttt{f}. In this section,
we construct the closure by starting with the set \texttt{B} and
repeatedly taking the image under \texttt{f}. For the motivation for
this strategy, see \emph{HTPI}; here we focus on how to carry out this
strategy in Lean.

To talk about repeatedly taking the image of a set under a function, we
will need a recursive definition:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ rep\_image \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A) (n : Nat) (B : Set A) : Set A :=}
  \KeywordTok{match}\NormalTok{ n }\KeywordTok{with}
\NormalTok{    | 0 =\textgreater{} B}
\NormalTok{    | k + 1 =\textgreater{} image f (rep\_image f k B)}
\end{Highlighting}
\end{Shaded}

According to this definition, \texttt{rep\_image\ f\ 0\ B\ =\ B},
\texttt{rep\_image\ f\ 1\ B\ =\ image\ f\ B},
\texttt{rep\_image\ f\ 2\ B\ =\ image\ f\ (image\ f\ B)}, and so on. In
other words, \texttt{rep\_image\ f\ n\ B} is the result of starting with
\texttt{B} and then taking the image under \texttt{f} \texttt{n} times.
To make it easier to work with this definition, we state two simple
theorems, both of which follow immediately from the definition.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ rep\_image\_base \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A) (B : Set A) :}
\NormalTok{    rep\_image f 0 B = B := }\KeywordTok{by} \KeywordTok{rfl}

\KeywordTok{theorem}\NormalTok{ rep\_image\_step \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A) (n : Nat) (B : Set A) :}
\NormalTok{    rep\_image f (n + 1) B = image f (rep\_image f n B) := }\KeywordTok{by} \KeywordTok{rfl}
\end{Highlighting}
\end{Shaded}

We will prove that the closure of \texttt{B} under \texttt{f} is the
union of the sets \texttt{rep\_image\ f\ n\ B}. We will call this the
\emph{cumulative image} of \texttt{B} under \texttt{f}, and we define it
as follows:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ cumul\_image \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A) (B : Set A) : Set A :=}
\NormalTok{  \{ x : A | ∃ (n : Nat), x ∈ rep\_image f n B \}}
\end{Highlighting}
\end{Shaded}

To prove that \texttt{cumul\_image\ f\ B} is the closure of \texttt{B}
under \texttt{f}, we first prove a lemma saying that if \texttt{B\ ⊆\ D}
and \texttt{D} is closed under \texttt{f}, then for every natural number
\texttt{n}, \texttt{rep\_image\ f\ n\ B\ ⊆\ D}. We prove it by
induction.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ rep\_image\_sub\_closed \{A : }\KeywordTok{Type}\NormalTok{\} \{f : A → A\} \{B D : Set A\}}
\NormalTok{    (h1 : B ⊆ D) (h2 : closed f D) :}
\NormalTok{    ∀ (n : Nat), rep\_image f n B ⊆ D := }\KeywordTok{by}
  \KeywordTok{by\_induc}
\NormalTok{  · }\CommentTok{{-}{-} Base Case}
    \KeywordTok{rewrite}\NormalTok{ [rep\_image\_base]          }\CommentTok{{-}{-}Goal : B ⊆ D}
    \KeywordTok{show}\NormalTok{ B ⊆ D }\KeywordTok{from}\NormalTok{ h1}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Induction Step}
    \KeywordTok{fix}\NormalTok{ n : Nat}
    \KeywordTok{assume}\NormalTok{ ih : rep\_image f n B ⊆ D   }\CommentTok{{-}{-}Goal : rep\_image f (n + 1) B ⊆ D}
    \KeywordTok{fix}\NormalTok{ x : A}
    \KeywordTok{assume}\NormalTok{ h3 : x ∈ rep\_image f (n + 1) B  }\CommentTok{{-}{-}Goal : x ∈ D}
    \KeywordTok{rewrite}\NormalTok{ [rep\_image\_step] }\KeywordTok{at}\NormalTok{ h3}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h3    }\CommentTok{{-}{-}h3 : ∃ (x\_1 : A), x\_1 ∈ rep\_image f n B ∧ f x\_1 = x}
    \KeywordTok{obtain}\NormalTok{ (b : A) (h4 : b ∈ rep\_image f n B ∧ f b = x) }\KeywordTok{from}\NormalTok{ h3}
    \KeywordTok{rewrite}\NormalTok{ [←h4.right]   }\CommentTok{{-}{-}Goal : f b ∈ D    }
    \KeywordTok{have}\NormalTok{ h5 : b ∈ D := ih h4.left}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2          }\CommentTok{{-}{-}h2 : ∀ (x : A), x ∈ D → f x ∈ D}
    \KeywordTok{show}\NormalTok{ f b ∈ D }\KeywordTok{from}\NormalTok{ h2 b h5}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

With this preparation, we can now prove that \texttt{cumul\_image\ f\ B}
is the closure of \texttt{B} under \texttt{f}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Theorem\_6\_5\_1 \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A) (B : Set A) :}
\NormalTok{    closure f B (cumul\_image f B) := }\KeywordTok{by}
  \KeywordTok{define}
  \KeywordTok{apply}\NormalTok{ And.intro}
\NormalTok{  · }\CommentTok{{-}{-} Proof that cumul\_image f B ∈ \{ D : Set A | B ⊆ D ∧ closed f D \}}
    \KeywordTok{define}  \CommentTok{{-}{-}Goal : B ⊆ cumul\_image f B ∧ closed f (cumul\_image f B)}
    \KeywordTok{apply}\NormalTok{ And.intro}
\NormalTok{    · }\CommentTok{{-}{-} Proof that B ⊆ cumul\_image f B}
      \KeywordTok{fix}\NormalTok{ x : A}
      \KeywordTok{assume}\NormalTok{ h1 : x ∈ B}
      \KeywordTok{define}     \CommentTok{{-}{-}Goal : ∃ (n : Nat), x ∈ rep\_image f n B}
      \KeywordTok{apply}\NormalTok{ Exists.intro 0}
      \KeywordTok{rewrite}\NormalTok{ [rep\_image\_base]  }\CommentTok{{-}{-}Goal : x ∈ B}
      \KeywordTok{show}\NormalTok{ x ∈ B }\KeywordTok{from}\NormalTok{ h1}
      \KeywordTok{done}
\NormalTok{    · }\CommentTok{{-}{-} Proof that cumul\_image f B closed under f}
      \KeywordTok{define}
      \KeywordTok{fix}\NormalTok{ x : A}
      \KeywordTok{assume}\NormalTok{ h1 : x ∈ cumul\_image f B  }\CommentTok{{-}{-}Goal : f x ∈ cumul\_image f B}
      \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1}
      \KeywordTok{obtain}\NormalTok{ (m : Nat) (h2 : x ∈ rep\_image f m B) }\KeywordTok{from}\NormalTok{ h1}
      \KeywordTok{define}     \CommentTok{{-}{-}Goal : ∃ (n : Nat), f x ∈ rep\_image f n B}
      \KeywordTok{apply}\NormalTok{ Exists.intro (m + 1) }\CommentTok{{-}{-}Goal : f x ∈ rep\_image f (m + 1) B}
      \KeywordTok{rewrite}\NormalTok{ [rep\_image\_step]   }\CommentTok{{-}{-}Goal : f x ∈ image f (rep\_image f m B)}
      \KeywordTok{define}     \CommentTok{{-}{-}Goal : ∃ (x\_1 : A), x\_1 ∈ rep\_image f m B ∧ f x\_1 = f x}
      \KeywordTok{apply}\NormalTok{ Exists.intro x  }\CommentTok{{-}{-}Goal : x ∈ rep\_image f m B ∧ f x = f x}
      \KeywordTok{apply}\NormalTok{ And.intro h2}
      \KeywordTok{rfl}
      \KeywordTok{done}
    \KeywordTok{done}
\NormalTok{  · }\CommentTok{{-}{-} Proof that cumul\_image f B is smallest}
    \KeywordTok{fix}\NormalTok{ D : Set A}
    \KeywordTok{assume}\NormalTok{ h1 : D ∈ \{ D : Set A | B ⊆ D ∧ closed f D \}}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h1  }\CommentTok{{-}{-}h1 : B ⊆ D ∧ closed f D}
    \KeywordTok{define}   \CommentTok{{-}{-}Goal : ∀ ⦃a : A⦄, a ∈ cumul\_image f B → a ∈ D}
    \KeywordTok{fix}\NormalTok{ x : A}
    \KeywordTok{assume}\NormalTok{ h2 : x ∈ cumul\_image f B  }\CommentTok{{-}{-}Goal : x ∈ D}
    \KeywordTok{define} \KeywordTok{at}\NormalTok{ h2  }\CommentTok{{-}{-}h2: ∃ (n : Nat), x ∈ rep\_image f n B}
    \KeywordTok{obtain}\NormalTok{ (m : Nat) (h3 : x ∈ rep\_image f m B) }\KeywordTok{from}\NormalTok{ h2}
    \KeywordTok{have}\NormalTok{ h4 : rep\_image f m B ⊆ D :=}
\NormalTok{      rep\_image\_sub\_closed h1.left h1.right m}
    \KeywordTok{show}\NormalTok{ x ∈ D }\KeywordTok{from}\NormalTok{ h4 h3}
    \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-18}{%
\subsection{Exercises}\label{exercises-18}}

1. Recall the following definitions from the exercises of Section 5.4:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ closed\_family \{A : }\KeywordTok{Type}\NormalTok{\} (F : Set (A → A)) (C : Set A) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  ∀ f ∈ F, closed f C}

\KeywordTok{def}\NormalTok{ closure\_family \{A : }\KeywordTok{Type}\NormalTok{\} (F : Set (A → A)) (B C : Set A) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  smallestElt (sub A) C \{ D : Set A | B ⊆ D ∧ closed\_family F D \}}
\end{Highlighting}
\end{Shaded}

These definitions say that a set is closed under a family of functions
if it is closed under all of the functions in the family, and the
closure of a set \texttt{B} under a family of functions is the smallest
set containing \texttt{B} that is closed under the family.

In this exercise we will use the following additional definitions:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ rep\_image\_family \{A : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (F : Set (A → A)) (n : Nat) (B : Set A) : Set A :=}
  \KeywordTok{match}\NormalTok{ n }\KeywordTok{with}
\NormalTok{    | 0 =\textgreater{} B}
\NormalTok{    | k + 1 =\textgreater{} \{ x : A | ∃ f ∈ F, x ∈ image f (rep\_image\_family F k B) \}}

\KeywordTok{def}\NormalTok{ cumul\_image\_family \{A : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (F : Set (A → A)) (B : Set A) : Set A :=}
\NormalTok{  \{ x : A | ∃ (n : Nat), x ∈ rep\_image\_family F n B \}}
\end{Highlighting}
\end{Shaded}

The following theorems establish that if \texttt{F\ :\ Set\ (A\ →\ A)}
and \texttt{B\ :\ Set\ A}, then \texttt{cumul\_image\_family\ F\ B} is
the closure of \texttt{B} under \texttt{F}. The first two are proven by
\texttt{rfl}; the other two are for you to prove.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ rep\_image\_family\_base \{A : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (F : Set (A → A)) (B : Set A) : rep\_image\_family F 0 B = B := }\KeywordTok{by} \KeywordTok{rfl}

\KeywordTok{theorem}\NormalTok{ rep\_image\_family\_step \{A : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (F : Set (A → A)) (n : Nat) (B : Set A) :}
\NormalTok{    rep\_image\_family F (n + 1) B =}
\NormalTok{    \{ x : A | ∃ f ∈ F, x ∈ image f (rep\_image\_family F n B) \} := }\KeywordTok{by} \KeywordTok{rfl}

\KeywordTok{lemma}\NormalTok{ rep\_image\_family\_sub\_closed \{A : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (F : Set (A → A)) (B D : Set A)}
\NormalTok{    (h1 : B ⊆ D) (h2 : closed\_family F D) :}
\NormalTok{    ∀ (n : Nat), rep\_image\_family F n B ⊆ D := }\ConstantTok{sorry}

\KeywordTok{theorem}\NormalTok{ Exercise\_6\_5\_3 \{A : }\KeywordTok{Type}\NormalTok{\} (F : Set (A → A)) (B : Set A) :}
\NormalTok{    closure\_family F B (cumul\_image\_family F B) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\begin{mdsk}

\end{mdsk}

The next two exercises concern the following two definitions from
Section 5.4:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ closed2 \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A → A) (C : Set A) : }\KeywordTok{Prop}\NormalTok{ :=}
\NormalTok{  ∀ x ∈ C, ∀ y ∈ C, f x y ∈ C}

\KeywordTok{def}\NormalTok{ closure2 \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A → A) (B C : Set A) : }\KeywordTok{Prop}\NormalTok{ := }
\NormalTok{  smallestElt (sub A) C \{ D : Set A | B ⊆ D ∧ closed2 f D \}}
\end{Highlighting}
\end{Shaded}

They also use the following definition, which extends the idea of the
image of a set under a function to functions of two variables:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ image2 \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A → A) (B : Set A) : Set A :=}
\NormalTok{  \{ z : A | ∃ (x y : A), x ∈ B ∧ y ∈ B ∧ z = f x y \}}
\end{Highlighting}
\end{Shaded}

2. A natural way to try to find the closure of a set under a function of
two variables would be to use the following definitions and theorems:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ rep\_image2 \{A : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (f : A → A → A) (n : Nat) (B : Set A) : Set A :=}
  \KeywordTok{match}\NormalTok{ n }\KeywordTok{with}
\NormalTok{    | 0 =\textgreater{} B}
\NormalTok{    | k + 1 =\textgreater{} image2 f (rep\_image2 f k B)}

\KeywordTok{theorem}\NormalTok{ rep\_image2\_base \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A → A) (B : Set A) :}
\NormalTok{    rep\_image2 f 0 B = B := }\KeywordTok{by} \KeywordTok{rfl}

\KeywordTok{theorem}\NormalTok{ rep\_image2\_step \{A : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (f : A → A → A) (n : Nat) (B : Set A) :}
\NormalTok{    rep\_image2 f (n + 1) B = image2 f (rep\_image2 f n B) := }\KeywordTok{by} \KeywordTok{rfl}

\KeywordTok{def}\NormalTok{ cumul\_image2 \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A → A) (B : Set A) : Set A :=}
\NormalTok{  \{ x : A | ∃ (n : Nat), x ∈ rep\_image2 f n B \}}
\end{Highlighting}
\end{Shaded}

We could now try to prove that if \texttt{f\ :\ A\ →\ A\ →\ A} and
\texttt{B\ :\ Set\ A}, then \texttt{cumul\_image2\ f\ B} is the closure
of \texttt{B} under \texttt{f}. However, this approach doesn't work,
because \texttt{cumul\_image2\ f\ B} might not be closed under
\texttt{f}.

Here is an incorrect informal argument that \texttt{cumul\_image2\ f\ B}
is closed under \texttt{f}. Suppose \texttt{x} and \texttt{y} are
elements of \texttt{cumul\_image2\ f\ B}. This means that we can choose
some natural number \texttt{n} such that
\texttt{x\ ∈\ rep\_image2\ f\ n\ B} and
\texttt{y\ ∈\ rep\_image2\ f\ n\ B}. This implies that
\texttt{f\ x\ y\ ∈\ image2\ f\ (rep\_image2\ f\ n\ B)\ =\ rep\_image2\ f\ (n\ +\ 1)\ B},
so \texttt{f\ x\ y\ ∈\ cumul\_image2\ f\ B}.

Find the mistake in this informal argument by trying to turn it into a
proof in Lean:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-}You won\textquotesingle{}t be able to complete this proof}
\KeywordTok{theorem}\NormalTok{ Exercise\_6\_5\_6 \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A → A) (B : Set A) :}
\NormalTok{    closed2 f (cumul\_image2 f B) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

3. In this exercise, we fix the mistake in the attempted proof in the
previous exercise. Instead of repeatedly taking the image of a set, we
repeatedly take the union of a set with its image:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ un\_image2 \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A → A) (B : Set A) : Set A :=}
\NormalTok{  B ∪ (image2 f B)}

\KeywordTok{def}\NormalTok{ rep\_un\_image2 \{A : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (f : A → A → A) (n : Nat) (B : Set A) : Set A :=}
  \KeywordTok{match}\NormalTok{ n }\KeywordTok{with}
\NormalTok{    | 0 =\textgreater{} B}
\NormalTok{    | k + 1 =\textgreater{} un\_image2 f (rep\_un\_image2 f k B)}

\KeywordTok{theorem}\NormalTok{ rep\_un\_image2\_base \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A → A) (B : Set A) :}
\NormalTok{    rep\_un\_image2 f 0 B = B := }\KeywordTok{by} \KeywordTok{rfl}

\KeywordTok{theorem}\NormalTok{ rep\_un\_image2\_step \{A : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (f : A → A → A) (n : Nat) (B : Set A) :}
\NormalTok{    rep\_un\_image2 f (n + 1) B =}
\NormalTok{    un\_image2 f (rep\_un\_image2 f n B) := }\KeywordTok{by} \KeywordTok{rfl}

\KeywordTok{def}\NormalTok{ cumul\_un\_image2 \{A : }\KeywordTok{Type}\NormalTok{\}}
\NormalTok{    (f : A → A → A) (B : Set A) : Set A :=}
\NormalTok{  \{ x : A | ∃ (n : Nat), x ∈ rep\_un\_image2 f n B \}}
\end{Highlighting}
\end{Shaded}

Now prove that if \texttt{f\ :\ A\ →\ A\ →\ A} and
\texttt{B\ :\ Set\ A}, then \texttt{cumul\_un\_image2\ f\ B} is the
closure of \texttt{B} under \texttt{f} by completing the following
proofs:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_6\_5\_8a \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A → A) (B : Set A) :}
\NormalTok{    ∀ (m n : Nat), m ≤ n →}
\NormalTok{    rep\_un\_image2 f m B ⊆ rep\_un\_image2 f n B := }\ConstantTok{sorry}

\KeywordTok{lemma}\NormalTok{ rep\_un\_image2\_sub\_closed \{A : }\KeywordTok{Type}\NormalTok{\} \{f : A → A → A\} \{B D : Set A\}}
\NormalTok{    (h1 : B ⊆ D) (h2 : closed2 f D) :}
\NormalTok{    ∀ (n : Nat), rep\_un\_image2 f n B ⊆ D := }\ConstantTok{sorry}

\KeywordTok{lemma}\NormalTok{ closed\_lemma}
\NormalTok{    \{A : }\KeywordTok{Type}\NormalTok{\} \{f : A → A → A\} \{B : Set A\} \{x y : A\} \{nx ny n : Nat\}}
\NormalTok{    (h1 : x ∈ rep\_un\_image2 f nx B) (h2 : y ∈ rep\_un\_image2 f ny B)}
\NormalTok{    (h3 : nx ≤ n) (h4 : ny ≤ n) :}
\NormalTok{    f x y ∈ cumul\_un\_image2 f B := }\ConstantTok{sorry}

\KeywordTok{theorem}\NormalTok{ Exercise\_6\_5\_8b \{A : }\KeywordTok{Type}\NormalTok{\} (f : A → A → A) (B : Set A) :}
\NormalTok{    closure2 f B (cumul\_un\_image2 f B) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\begin{mdsk}

\end{mdsk}

The remaining exercises in this section use the following definitions:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ idExt (A : }\KeywordTok{Type}\NormalTok{) : Set (A × A) := \{ (x, y) : A × A | x = y \}}

\KeywordTok{def}\NormalTok{ rep\_comp \{A : }\KeywordTok{Type}\NormalTok{\} (R : Set (A × A)) (n : Nat) : Set (A × A) :=}
  \KeywordTok{match}\NormalTok{ n }\KeywordTok{with}
\NormalTok{    | 0 =\textgreater{} idExt A}
\NormalTok{    | k + 1 =\textgreater{} comp (rep\_comp R k) R}

\KeywordTok{def}\NormalTok{ cumul\_comp \{A : }\KeywordTok{Type}\NormalTok{\} (R : Set (A × A)) : Set (A × A) :=}
\NormalTok{  \{ (x, y) : A × A | ∃ n ≥ 1, (x, y) ∈ rep\_comp R n \}}
\end{Highlighting}
\end{Shaded}

\begin{numex}{4}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ rep\_comp\_one \{A : }\KeywordTok{Type}\NormalTok{\} (R : Set (A × A)) :}
\NormalTok{    rep\_comp R 1 = R := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{5}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_6\_5\_11 \{A : }\KeywordTok{Type}\NormalTok{\} (R : Set (A × A)) :}
\NormalTok{    ∀ (m n : Nat), rep\_comp R (m + n) =}
\NormalTok{    comp (rep\_comp R m) (rep\_comp R n) := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{6}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lemma}\NormalTok{ rep\_comp\_sub\_trans \{A : }\KeywordTok{Type}\NormalTok{\} \{R S : Set (A × A)\}}
\NormalTok{    (h1 : R ⊆ S) (h2 : transitive (RelFromExt S)) :}
\NormalTok{    ∀ n ≥ 1, rep\_comp R n ⊆ S := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}

\begin{numex}{7}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theorem}\NormalTok{ Exercise\_6\_5\_14 \{A : }\KeywordTok{Type}\NormalTok{\} (R : Set (A × A)) :}
\NormalTok{    smallestElt (sub (A × A)) (cumul\_comp R)}
\NormalTok{    \{ S : Set (A × A) | R ⊆ S ∧ transitive (RelFromExt S) \} := }\ConstantTok{sorry}
\end{Highlighting}
\end{Shaded}

\end{numex}



\end{document}
