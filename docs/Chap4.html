<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Automated Proof Verification with Lean - 3&nbsp; Conclusions</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./references.html" rel="next">
<link href="./Chap3.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="HTPIwLstyles.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./Chap4.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Conclusions</span></a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Automated Proof Verification with Lean</a> 
        <div class="sidebar-tools-main">
    <a href="./Automated-Proof-Verification-with-Lean.pdf" rel="" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Acknowledgements</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Functional Programming</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Lean as a Theorem Prover</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chap4.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Conclusions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Works Cited</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">In This Chapter</h2>
   
  <ul class="collapse">
  <li><a href="#the-good" id="toc-the-good" class="nav-link active" data-scroll-target="#the-good">The Good</a></li>
  <li><a href="#the-bad" id="toc-the-bad" class="nav-link" data-scroll-target="#the-bad">The Bad</a></li>
  <li><a href="#the-future" id="toc-the-future" class="nav-link" data-scroll-target="#the-future">The Future</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
<div class="hidden">
$$
\newcommand{\setmin}{\mathbin{\backslash}}
\newcommand{\symmdiff}{\bigtriangleup}
$$
</div>

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Conclusions</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="the-good" class="level2">
<h2 class="anchored" data-anchor-id="the-good">The Good</h2>
<p>It is easy to see the potential which Lean has to aid in proof verification, and it only seems to be gaining more popularity. The language is continuously being expanded and made more powerful which should only help make it accessible to more people. The language already has some features that could be very helpful to new users, such as the <code>apply?</code> tactic. This tactic looks at the current goal and all hypotheses and suggests tactics and theorems which could be applied to get closer to the goal. While this is certainly not perfect, it is very helpful and I used it quite a few times during my time with the language. This tactic is most useful for peopple who are new to the language and are not sure how to apply the theorems that they need or what the theorems may be called in Lean. This tactic worked best for me when completing simple steps that only required one more theorem already in Lean’s library to reach my current goal.</p>
<p>Lean is like the kitchen we are cooking our proofs in and its libraries full of theorems are like cupboards and pantries containing all of the tools with which we are cooking. It would be impossible for us to have read through the entire library and as such we can occasionally rely on the <code>apply?</code> tactic for some assistance when necessary. Picture a situation in which we already have boiled potatoes and we are attempting to make mashed potatoes, but we are unsure of which tool we could use to do this or in which cupboard it would be located. In this scenario, we could consult the <code>apply?</code> tactic as if we were asking, “What can I use to mash these potatoes up?” to which Lean may reply, “I would use the masher, found on the top shelf of that pantry over there.” This tactic is not perfect and cannot make every connection, but if we are already quite close to a connection, <code>apply?</code> can typically get us the rest of the way there.</p>
<p>Another helpful tactic is the <code>sorry</code> tactic. This is mainly helpful for those trying to initially prove theorems in Lean rather than just convert previous proofs into Lean. Applying <code>sorry</code> to a goal automatically proves that goal within the context of the problem, allowing the user to continue on with the proof and return to that sub-proof later. Since using this tactic does not actually prove a theorem, Lean will underline the main theorem and not allow it to be used in any other proofs. While this line of thinking could also be done with pen and paper, the ability to see if one approach would even be fruitful before taking the time to justify everything is convenient and could help with the process of creating proofs.</p>
<section id="sorry-example" class="level4">
<h4 class="anchored" data-anchor-id="sorry-example"><code>sorry</code> Example</h4>
<p>This is an example of sorry being used in a <code>by_cases</code> proof.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode lean code-with-copy"><code class="sourceCode lean"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">example</span> (a b c d : ℝ) (h1: a &lt; b) </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    (h2 : c ≤ d) : a + c &lt; b + d := <span class="kw">by</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">by_cases</span> h3 : c = d</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  · <span class="co">--Case 1 </span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cn">sorry</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  · <span class="co">--Case 2</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">push_neg</span> <span class="kw">at</span> h3</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">have</span> h4 : c &lt; d := <span class="kw">by</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">apply</span> Ne.lt_of_le h3 h2</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">exact</span> <span class="kw">calc</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>      a + c &lt; b + c := add_lt_add_right h1 c</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>      _ &lt; b + d := add_lt_add_left h4 b</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In this example, I may think that the first case where <span class="math inline">\(c = d\)</span> is simple and decide that I would rather focus my efforts on the second case first. Using <code>sorry</code> here allows me to only focus on the second case of the proof and still see if my justification for it would be valid. This tactic is not really about modifying the proof to make it easier to solve, but rather about a way of organizing our proof. This tactic also does not fit well into our cooking metaphor, because there is no way to skip over some steps and still get a finished product. This tactic may be more akin to a magical elf which would automatically make the sauce for our pasta with the stipulation that we can’t actually eat any of it and we have to leave a note saying that the elf helped us.</p>
<p>Lean clearly laying out all known hypotheses and the current goal which would finish the proof could aid some users in figuring out how to prove theorems or problems they might have struggled with otherwise. This was one of the biggest benefits of the language when I was working with it, because it is often difficult to keep track of exactly what I know to be true. Being able to automatically simplify hypotheses and take things back to their definitions can greatly help figure out how each hypothesis could be applied.</p>
<p>Even without these tactics which make the language more user friendly, Lean still absolutely accomplishes its goal of automated proof verification. The language is somewhat difficult to get the hang of even with newly empowered tactics and theorems, but the users who have a deep understanding of the language are truly able to harness its full potential and easily work with difficult concepts in a way that is at times more concise than writing it out on paper. If a proof is being verified by another human, it may be necessary to go into great detail so that they are able to understand each step being taken. With Lean, however, once one knows how to work within Lean’s realm of understanding they should be able to prove anything and not need to go into great detail. This difference in explanation would only grow larger when venturing into higher level mathematics and newly developing topics.</p>
<p>Lean’s intent on proof verification also raises the question of how necessary automated proof verification truly is. No doubt is it useful to have a proof checked by a machine for you, but if this were to be used to develop new theorems, they would still need to eventually be written in a way on paper that other human mathematicians can easily understand and use. Automation in mathematics is nice, but ultimately the human mathematicians are the ones making new developments and as such should be prioritized when writing proofs. Lean could, however, help with the writing of human readable proofs so long as the writer fully understands what the Lean code is doing. Lean can ensure that no logical jumps are being taken and if something is broken down into steps that Lean can understand, someone could translate them into human readable steps that would be totally coherent and logical.</p>
</section>
</section>
<section id="the-bad" class="level2">
<h2 class="anchored" data-anchor-id="the-bad">The Bad</h2>
<p>The biggest downside to using Lean is getting used to the programming language itself and trying to put mathematical steps into terms which Lean is able to understand. If someone has not spent much time working with programming languages it would certainly be difficult and time consuming to learn something entirely new, but even for those who have had experience programming the switch into Lean could still prove difficult. While there are methods within Lean which could aid new users such as the aforementioned <code>apply?</code> tactic, it is still necessary to know how to manipulate hypotheses into a form that Lean is able to work with, which may not always be as easy as it would be on paper.</p>
<p>Another downside to Lean is the lack of options and potentially the inability to immediately keep up with mathematics in the future. Development takes time, and in order to do proofs in Lean more theorems and definitions need to be added and worked out. As new areas of mathematics are expanded, it will be necessary to do upkeep on the language and add in new features or even make large overhauls to the language depending on the significance of the work being done. As I mentioned earlier, Lean completely abandons some methods of proof in favor of more currently concise methods. This works fine for now, but if there was a newly developing area of mathematics which functioned better under a previously abandoned method, Lean may need to be reworked and theorems may need to be rewritten to fit better into the new system.</p>
<p>Lean also abandons some parts of mathematics that are not neccesarily applicable outside of exercises. While working on a problem in Lean I reached out on the Zulip forum for help and one person who contributes to the programming of Lean responded that what I was looking for wasn’t included in Lean’s library because it was really only useful for exercises. Cutting things like this may be necessary to save time programming the language, but it is a shame that everything cannot be included. Some simpler aspects of mathematics are important steps in developing ones understanding of higher level topics and to expect anyone coming into Lean to already know high level mathematics seems nearsighted. If Lean is to become more widely accepted, those learning mathematics need to be able to learn and use it as they grow in mathematical ability. This could help lead to mathematicians who are able to take full advantage of the language and even potentially contribute to development of the language.</p>
</section>
<section id="the-future" class="level2">
<h2 class="anchored" data-anchor-id="the-future">The Future</h2>
<p>With Lean constantly expanding and growing more powerful, it could become easy enough to use that it becomes widely used. The scene of users is quite active right now, and its libraries are constantly being updated. Lean has even gained enough popularity that a few textbooks have been written about proving mathematical theorems using Lean. These vary in level of difficulty and some add their own libraries of theorems and definitions which are not included in the base installation of Lean. The <em>How To Prove It With Lean</em> textbook as well as <em>Mathematics in Lean</em> were both quite instrumental in learning the language and gaining a full grasp of Lean’s capabilities. <em>How To Prove It With Lean</em> makes some substantial changes to the base language which I believe makes it easier to use than the base language. Due to the added tactics and simpler syntax rules in this book, I would certainly recommend any new users start with this book. Once the basics have been understood, <em>Mathematics in Lean</em> goes back to the base language and takes the language into higher level mathematics such as topology and calculus. These books do a great job of teaching the language and some of the math at the same time, making it possible for those starting to learn mathematical proofs to start in Lean and learn to take full advantage of it. If Lean continues to be supported and expanded we could certainly see a greater acceptance and implementation into mainstream mathematics.</p>


<div id="refs" class="references csl-bib-body hanging-indent" role="list" style="display: none">
<div id="ref-Avigad_Massot" class="csl-entry" role="listitem">
Avigad, Jeremy, and Patrick Massot. 2020. <span>“Mathematics in Lean.”</span> <em>Mathematics in Lean - Mathematics in Lean 0.1 Documentation</em>. <a href="https://leanprover-community.github.io/mathematics_in_lean/index.html#">https://leanprover-community.github.io/mathematics_in_lean/index.html#</a>.
</div>
<div id="ref-Avigad_de_Moura_Kong_Ullrich" class="csl-entry" role="listitem">
Avigad, Jeremy, Leonardo de Moura, Soonho Kong, and Sebastian Ullrich. 2021. <span>“Theorem Proving in Lean 4.”</span> <em>Theorem Proving in Lean 4 - Theorem Proving in Lean 4</em>. <a href="https://lean-lang.org/theorem_proving_in_lean4/title_page.html">https://lean-lang.org/theorem_proving_in_lean4/title_page.html</a>.
</div>
<div id="ref-Christiansen" class="csl-entry" role="listitem">
Christiansen, David Thrane. 2023. <span>“Functional Programming in Lean.”</span> <em>Functional Programming in Lean - Functional Programming in Lean</em>. <a href="https://lean-lang.org/functional_programming_in_lean/title.html">https://lean-lang.org/functional_programming_in_lean/title.html</a>.
</div>
<div id="ref-Velleman" class="csl-entry" role="listitem">
Velleman, Daniel J. 2023. <em>How To Prove It With Lean</em>. <a href="https://djvelleman.github.io/HTPIwL/">https://djvelleman.github.io/HTPIwL/</a>.
</div>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Chap3.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Lean as a Theorem Prover</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./references.html" class="pagination-link">
        <span class="nav-page-text">Works Cited</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">Logan Johnson 2023</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>



</body></html>