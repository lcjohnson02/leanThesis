[
  {
    "objectID": "Chap3.html#differences-from-paragraph-style-proofs",
    "href": "Chap3.html#differences-from-paragraph-style-proofs",
    "title": "3  Lean as a Theorem Prover",
    "section": "Differences From Paragraph Style Proofs",
    "text": "Differences From Paragraph Style Proofs\nDespite the incredible power that lean could provide in the verification of mathematical proofs, this does pose some difficulties, namely the ease with which the aforementioned proofs can be written up. Typically, proofs are simply written up in a paragraph style, where the steps being taken and the theorems being applied are laid out in plain terms so that it can be easily understood by fellow mathematicians. There are often times when mathematicians will take things for granted or skip over steps that they think the reader will either already know to be fact or can easily reason out for themselves when writing out typical proofs. This lax approach for conveying information simply does not work when trying to communicate with technology, and a much more specific and methodical approach must be adopted in order to take advantage of the logical verification benefits. Thankfully, lean has a community working to create libraries of previously proven theorems that can be applied to speed up the writing and verification of future proofs. This thankfully means that all proofs do not need to be taken all the way back to basic axioms: Users can save time by avoiding proving adjacent theorems and instead focus only on the immediately relevant steps of their proof.\nFor each of the following proofs, I will first provide a typical “paragraph style” version of the proof, so the differences between the two can easily be compared."
  },
  {
    "objectID": "Chap3.html#inequality-addition",
    "href": "Chap3.html#inequality-addition",
    "title": "3  Lean as a Theorem Prover",
    "section": "Inequality Addition",
    "text": "Inequality Addition\n\nParagraph Style Proof\n\nIf \\(a &lt; b\\) and \\(c \\le d\\), prove that \\(a + c &lt; b + d\\)\n\nThere are multiple ways to approach this in a paragraph style proof, so I will attempt to have this proof follow along the same lines as the lean proof.\n\nProof. There are two possible cases: either \\(c = d\\) or \\(c &lt; d\\). We will first consider the case where \\(c = d\\). We know \\(a &lt; b\\), so it would also be true that \\(a + c &lt; b + c\\). Then because \\(c = d\\), \\(a + c &lt; b + d\\). Now consider the case where \\(c &lt; d\\). We know \\(a &lt; b\\), so \\(a + c &lt; b + c\\) and \\(b + c &lt; b + d\\) because \\(c &lt; d\\). Thus by transitivity of inequalities, we could say \\(a + c &lt; b + d\\)  □\n\n\n\nLean Proof\n\nSeting up the problem\nHere I put the theorem we want to prove into lean and we can see the resulting infoview panel. I name our two assumptions h1 and h2, for hypotheses one and two. After a colon I then write out the thing I am trying to prove with those hypotheses and use by to put lean into tactic mode.\nIt can now be seen that the infoview panel lists out both of our hypotheses as well as the goal we are working towards at the bottom. This panel will continue to change as more code is added to the lean file.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  \n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\n⊢ a + c &lt; b + d\n\n\n\n\nStep 1\nHere I lay out the two possible cases of our second hypothesis which allows me to strengthen the information that we know. We see this strengthened hypothesis reflected in h3 in the infoview.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: c = d\n⊢ a + c &lt; b + d\n\n\n\n\nStep 2\nHere I used hypothesis 3 to rewrite he c in our final goal as a d. This change is reflected in the infoview for this step.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: c = d\n⊢ a + d &lt; b + d\n\n\n\n\nStep 3\nIn this step I applied a theorem already in the Mathlib library for lean. The add_lt_add_right theorem simply states that if you have a b &lt; c, then b + a &lt; c + a which is exactly what we need to prove the goal for the first case. As the first case has been completed, the infoview then switches to the second case which is reflected in the new h3 and reset goal.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: ¬c = d\n⊢ a + c &lt; b + d\n\n\n\n\nStep 4\nIn order to better work with our new hypothesis, I use a tactic which pushes the negation symbol further into the thing it is negating. This results in a hypothesis which can actually be applied later on.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: c ≠ d\n⊢ a + c &lt; b + d\n\n\n\n\nStep 5\nHere I am laying out a new hypothesis which will be useful later in the proof. This hypothesis seems like an obvious conclusion based on hypotheses two and three, but we must still lay it out simply for lean if we want to actually use it. The infoview panel always displays the most current goal, which is why it is displaying the goal for h4 rather than the main goal.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n  have h4 : c &lt; d := by\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: c ≠ d\n⊢ c &lt; d\n\n\n\n\nStep 6\nHere I apply another theorem already in lean which takes the information h3 and h2 gives us and shows our current goal. Writing out h4 like this is technically optional, as lean allows you to evaluate tactics within arguments for other tactics. Despite this, I personally find it more convenient and clear to write out extra hypotheses like this rather than just giving the body of the argument when necessary. Now that our new hypothesis has been proven, the infoview displays that we have no goals until we get back into our main theorem.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n  have h4 : c &lt; d := by\n    apply Ne.lt_of_le h3 h2\n\n  **done::\n\n\nNo goals\n\n\n\n\nStep 7\nI now use the calc tactic to work through the rest of the theorem. This tactic is quite useful as it allows us to chain together multiple equalities or inequalities while still giving proofs for each step. This is essentially a shortcut of writing out individual hypotheses and then using the rewrite tactic to get our desired goal.\nIn this case, I only need to do two steps of chaining inequalities, where I use transitivity to show that the starting value is less than the final value. It essentially follows the same path as the paragraph style proof, where the tactics add_lt_add_right and add_lt_add_left justify the steps taken.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n  have h4 : c &lt; d := by\n    apply Ne.lt_of_le h3 h2\n  exact calc\n    a + c &lt; b + c := add_lt_add_right h1 c\n    _ &lt; b + d := add_lt_add_left h4 b\n  done\n\n\nNo goals"
  },
  {
    "objectID": "Chap3.html#a-is-less-than-or-equal-to-b",
    "href": "Chap3.html#a-is-less-than-or-equal-to-b",
    "title": "3  Lean as a Theorem Prover",
    "section": "a is Less Than or Equal to b",
    "text": "a is Less Than or Equal to b\n\nParagraph Style Proof\n\nSuppose that \\(a, b \\in \\mathbb{R}\\) and for every \\(\\varepsilon &gt; 0\\), we have \\(a \\le b + \\varepsilon\\). Show that \\(a \\le b\\).\n\n\nProof. Assume for the sake of contradiction that \\(a\\) is not less than or equal to \\(b\\). Then it would be true that \\(a &gt; b\\). Now consider the case where \\(\\varepsilon = \\frac{a - b}{2}.\\) Then since \\(a &gt; b\\), epsilon is positive and by our assumption then \\(a \\le b + \\varepsilon\\). Then \\[\\begin{align*}\na & \\le b + \\varepsilon \\\\\n& = b + \\frac{a - b}{2} \\\\\n& = b + \\frac{a}{2} - \\frac{b}{2} \\\\\n& = \\frac{a}{2} + \\frac{b}{2}.\n\\end{align*}\\] So now, \\[\\begin{align*}\na & \\le \\frac{a}{2} + \\frac{b}{2} \\\\\na - \\frac{a}{2} & \\le \\frac{b}{2} \\\\\n\\frac{a}{2} & \\le \\frac{b}{2} \\\\\na & \\le b.\n\\end{align*}\\] But now we have that \\(a \\le b\\) and \\(a &gt; b\\), a contradiction!  □\n\n\n\nLean Proof\n\nSetting up the problem\nI again set up the proof with our one hypothesis and the goal we want to prove. These are then seen listed in the infoview on the right.\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\n⊢ a ≤ b\n\n\n\n\nStep 1\nThe by_contra tactic allows me to complete this problem using proof by contradiction. This tactic automatically creates a hypothesis containing the negation of the final goal, I named it h2, and changes the final goal to False meaning that it needs a contradiction.\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: ¬a ≤ b\n⊢ False\n\n\n\n\nStep 2\nHere I use the push_neg tactic similarly to the previous example to het a usable version of h2 as well as pick a specific epsilon for which we will find a contradiction. This new epsilon will now show up in the infoview in the side and can be used in our problem.\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\n⊢ False\n\n\n\n\nStep 3\nHere I lay out a hypothesis that we will later be able to apply to h1. Saying that epsilon was positive in the paragraph style proof fairly simpler, where we only really need to justify that \\(a - b\\) is positive. In lean however, it requires a bit more effort and as such I put in its own hypothesis.\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n\n    **done::\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\n⊢ ε &gt; 0\n\n\n\n\nStep 4\nAnyone reading a paragraph style proof such as ours would know that dividing a number by two does not impact whether the resulting number if positive or negative, but it still needs to be justified to lean. As such, I use the half_pos theorem with the refine tactic to change the goal to what is currently shown in the infoview. The refine tactic is useful because it tries to apply the arguments it is given to the final goal and change the goal to whatever is needed to meet the hypotheses in the arguments. In this case, half_pos claims that if you have some \\(a &gt; 0.\\) then \\(\\frac{a}{2} &gt; 0.\\) The refine tactic then applies the result of that theorem and leaves us to show that \\(a &gt; 0,\\) and lean is smart enough to figure out that we actually need to show \\(a - b &gt; 0.\\)\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n\n      **done::\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\n⊢ 0 &lt; a - b\n\n\n\n\nStep 5\nThe theorem I uses our second hypothesis to show that \\(a - b &gt; 0,\\) which finishes the proof for our third hypothesis and the goal switches back to finding a contradiction.\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n    exact Iff.mpr sub_pos h2\n    done\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\nh3: ε &gt; 0\n⊢ False\n\n\n\n\nStep 6\nI now try to lay out the fourth and final hypothesis which will be used to find a contradiction with h2. This is another example of something being quickly explained in the paragraph style proof, but being more cumbersome to justify within lean.\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n    exact Iff.mpr sub_pos h2\n    done\n  have h4 : a ≤ b + ε := by\n\n    **done::\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\nh3: ε &gt; 0\n⊢ a ≤ b + ε\n\n\n\n\nStep 7\nI first apply h1 which works has a similar effect as using the refine tactic earler: it applies to result of an if then statement and changes our goal to the if.\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n    exact Iff.mpr sub_pos h2\n    done\n  have h4 : a ≤ b + ε := by\n    apply h1\n\n    **done::\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\nh3: ε &gt; 0\n⊢ ε &gt; 0\n\n\n\n\nStep 8\nNow that our goal has been properly modified, h3 is the only other thing necessary to justify this hypothesis.\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n    exact Iff.mpr sub_pos h2\n    done\n  have h4 : a ≤ b + ε := by\n    apply h1\n    apply h3\n    done\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\nh3: ε &gt; 0\nh4: a ≤ b + ε\n⊢ False\n\n\n\n\nStep 9\nThis dsimp tactic will do its best to automatically simplify anything it is given, in this case it substitutes our specific epsilon value in for the arbitrary epsilon. This will now allow us to use h4 to find our contradiction.\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n    exact Iff.mpr sub_pos h2\n    done\n  have h4 : a ≤ b + ε := by\n    apply h1\n    apply h3\n    done\n  dsimp at h4\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\nh3: ε &gt; 0\nh4: a ≤ b + (a - b) / 2\n⊢ False\n\n\n\n\nStep 10\nThe linarith tactic is quite powerful as it will attempt to simplify the goal as well as hypotheses and then look for a contradiction amongst the known hypotheses. This is one example where lean actually requires quite a bit less explanation than a typical proof. The majority of my paragraph style proof above was spent simplifying and manipulating h4 and h2, whereas in lean I need to specify none of that! It is quite impressive that lean is already able to do so much simplification and even find contradictions with no user input. This ability will likely only increase in power in the future, and some developments have even occured during the planning and writing of this thesis that make other simplification tactics substantially more powerful.\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n    exact Iff.mpr sub_pos h2\n    done\n  have h4 : a ≤ b + ε := by\n    apply h1\n    apply h3\n    done\n  dsimp at h4\n  linarith\n  done\n\n\nNo goals"
  },
  {
    "objectID": "Chap3.html#absolute-convergence",
    "href": "Chap3.html#absolute-convergence",
    "title": "3  Lean as a Theorem Prover",
    "section": "Absolute Convergence",
    "text": "Absolute Convergence\n\nParagraph Style Proof\n\nSome words\n\n\nProof. Some more words  □\n\n\n\nLean Proof\n\nSetting up the problem\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n\n  **done::\n\n\ns1: ℕ → ℝ\n⊢ ConvergesTo s1 0 \n&gt;&gt;  ↔ ConvergesTo |s1| 0\n\n\n\n\nStep 1\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n\n  **done::\n\n\ns1: ℕ → ℝ\n⊢ (∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |s1 n - 0| &lt; ε) ↔\n&gt;&gt;    ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |abs s1 n - 0| &lt; ε\n\n\n\n\nStep 2\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    \n    done\n\n  **done::\n\n\ns1: ℕ → ℝ\nx: ℕ\n⊢ |s1 x| = |abs s1 x|\n\n\n\n\nStep 3\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\n⊢ (∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |s1 n - 0| &lt; ε) ↔\n&gt;&gt;    ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |abs s1 n - 0| &lt; ε\n\n\n\n\nStep 4\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\n⊢ (∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |s1 n - 0| &lt; ε) →\n&gt;&gt;    ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |abs s1 n - 0| &lt; ε\n\n\n\n\nStep 5\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  ∃ N, ∀ (n : ℕ), \n&gt;&gt;  n ≥ N → |s1 n - 0| &lt; ε\n⊢ ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |abs s1 n - 0| &lt; ε\n\n\n\n\nStep 6\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  ∃ N, ∀ (n : ℕ), \n&gt;&gt;  n ≥ N → |s1 n - 0| &lt; ε\n⊢ ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    N ≤ n → \n&gt;&gt;    |abs s1 n| &lt; ε\n\n\n\n\nStep 7\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n    simp at h1\n\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\nh1: ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;  ∃ N, ∀ (n : ℕ), \n&gt;&gt;  N ≤ n → |s1 n| &lt; ε\n⊢ ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    N ≤ n → \n&gt;&gt;    |abs s1 n| &lt; ε\n\n\n\n\nStep 8\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n    simp at h1\n    simp [← h3]\n\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\nh1: ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;  ∃ N, ∀ (n : ℕ), \n&gt;&gt;  N ≤ n → |s1 n| &lt; ε\n⊢ ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    N ≤ n → \n&gt;&gt;    |s1 n| &lt; ε\n\n\n\n\nStep 9\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n    simp at h1\n    simp [← h3]\n    apply h1\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\n⊢ (∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |abs s1 n - 0| &lt; ε) →\n&gt;&gt;    ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |s1 n - 0| &lt; ε\n\n\n\n\nStep 10\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n    simp at h1\n    simp [← h3]\n    apply h1\n  · --Reverse\n    intro h1\n    simp\n    simp at h1\n    simp_rw [h3]\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\nh1: ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;  ∃ N, ∀ (n : ℕ), \n&gt;&gt;  N ≤ n → |abs s1 n| &lt; ε\n⊢ ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;    ∃ N, ∀ (n : ℕ),\n&gt;&gt;    N ≤ n → \n&gt;&gt;    |abs s1 n| &lt; ε\n\n\n\n\nStep 11\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n    simp at h1\n    simp [← h3]\n    apply h1\n  · --Reverse\n    intro h1\n    simp\n    simp at h1\n    simp_rw [h3]\n    apply h1\n  done\n\n\nNo goals"
  },
  {
    "objectID": "Chap3.html#convergence-of-a-specific-sequence",
    "href": "Chap3.html#convergence-of-a-specific-sequence",
    "title": "3  Lean as a Theorem Prover",
    "section": "Convergence of a Specific Sequence",
    "text": "Convergence of a Specific Sequence\nThe following is an example of one situation where lean is somewhat lacking in comparison to a paragraph style proof. The paragraph style proof is able to quickly and easily prove the desired end goal, but lean has to work around a lot of the simple rewriting we would do in a normal proof. In this attempt to prove the convergence of a specific sequence, there were many issues with simplifying involving arbitrary variables and the change from natural numbers to real numbers. These sorts of things can be easily explained in a paragraph style proof, but required significant work to prove in lean.\nLean internally defines limits using filters and topology rather than the real analysis approach of epsilons, so the approach I was taking here is not the optimal approach for theorems involving limits in lean. While this high level definition of a limit is very useful for the people who know how to use it, it makes lean more difficult to use for those who have not yet studied topology. Definitions such as this start to portray that lean is not really something meant to be used for lower level mathematics, but rather complex and high level proofs.\n\nParagraph Style Proof\n\nEven more words\n\n\nProof. Finally, words  □\n\n\n\nLean Proof\nexample : ConvergesTo (fun (n : ℕ) ↦ \n    ((2 * n) / (n + 1))) 2 := by\n  intro ε\n  intro h1\n  obtain ⟨k, h13⟩ := \n    exists_nat_gt (2 / ε - 1) --Archimedean Property\n  use k\n  intro n\n  intro h2\n  dsimp\n  have h3 : (2 : ℝ) = 2 * ((n + 1) / (n + 1)) := by\n    have h4 : ((n + 1) / (n + 1)) = \n        (n + 1) * ((n + 1) : ℝ)⁻¹ := by\n      rfl\n      done\n    rw [h4]\n    have h5 : (n + 1) * ((n + 1) : ℝ)⁻¹ = 1 := by\n      rw [mul_inv_cancel]\n      exact Nat.cast_add_one_ne_zero n\n      done\n    rw [h5]\n    exact Eq.symm (mul_one 2)\n    done\n  nth_rewrite 2 [h3]\n  have h6 : 2 * ((↑n + 1) : ℝ) / (↑n + 1) = \n      ((2 * n) + 2) / (n + 1) := by\n    rw [Distribute n]\n    done\n  have h7 : 2 * (((↑n + 1) : ℝ) / (↑n + 1)) = \n      2 * (↑n + 1) / (↑n + 1) := by\n    rw [← mul_div_assoc 2 ((n + 1) : ℝ) ((n + 1) : ℝ)]\n    done\n  rw [h7]\n  rw [h6]\n  rw [div_sub_div_same (2 * n : ℝ) (2 * n + 2) (n + 1)]\n  rw [sub_add_cancel']\n  rw [abs_div]\n  simp\n  have h8 : |(↑n + 1 : ℝ)| = ↑n + 1 := by\n    simp\n    apply LT.lt.le (Nat.cast_add_one_pos ↑n)\n    done\n  rw [h8]\n  have h9 : (2 : ℝ) / (↑n + 1) ≤ 2 / (k + 1) := by\n    apply div_le_div_of_le_left\n    · --case 1\n      linarith\n      done\n    · --case 2\n      exact Nat.cast_add_one_pos k\n      done\n    · --case 3\n      convert add_le_add_right h2 1\n      apply Iff.intro\n      · --subcase 1\n        exact fun a =&gt; Nat.add_le_add_right h2 1\n        done\n      · --subcase 2\n        intro h14\n        apply add_le_add_right\n        exact Iff.mpr Nat.cast_le h2\n        done\n      done\n    done\n  have h10 : 2 / (k + 1) &lt; 2 / (2 / ε - 1 + 1) := by\n    apply div_lt_div_of_lt_left\n    · --case 1\n      linarith\n      done\n    · --case 2\n      simp\n      apply div_pos\n      linarith\n      apply h1\n      done\n    · --case 3\n      convert add_le_add_right h2 1\n      apply Iff.intro\n      · --subcase 1\n        intro h11\n        exact Nat.add_le_add_right h2 1\n        done\n      · --subcase 2\n        intro h11\n        have h12 : 2 / ε - 1 &lt; (k : ℝ) := by\n          simp only []\n          apply h13\n          done\n        exact add_lt_add_right h12 1\n        done\n      done\n    done\n  calc\n    2 / (↑n + 1) ≤ (2 : ℝ) / (k + 1) := by\n      apply h9\n      done\n    _ &lt; (2 : ℝ) / (2 / ε - 1 + 1) := by\n      apply h10\n      done\n    _ = ε := by\n      ring_nf\n      apply inv_inv\n      done\n  done"
  },
  {
    "objectID": "Chap1.html",
    "href": "Chap1.html",
    "title": "1  Real Analysis",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$"
  },
  {
    "objectID": "Chap2.html",
    "href": "Chap2.html",
    "title": "2  Functional Programming",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$"
  },
  {
    "objectID": "Chap4.html",
    "href": "Chap4.html",
    "title": "4  Conclusions",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\nUltimately lean is an incredibly powerful tool which does provide the valuable proof verification benefits which make learning the language worthwhile."
  },
  {
    "objectID": "Chap5.html",
    "href": "Chap5.html",
    "title": "5  Works Cited",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\nThis work had been formatted and styled from the book How To Prove It With Lean, written by Daniel J. Velleman. How To Prove It With Lean contains short excerpts from How To Prove It: A Structured Approach, 3rd Edition, by Daniel J. Velleman and published by Cambridge University Press."
  },
  {
    "objectID": "Chap6.html",
    "href": "Chap6.html",
    "title": "6  Additional space",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\nExtra chapter to write more things if needed!!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Untitled Lean Thesis",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\n\nPreface"
  }
]