[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Untitled Lean Thesis",
    "section": "",
    "text": "Preface\nI will not do my homework today.\nsum(4, 7, 3)\n\n[1] 14\nHello World"
  },
  {
    "objectID": "index.html#making-chapters",
    "href": "index.html#making-chapters",
    "title": "Untitled Lean Thesis",
    "section": "Making Chapters",
    "text": "Making Chapters\nI am using this section to figure out how to incorporate a table of contents and different sections/chapters of the paper. This should prove useful in the final thesis and allow readers to quickly jump to important or interesting sections."
  },
  {
    "objectID": "index.html#incorporating-some-code",
    "href": "index.html#incorporating-some-code",
    "title": "Untitled Lean Thesis",
    "section": "Incorporating Some Code",
    "text": "Incorporating Some Code\nI will also be able to use some LaTeX equations within the document which could halp to make the paper look quite nice.\nIf \\(a &lt; b\\) and \\(c \\le d\\), prove that \\(a + c \\le b + d\\). It just so happens that I was able to prove this using lean!\nexample (a b c d : ℝ) (h1: a &lt; b) (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n  have h4 : c &lt; d := by\n    apply Ne.lt_of_le h3 h2\n  apply add_lt_add h1 h4\n  done\nNow to display the benefits of the lean infoview!"
  },
  {
    "objectID": "index.html#showing-the-infoview-with-picture-sequences",
    "href": "index.html#showing-the-infoview-with-picture-sequences",
    "title": "Untitled Lean Thesis",
    "section": "Showing the Infoview with Picture Sequences",
    "text": "Showing the Infoview with Picture Sequences\nNot going to do this now as I think the columns are far superior."
  },
  {
    "objectID": "index.html#showing-infoview-with-columns",
    "href": "index.html#showing-infoview-with-columns",
    "title": "Untitled Lean Thesis",
    "section": "Showing Infoview with Columns",
    "text": "Showing Infoview with Columns\nAs we can clearly see, this is the first step of the code and it can now be explained with great ease. Now onto the next step!\n\n\ntheorem Example_3_2_4_v2 (P Q R : Prop)\n    (h : P → (Q → R)) : ¬R → (P → ¬Q) := by\n  assume h2 : ¬R\n  assume h3 : P\n  **done::\n\n\nP Q R : Prop\nh : P → Q → R\nh2 : ¬R\nh3 : P\n⊢ ¬Q\n\n\nClick on the Extensions icon on the left side of the window, which is circled in red in the image above. That will bring up a list of available extensions:"
  },
  {
    "objectID": "index.html#acknowledgments",
    "href": "index.html#acknowledgments",
    "title": "Untitled Lean Thesis",
    "section": "Acknowledgments",
    "text": "Acknowledgments"
  },
  {
    "objectID": "Chap1.html",
    "href": "Chap1.html",
    "title": "1  Real Analysis",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\n\n\n\n\nSymbol\nMeaning\n\n\n\n\n\\(\\neg\\)\nnot\n\n\n\\(\\wedge\\)\nand\n\n\n\\(\\vee\\)\nor\n\n\n\\(\\to\\)\nif … then\n\n\n\\(\\leftrightarrow\\)\niff (that is, if and only if)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\n\nEquivalence\n\n\n\n\n\nDe Morgan’s Laws\n\\(\\neg (P \\wedge Q)\\)\nis equivalent to\n\\(\\neg P \\vee \\neg Q\\)\n\n\n\n\\(\\neg (P \\vee Q)\\)\nis equivalent to\n\\(\\neg P \\wedge \\neg Q\\)\n\n\nDouble Negation Law\n\\(\\neg\\neg P\\)\nis equivalent to\n\\(P\\)\n\n\nConditional Laws\n\\(P \\to Q\\)\nis equivalent to\n\\(\\neg P \\vee Q\\)\n\n\n\n\\(P \\to Q\\)\nis equivalent to\n\\(\\neg(P \\wedge \\neg Q)\\)\n\n\nContrapositive Law\n\\(P \\to Q\\)\nis equivalent to\n\\(\\neg Q \\to \\neg P\\)\n\n\n\n\n\n\\(A \\cap B = \\{x \\mid x \\in A \\wedge x \\in B\\} = {}\\) the intersection of \\(A\\) and \\(B\\),\n\\(A \\cup B = \\{x \\mid x \\in A \\vee x \\in B\\} = {}\\) the union of \\(A\\) and \\(B\\),\n\\(A \\setmin B = \\{x \\mid x \\in A \\wedge x \\notin B\\} = {}\\) the difference of \\(A\\) and \\(B\\),\n\\(A \\symmdiff B = (A \\setmin B) \\cup (B \\setmin A) = {}\\) the symmetric difference of \\(A\\) and \\(B\\)."
  },
  {
    "objectID": "Chap2.html",
    "href": "Chap2.html",
    "title": "2  Functional Programming",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\n\n\\(\\forall x\\,P(x)\\) means “for all \\(x\\), \\(P(x)\\),”\n\n\n\n\n\n\nQuantifier Negation Laws\n\n\n\n\n\n\\(\\neg \\exists x\\,P(x)\\)\nis equivalent to\n\\(\\forall x\\,\\neg P(x)\\)\n\n\n\\(\\neg \\forall x\\,P(x)\\)\nis equivalent to\n\\(\\exists x\\,\\neg P(x)\\)"
  },
  {
    "objectID": "Chap3.html#differences-from-paragraph-style-proofs",
    "href": "Chap3.html#differences-from-paragraph-style-proofs",
    "title": "3  Lean as a Theorem Prover",
    "section": "Differences From Paragraph Style Proofs",
    "text": "Differences From Paragraph Style Proofs\nDespite the incredible power that lean could provide in the verification of mathematical proofs, this does pose some difficulties, namely the ease with which the aforementioned proofs can be written up. Typically, proofs are simply written up in a paragraph style, where the steps being taken and the theorems being applied are laid out in plain terms so that it can be easily understood by fellow mathematicians. There are often times when mathematicians will take things for granted or skip over steps that they think the reader will either already know to be fact or can easily reason out for themselves when writing out typical proofs. This lax approach for conveying information simply does not work when trying to communicate with technology, and a much more specific and methodical approach must be adopted in order to take advantage of the logical verification benefits. Thankfully, lean has a community working to create libraries of previously proven theorems that can be applied to speed up the writing and verification of future proofs. This thankfully means that all proofs do not need to be taken all the way back to basic axioms: Users can save time by avoiding proving adjacent theorems and instead focus only on the immediately relevant steps of their proof."
  },
  {
    "objectID": "Chap3.html#inequality-addition",
    "href": "Chap3.html#inequality-addition",
    "title": "3  Lean as a Theorem Prover",
    "section": "Inequality Addition",
    "text": "Inequality Addition\nStep 1 Putting the initial theorem we want to show in lean code and observing the final goal in the infoview.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  \n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\n⊢ a + c &lt; b + d\n\n\nStep 2\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: c = d\n⊢ a + c &lt; b + d\n\n\nStep 3\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: c = d\n⊢ a + d &lt; b + d\n\n\nStep 4\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: ¬c = d\n⊢ a + c &lt; b + d\n\n\nStep 5\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: c ≠ d\n⊢ a + c &lt; b + d\n\n\nStep 6a We can see here that the lean infoview is now displaying my new hypothesis as the current goal.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n  have h4 : c &lt; d := by\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: c ≠ d\n⊢ c &lt; d\n\n\nStep 6b\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n  have h4 : c &lt; d := by\n    apply Ne.lt_of_le h3 h2\n\n  **done::\n\n\nNo goals\n\n\nStep 7\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n  have h4 : c &lt; d := by\n    apply Ne.lt_of_le h3 h2\n  apply add_lt_add h1 h4\n  done\n\n\nNo goals"
  },
  {
    "objectID": "Chap3.html#absolute-convergence",
    "href": "Chap3.html#absolute-convergence",
    "title": "3  Lean as a Theorem Prover",
    "section": "Absolute Convergence",
    "text": "Absolute Convergence\nI will now display how I used to lean to demonstrate that a sequence converges if and only if the absolute value of that sequence converges.\nLaying out the goal\n\n\nexample (s1 : ℕ → ℝ) : ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) := by\n\n  **done::\n\n\ns1: ℕ → ℝ\n⊢ ConvergesTo s1 0 ↔ ConvergesTo |s1| 0\n\n\nStep 1\n\n\nexample (s1 : ℕ → ℝ) : ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n\n  **done::\n\n\ns1: ℕ → ℝ\n⊢ (∀ (ε : ℝ), ε &gt; 0 → ∃ N, ∀ (n : ℕ), n ≥ N → |s1 n - 0| &lt; ε) ↔\n  ∀ (ε : ℝ), ε &gt; 0 → ∃ N, ∀ (n : ℕ), n ≥ N → |abs s1 n - 0| &lt; ε\n\n\nStep 2\n\n\nexample (s1 : ℕ → ℝ) : ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = |abs s1 x| := by\n    \n    done\n\n  **done::\n\n\ns1: ℕ → ℝ\nx: ℕ\n⊢ |s1 x| = |abs s1 x|\n\n\nStep 3\n\n\nexample (s1 : ℕ → ℝ) : ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = |abs s1 x| := by\n    simp [abs]\n    done\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = |abs s1 x|\n⊢ (∀ (ε : ℝ), ε &gt; 0 → ∃ N, ∀ (n : ℕ), n ≥ N → |s1 n - 0| &lt; ε) ↔\n  ∀ (ε : ℝ), ε &gt; 0 → ∃ N, ∀ (n : ℕ), n ≥ N → |abs s1 n - 0| &lt; ε\n\n\nStep 4\n\n\nexample (s1 : ℕ → ℝ) : ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = |abs s1 x|\n⊢ (∀ (ε : ℝ), ε &gt; 0 → ∃ N, ∀ (n : ℕ), n ≥ N → |s1 n - 0| &lt; ε) →\n  ∀ (ε : ℝ), ε &gt; 0 → ∃ N, ∀ (n : ℕ), n ≥ N → |abs s1 n - 0| &lt; ε\n\n\nStep 5\n\n\nexample (s1 : ℕ → ℝ) : ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = |abs s1 x|\nh1: ∀ (ε : ℝ), ε &gt; 0 → ∃ N, ∀ (n : ℕ), n ≥ N → |s1 n - 0| &lt; ε\n⊢ ∀ (ε : ℝ), ε &gt; 0 → ∃ N, ∀ (n : ℕ), n ≥ N → |abs s1 n - 0| &lt; ε\n\n\nStep 6\n\n\nexample (s1 : ℕ → ℝ) : ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = |abs s1 x|\nh1: ∀ (ε : ℝ), ε &gt; 0 → ∃ N, ∀ (n : ℕ), n ≥ N → |s1 n - 0| &lt; ε\n⊢ ∀ (ε : ℝ), 0 &lt; ε → ∃ N, ∀ (n : ℕ), N ≤ n → |abs s1 n| &lt; ε\n\n\nStep 7\n\n\nexample (s1 : ℕ → ℝ) : ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n    simp at h1\n\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = |abs s1 x|\nh1: ∀ (ε : ℝ), 0 &lt; ε → ∃ N, ∀ (n : ℕ), N ≤ n → |s1 n| &lt; ε\n⊢ ∀ (ε : ℝ), 0 &lt; ε → ∃ N, ∀ (n : ℕ), N ≤ n → |abs s1 n| &lt; ε\n\n\nStep 8\n\n\nexample (s1 : ℕ → ℝ) : ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n    simp at h1\n    simp [← h3]\n\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = |abs s1 x|\nh1: ∀ (ε : ℝ), 0 &lt; ε → ∃ N, ∀ (n : ℕ), N ≤ n → |s1 n| &lt; ε\n⊢ ∀ (ε : ℝ), 0 &lt; ε → ∃ N, ∀ (n : ℕ), N ≤ n → |s1 n| &lt; ε\n\n\nStep 9\n\n\nexample (s1 : ℕ → ℝ) : ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n    simp at h1\n    simp [← h3]\n    apply h1\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = |abs s1 x|\n⊢ (∀ (ε : ℝ), ε &gt; 0 → ∃ N, ∀ (n : ℕ), n ≥ N → |abs s1 n - 0| &lt; ε) →\n  ∀ (ε : ℝ), ε &gt; 0 → ∃ N, ∀ (n : ℕ), n ≥ N → |s1 n - 0| &lt; ε\n\n\nStep 10\n\n\nexample (s1 : ℕ → ℝ) : ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n    simp at h1\n    simp [← h3]\n    apply h1\n  · --Reverse\n    intro h1\n    simp\n    simp at h1\n    simp_rw [h3]\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = |abs s1 x|\nh1: ∀ (ε : ℝ), 0 &lt; ε → ∃ N, ∀ (n : ℕ), N ≤ n → |abs s1 n| &lt; ε\n⊢ ∀ (ε : ℝ), 0 &lt; ε → ∃ N, ∀ (n : ℕ), N ≤ n → |abs s1 n| &lt; ε\n\n\nStep 11\n\n\nexample (s1 : ℕ → ℝ) : ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n    simp at h1\n    simp [← h3]\n    apply h1\n  · --Reverse\n    intro h1\n    simp\n    simp at h1\n    simp_rw [h3]\n    apply h1\n  done\n\n\nNo goals"
  },
  {
    "objectID": "Chap3.html#perhaps-a-third-great-example",
    "href": "Chap3.html#perhaps-a-third-great-example",
    "title": "3  Lean as a Theorem Prover",
    "section": "Perhaps a Third Great Example??",
    "text": "Perhaps a Third Great Example??\n\nTo prove a goal of the form P → Q:\n\nAssume P is true and prove Q.\nAssume Q is false and prove that P is false.\n\n\n\n&gt;&gt; ⋮\n⊢ P → Q\n\n\n&gt;&gt; ⋮\nh : P\n⊢ Q\n\n\n\n\n\n\nQ\n¬Q\n(Q\n→\nFalse)\n\n\n\n\nF\nT\nF\nT\n    F\n\n\nT\nF\nT\nF\n    F\n\n\n\n\n\n\ntheorem Example_3_2_4_v2 (P Q R : Prop)\n    (h : P → (Q → R)) : ¬R → (P → ¬Q) := by\n  assume h2 : ¬R\n  assume h3 : P\n  **done::\n\n\nP Q R : Prop\nh : P → Q → R\nh2 : ¬R\nh3 : P\n⊢ ¬Q\n\n\n\n\nExercises\nFill in proofs of the following theorems. All of them are based on exercises in HTPI.\n\ntheorem Exercise_3_2_1a (P Q R : Prop)\n    (h1 : P → Q) (h2 : Q → R) : P → R := by\n  \n  **done::\n\n\ntheorem Exercise_3_2_1b (P Q R : Prop)\n    (h1 : ¬R → (P → ¬Q)) : P → (Q → R) := by\n  \n  **done::\n\n\ntheorem Exercise_3_2_2a (P Q R : Prop)\n    (h1 : P → Q) (h2 : R → ¬Q) : P → ¬R := by\n  \n  **done::\n\n\ntheorem Exercise_3_2_2b (P Q : Prop)\n    (h1 : P) : Q → ¬(Q → ¬P) := by\n  \n  **done::"
  },
  {
    "objectID": "Chap3.html#proofs-involving-quantifiers",
    "href": "Chap3.html#proofs-involving-quantifiers",
    "title": "3  Lean as a Theorem Prover",
    "section": "3.3. Proofs Involving Quantifiers",
    "text": "3.3. Proofs Involving Quantifiers\n\nLet x stand for an arbitrary object of type U and prove P x. If the letter x is already being used in the proof to stand for something, then you must choose an unused variable, say y, to stand for the arbitrary object, and prove P y.\n\n\n\n\n\n\nquant_neg Tactic\n\n\n\n\n\n¬∀ (x : U), P x\nis changed to\n∃ (x : U), ¬P x\n\n\n¬∃ (x : U), P x\nis changed to\n∀ (x : U), ¬P x\n\n\n∀ (x : U), P x\nis changed to\n¬∃ (x : U), ¬P x\n\n\n∃ (x : U), P x\nis changed to\n¬∀ (x : U), ¬P x\n\n\n\n\n\nSuppose \\(B\\) is a set and \\(\\mathcal{F}\\) is a family of sets. If \\(\\bigcup\\mathcal{F} \\subseteq B\\) then \\(\\mathcal{F} \\subseteq \\mathscr{P}(B)\\).\n\n\nProof. Suppose \\(\\bigcup \\mathcal{F} \\subseteq B\\). Let \\(x\\) be an arbitrary element of \\(\\mathcal{F}\\). Let \\(y\\) be an arbitrary element of \\(x\\). Since \\(y \\in x\\) and \\(x \\in \\mathcal{F}\\), by the definition of \\(\\bigcup \\mathcal{F}\\), \\(y \\in \\bigcup \\mathcal{F}\\). But then since \\(\\bigcup \\mathcal{F} \\subseteq B\\), \\(y \\in B\\). Since \\(y\\) was an arbitrary element of \\(x\\), we can conclude that \\(x \\subseteq B\\), so \\(x \\in \\mathscr{P}(B)\\). But \\(x\\) was an arbitrary element of \\(\\mathcal{F}\\), so this shows that \\(\\mathcal{F} \\subseteq \\mathscr{P}(B)\\), as required.  □\n\n\nFor every integer \\(n\\), \\(6 \\mid n\\) iff \\(2 \\mid n\\) and \\(3 \\mid n\\).\n\n\nProof. Let \\(n\\) be an arbitrary integer.\n(\\(\\to\\)) Suppose \\(6 \\mid n\\). Then we can choose an integer \\(k\\) such that \\(6k=n\\). Therefore \\(n = 6k = 2(3k)\\), so \\(2 \\mid n\\), and similarly \\(n = 6k = 3(2k)\\), so \\(3 \\mid n\\).\n(\\(\\leftarrow\\)) Suppose \\(2 \\mid n\\) and \\(3 \\mid n\\). Then we can choose integers \\(j\\) and \\(k\\) such that \\(n = 2j\\) and \\(n = 3k\\). Therefore \\(6(j-k) = 6j - 6k = 3(2j) - 2(3k) = 3n - 2n = n\\), so \\(6 \\mid n\\).  □\n\n\n\n\nFor the next exercise you will need the following definitions:"
  },
  {
    "objectID": "Chap4.html",
    "href": "Chap4.html",
    "title": "4  Conclusions",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\n\\[\n[x]_R = \\{y \\in A \\mid yRx\\}.\n\\] The set whose elements are all of these equivalence classes is called \\(A\\) mod \\(R\\). It is written \\(A/R\\), so \\[\nA/R = \\{[x]_R \\mid x \\in A\\}.\n\\] Note that \\(A/R\\) is a set whose elements are sets: for each \\(x \\in A\\), \\([x]_R\\) is a subset of \\(A\\), and \\([x]_R \\in A/R\\)."
  },
  {
    "objectID": "Chap5.html",
    "href": "Chap5.html",
    "title": "5  Works Cited",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\nThis work had been formatted and styled from the book How To Prove It With Lean, written by Daniel J. Velleman. How To Prove It With Lean contains short excerpts from How To Prove It: A Structured Approach, 3rd Edition, by Daniel J. Velleman and published by Cambridge University Press.\nexample : square1 = square2 := by rfl\n\n++#eval:: square1 7     --Answer: 49"
  },
  {
    "objectID": "Chap6.html",
    "href": "Chap6.html",
    "title": "6  Additional space",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\nExtra chapter to write more things if needed!!"
  }
]