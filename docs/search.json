[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Untitled Lean Thesis",
    "section": "",
    "text": "Preface\nI will not do my homework today.\nsum(4, 7, 3)\n\n[1] 14\nHello World"
  },
  {
    "objectID": "index.html#making-chapters",
    "href": "index.html#making-chapters",
    "title": "Untitled Lean Thesis",
    "section": "Making Chapters",
    "text": "Making Chapters\nI am using this section to figure out how to incorporate a table of contents and different sections/chapters of the paper. This should prove useful in the final thesis and allow readers to quickly jump to important or interesting sections."
  },
  {
    "objectID": "index.html#incorporating-some-code",
    "href": "index.html#incorporating-some-code",
    "title": "Untitled Lean Thesis",
    "section": "Incorporating Some Code",
    "text": "Incorporating Some Code\nI will also be able to use some LaTeX equations within the document which could halp to make the paper look quite nice.\nIf \\(a &lt; b\\) and \\(c \\le d\\), prove that \\(a + c \\le b + d\\). It just so happens that I was able to prove this using lean!\nexample (a b c d : ℝ) (h1: a &lt; b) (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n  have h4 : c &lt; d := by\n    apply Ne.lt_of_le h3 h2\n  apply add_lt_add h1 h4\n  done\nNow to display the benefits of the lean infoview!"
  },
  {
    "objectID": "index.html#showing-the-infoview-with-picture-sequences",
    "href": "index.html#showing-the-infoview-with-picture-sequences",
    "title": "Untitled Lean Thesis",
    "section": "Showing the Infoview with Picture Sequences",
    "text": "Showing the Infoview with Picture Sequences\nNot going to do this now as I think the columns are far superior."
  },
  {
    "objectID": "index.html#showing-infoview-with-columns",
    "href": "index.html#showing-infoview-with-columns",
    "title": "Untitled Lean Thesis",
    "section": "Showing Infoview with Columns",
    "text": "Showing Infoview with Columns\nAs we can clearly see, this is the first step of the code and it can now be explained with great ease. Now onto the next step!\n\n\ntheorem Example_3_2_4_v2 (P Q R : Prop)\n    (h : P → (Q → R)) : ¬R → (P → ¬Q) := by\n  assume h2 : ¬R\n  assume h3 : P\n  **done::\n\n\nP Q R : Prop\nh : P → Q → R\nh2 : ¬R\nh3 : P\n⊢ ¬Q\n\n\nClick on the Extensions icon on the left side of the window, which is circled in red in the image above. That will bring up a list of available extensions:"
  },
  {
    "objectID": "index.html#acknowledgments",
    "href": "index.html#acknowledgments",
    "title": "Untitled Lean Thesis",
    "section": "Acknowledgments",
    "text": "Acknowledgments"
  },
  {
    "objectID": "Chap1.html",
    "href": "Chap1.html",
    "title": "1  Real Analysis",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\n\n\n\n\nSymbol\nMeaning\n\n\n\n\n\\(\\neg\\)\nnot\n\n\n\\(\\wedge\\)\nand\n\n\n\\(\\vee\\)\nor\n\n\n\\(\\to\\)\nif … then\n\n\n\\(\\leftrightarrow\\)\niff (that is, if and only if)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\n\nEquivalence\n\n\n\n\n\nDe Morgan’s Laws\n\\(\\neg (P \\wedge Q)\\)\nis equivalent to\n\\(\\neg P \\vee \\neg Q\\)\n\n\n\n\\(\\neg (P \\vee Q)\\)\nis equivalent to\n\\(\\neg P \\wedge \\neg Q\\)\n\n\nDouble Negation Law\n\\(\\neg\\neg P\\)\nis equivalent to\n\\(P\\)\n\n\nConditional Laws\n\\(P \\to Q\\)\nis equivalent to\n\\(\\neg P \\vee Q\\)\n\n\n\n\\(P \\to Q\\)\nis equivalent to\n\\(\\neg(P \\wedge \\neg Q)\\)\n\n\nContrapositive Law\n\\(P \\to Q\\)\nis equivalent to\n\\(\\neg Q \\to \\neg P\\)\n\n\n\n\n\n\\(A \\cap B = \\{x \\mid x \\in A \\wedge x \\in B\\} = {}\\) the intersection of \\(A\\) and \\(B\\),\n\\(A \\cup B = \\{x \\mid x \\in A \\vee x \\in B\\} = {}\\) the union of \\(A\\) and \\(B\\),\n\\(A \\setmin B = \\{x \\mid x \\in A \\wedge x \\notin B\\} = {}\\) the difference of \\(A\\) and \\(B\\),\n\\(A \\symmdiff B = (A \\setmin B) \\cup (B \\setmin A) = {}\\) the symmetric difference of \\(A\\) and \\(B\\)."
  },
  {
    "objectID": "Chap2.html",
    "href": "Chap2.html",
    "title": "2  Functional Programming",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\n\n\\(\\forall x\\,P(x)\\) means “for all \\(x\\), \\(P(x)\\),”\n\n\n\n\n\n\nQuantifier Negation Laws\n\n\n\n\n\n\\(\\neg \\exists x\\,P(x)\\)\nis equivalent to\n\\(\\forall x\\,\\neg P(x)\\)\n\n\n\\(\\neg \\forall x\\,P(x)\\)\nis equivalent to\n\\(\\exists x\\,\\neg P(x)\\)"
  },
  {
    "objectID": "Chap3.html#inequality-addition",
    "href": "Chap3.html#inequality-addition",
    "title": "3  Lean as a Theorem Prover",
    "section": "Inequality Addition",
    "text": "Inequality Addition\nStep 1 Putting the initial theorem we want to show in lean code and observing the final goal in the infoview.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  \n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\n⊢ a + c &lt; b + d\n\n\nStep 2\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: c = d\n⊢ a + c &lt; b + d\n\n\nStep 3\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: c = d\n⊢ a + d &lt; b + d\n\n\nStep 4\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: ¬c = d\n⊢ a + c &lt; b + d\n\n\nStep 5\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: c ≠ d\n⊢ a + c &lt; b + d\n\n\nStep 6a We can see here that the lean infoview is now displaying my new hypothesis as the current goal.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n  have h4 : c &lt; d := by\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: c ≠ d\n⊢ c &lt; d\n\n\nStep 6b\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n  have h4 : c &lt; d := by\n    apply Ne.lt_of_le h3 h2\n\n  **done::\n\n\nNo goals\n\n\nStep 7\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n  have h4 : c &lt; d := by\n    apply Ne.lt_of_le h3 h2\n  apply add_lt_add h1 h4\n  done\n\n\nNo goals\n\n\n\nTo prove a goal of the form P → Q:\n\nAssume P is true and prove Q.\nAssume Q is false and prove that P is false.\n\n\n\n&gt;&gt; ⋮\n⊢ P → Q\n\n\n&gt;&gt; ⋮\nh : P\n⊢ Q\n\n\n\n\n\n\nQ\n¬Q\n(Q\n→\nFalse)\n\n\n\n\nF\nT\nF\nT\n    F\n\n\nT\nF\nT\nF\n    F\n\n\n\n\n\n\ntheorem Example_3_2_4_v2 (P Q R : Prop)\n    (h : P → (Q → R)) : ¬R → (P → ¬Q) := by\n  assume h2 : ¬R\n  assume h3 : P\n  **done::\n\n\nP Q R : Prop\nh : P → Q → R\nh2 : ¬R\nh3 : P\n⊢ ¬Q\n\n\n\n\nExercises\nFill in proofs of the following theorems. All of them are based on exercises in HTPI.\n\ntheorem Exercise_3_2_1a (P Q R : Prop)\n    (h1 : P → Q) (h2 : Q → R) : P → R := by\n  \n  **done::\n\n\ntheorem Exercise_3_2_1b (P Q R : Prop)\n    (h1 : ¬R → (P → ¬Q)) : P → (Q → R) := by\n  \n  **done::\n\n\ntheorem Exercise_3_2_2a (P Q R : Prop)\n    (h1 : P → Q) (h2 : R → ¬Q) : P → ¬R := by\n  \n  **done::\n\n\ntheorem Exercise_3_2_2b (P Q : Prop)\n    (h1 : P) : Q → ¬(Q → ¬P) := by\n  \n  **done::"
  },
  {
    "objectID": "Chap3.html#proofs-involving-quantifiers",
    "href": "Chap3.html#proofs-involving-quantifiers",
    "title": "3  Lean as a Theorem Prover",
    "section": "3.3. Proofs Involving Quantifiers",
    "text": "3.3. Proofs Involving Quantifiers\n\nLet x stand for an arbitrary object of type U and prove P x. If the letter x is already being used in the proof to stand for something, then you must choose an unused variable, say y, to stand for the arbitrary object, and prove P y.\n\n\n\n\n\n\nquant_neg Tactic\n\n\n\n\n\n¬∀ (x : U), P x\nis changed to\n∃ (x : U), ¬P x\n\n\n¬∃ (x : U), P x\nis changed to\n∀ (x : U), ¬P x\n\n\n∀ (x : U), P x\nis changed to\n¬∃ (x : U), ¬P x\n\n\n∃ (x : U), P x\nis changed to\n¬∀ (x : U), ¬P x\n\n\n\n\n\nSuppose \\(B\\) is a set and \\(\\mathcal{F}\\) is a family of sets. If \\(\\bigcup\\mathcal{F} \\subseteq B\\) then \\(\\mathcal{F} \\subseteq \\mathscr{P}(B)\\).\n\n\nProof. Suppose \\(\\bigcup \\mathcal{F} \\subseteq B\\). Let \\(x\\) be an arbitrary element of \\(\\mathcal{F}\\). Let \\(y\\) be an arbitrary element of \\(x\\). Since \\(y \\in x\\) and \\(x \\in \\mathcal{F}\\), by the definition of \\(\\bigcup \\mathcal{F}\\), \\(y \\in \\bigcup \\mathcal{F}\\). But then since \\(\\bigcup \\mathcal{F} \\subseteq B\\), \\(y \\in B\\). Since \\(y\\) was an arbitrary element of \\(x\\), we can conclude that \\(x \\subseteq B\\), so \\(x \\in \\mathscr{P}(B)\\). But \\(x\\) was an arbitrary element of \\(\\mathcal{F}\\), so this shows that \\(\\mathcal{F} \\subseteq \\mathscr{P}(B)\\), as required.  □\n\n\nFor every integer \\(n\\), \\(6 \\mid n\\) iff \\(2 \\mid n\\) and \\(3 \\mid n\\).\n\n\nProof. Let \\(n\\) be an arbitrary integer.\n(\\(\\to\\)) Suppose \\(6 \\mid n\\). Then we can choose an integer \\(k\\) such that \\(6k=n\\). Therefore \\(n = 6k = 2(3k)\\), so \\(2 \\mid n\\), and similarly \\(n = 6k = 3(2k)\\), so \\(3 \\mid n\\).\n(\\(\\leftarrow\\)) Suppose \\(2 \\mid n\\) and \\(3 \\mid n\\). Then we can choose integers \\(j\\) and \\(k\\) such that \\(n = 2j\\) and \\(n = 3k\\). Therefore \\(6(j-k) = 6j - 6k = 3(2j) - 2(3k) = 3n - 2n = n\\), so \\(6 \\mid n\\).  □\n\n\n\n\nFor the next exercise you will need the following definitions:"
  },
  {
    "objectID": "Chap4.html",
    "href": "Chap4.html",
    "title": "4  Conclusions",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\n\\[\n[x]_R = \\{y \\in A \\mid yRx\\}.\n\\] The set whose elements are all of these equivalence classes is called \\(A\\) mod \\(R\\). It is written \\(A/R\\), so \\[\nA/R = \\{[x]_R \\mid x \\in A\\}.\n\\] Note that \\(A/R\\) is a set whose elements are sets: for each \\(x \\in A\\), \\([x]_R\\) is a subset of \\(A\\), and \\([x]_R \\in A/R\\)."
  },
  {
    "objectID": "Chap5.html",
    "href": "Chap5.html",
    "title": "5  Works Cited",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\nThis work had been formatted and styled from the book How To Prove It With Lean, written by Daniel J. Velleman. How To Prove It With Lean contains short excerpts from How To Prove It: A Structured Approach, 3rd Edition, by Daniel J. Velleman and published by Cambridge University Press.\nexample : square1 = square2 := by rfl\n\n++#eval:: square1 7     --Answer: 49"
  },
  {
    "objectID": "Chap6.html",
    "href": "Chap6.html",
    "title": "6  Additional space",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\nExtra chapter to write more things if needed!!"
  }
]