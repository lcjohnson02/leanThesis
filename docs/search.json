[
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Works Cited",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\nThis work had been formatted and styled from the book How To Prove It With Lean, written by Daniel J. Velleman. How To Prove It With Lean contains short excerpts from How To Prove It: A Structured Approach, 3rd Edition, by Daniel J. Velleman and published by Cambridge University Press.\n\n\n\n\nAvigad, Jeremy, and Patrick Massot. 2020. “Mathematics in\nLean.” Mathematics in Lean - Mathematics in Lean 0.1\nDocumentation. https://leanprover-community.github.io/mathematics_in_lean/index.html#.\n\n\nAvigad, Jeremy, Leonardo de Moura, Soonho Kong, and Sebastian Ullrich.\n2021. “Theorem Proving in Lean 4.” Theorem Proving in\nLean 4 - Theorem Proving in Lean 4. https://lean-lang.org/theorem_proving_in_lean4/title_page.html.\n\n\nChristiansen, David Thrane. 2023. “Functional Programming in\nLean.” Functional Programming in Lean - Functional\nProgramming in Lean. https://lean-lang.org/functional_programming_in_lean/title.html.\n\n\nVelleman, Daniel J. 2023. How To Prove It With Lean. https://djvelleman.github.io/HTPIwL/."
  },
  {
    "objectID": "Chap2.html#basic-functional-programming",
    "href": "Chap2.html#basic-functional-programming",
    "title": "1  Functional Programming",
    "section": "Basic Functional Programming",
    "text": "Basic Functional Programming\nA programming paradigm is a way of categorizing any given programming language based on its features and how it computes its code. Programming languages will typically fall into one main programming paradigm even if they are capable of using multiple, sometimes chosen because of the intended use of the language. Lean happens to be a functional programming language, meaning that every single thing in lean is a function. A deep understanding of functional programming is not necessary to utilise lean, but in order to take full advantage of the theorem proving capabilities it is able to provide, it helps to have some idea of how the language works.\nWhen we write out mathematical proofs on paper, it is easy to think of each step we take or theorem we apply as part of a bridge between the hypotheses we are assuming to be true and the result we are trying to prove. Another way of thinking about each step in the proof process is as that of a function. In some proofs this is easier to picture than others, but when we take a step in a proof, we are essentially converting some fact that we know to be true into a different fact that we now know to be true. This process repeats over and over again until eventually we have converted something into our end goal. When the process of proving is thought of in this way it becomes more clear how lean is able to verify proofs.\nOne more important thing to mention before diving into an example is that lean also takes advantages of types. This means that every single thing in lean has a given type, which can lead to some issues if typing is not taken care of correctly. Just as some given number in mathematics could be a natural, integer, rational, irrational, or real, that same number in lean could be assigned to one of those specific types. While we typically think of a given natural number as also being an integer, rational, and real, lean tends to be strict and say that each natural number is only a natural number. This level of While this specificty is quite useful in maintaining logical consistency, it can make some processes a bit more difficult. I ran into a few issues during my time with the language when trying to make a recursively defined function that took a natural number to represent which term was being computed and returned a real number. Because lean was so strict with its typing, it did not allow me to define that recursive function the same way it would easily be defined if I was trying to output another natural number. While the theorems in lean are functions, the actual mathematical information is stored in types. Lean is then able to logically verify each step of a proof because of this strict typing. It will not allow for one type to be changed to another type without a valid function being applied."
  },
  {
    "objectID": "Chap2.html#theorems-as-functions",
    "href": "Chap2.html#theorems-as-functions",
    "title": "1  Functional Programming",
    "section": "Theorems as Functions",
    "text": "Theorems as Functions\nLet’s compare a simple lean function to a simple theorem.\n\nSimple Function\ndef adding (n1 : Nat) (n2 : Nat) : Nat := \n  n1 + n2\n\n\nSimple Theorem\nexample (x : α) (A : Set α) (B : Set α) (h1 : A ⊆ B) \n    (h2 : x ∈ A) : x ∈ B := by\n  apply h1\n  apply h2\n  done\nWhen using lean, you set up a theorem to be proved using similar notation to the notation used when defining a function. The hypotheses you are assuming to be true are put in parentheses, just like arguments to a function. In the simple function above I defined two arguments for the function, the two natural numbers n1 and n2. The function then takes these naturals and adds them together to produce another natural number. Within each set of parentheses is information separated by a colon. The information on the left side defines something, and the right side tells us what type that previously defined thing has. Whereas in the simple function we are only defining things of type natural, in the theorem we see that lean will allow us to define objects of an arbitrary type α so long as we continue to use that arbitrary type throughout the rest of the theorem.\nThe function itself is even split into two parts, with everything left of the colon being inputs, and everything to the right being the type of the output of the function itself. When we set up a theorem or example in lean, lean will not let us end the theorem until we have something of the type set out when defining the theorem. This is where we are able to use tactics and apply previous theorems to either convert the types of hypotheses we are assuming, or convert the type of the goal we are trying to prove. In my example theorem above, I applied our first hypothesis which acted as a function and changed the current type in the function. After applying the second hypothesis, I had essentially applied functions to convert our assumptions from their initial types into the goal we wanted to prove. Now that we have a proved theorem, we can apply this in proving other theorems just like any other built-in theorem. Since everything is a function, lean is easily able to use newly proved theorems to convert the types of hypotheses in a different theorem. Having some basic understanding of how the language works, we can begin to apply these concepts to more complex theorems and see the potential benefits of using lean.\n\n\n\n\nAvigad, Jeremy, and Patrick Massot. 2020. “Mathematics in Lean.” Mathematics in Lean - Mathematics in Lean 0.1 Documentation. https://leanprover-community.github.io/mathematics_in_lean/index.html#.\n\n\nAvigad, Jeremy, Leonardo de Moura, Soonho Kong, and Sebastian Ullrich. 2021. “Theorem Proving in Lean 4.” Theorem Proving in Lean 4 - Theorem Proving in Lean 4. https://lean-lang.org/theorem_proving_in_lean4/title_page.html.\n\n\nChristiansen, David Thrane. 2023. “Functional Programming in Lean.” Functional Programming in Lean - Functional Programming in Lean. https://lean-lang.org/functional_programming_in_lean/title.html.\n\n\nVelleman, Daniel J. 2023. How To Prove It With Lean. https://djvelleman.github.io/HTPIwL/."
  },
  {
    "objectID": "Chap3.html#differences-from-paragraph-style-proofs",
    "href": "Chap3.html#differences-from-paragraph-style-proofs",
    "title": "2  Lean as a Theorem Prover",
    "section": "Differences From Paragraph Style Proofs",
    "text": "Differences From Paragraph Style Proofs\nDespite the incredible power that lean could provide in the verification of mathematical proofs, this does pose some difficulties, namely the ease with which the aforementioned proofs can be written up. Typically, proofs are simply written up in a paragraph style, where the steps being taken and the theorems being applied are laid out in plain terms so that it can be easily understood by fellow mathematicians. There are often times when mathematicians writing a typical proof will take things for granted or skip over steps that they think the reader will either already know to be fact or can easily reason out for themselves. This lax approach for conveying information simply does not work when trying to communicate with technology, and a much more specific and methodical approach must be adopted in order to take advantage of the logical verification benefits. Thankfully, lean has a community working to create libraries of previously proven theorems that can be applied to speed up the writing and verification of future proofs. This thankfully means that all proofs do not need to be taken all the way back to basic axioms: Users can save time by avoiding proving adjacent theorems and instead focus only on the immediately relevant steps of their proof.\nFor each of the following proofs, I will first provide a typical “paragraph style” version of the proof, so the differences between the two can easily be compared."
  },
  {
    "objectID": "Chap3.html#inequality-addition",
    "href": "Chap3.html#inequality-addition",
    "title": "2  Lean as a Theorem Prover",
    "section": "Inequality Addition",
    "text": "Inequality Addition\n\nParagraph Style Proof\n\nIf \\(a &lt; b\\) and \\(c \\le d\\), prove that \\(a + c &lt; b + d\\)\n\nThere are multiple ways to approach this in a paragraph style proof, so I will attempt to have this proof follow along the same lines as the lean proof.\n\nProof. There are two possible cases: either \\(c = d\\) or \\(c &lt; d\\). We will first consider the case where \\(c = d\\). We know \\(a &lt; b\\), so it would also be true that \\(a + c &lt; b + c\\). Then because \\(c = d\\), \\(a + c &lt; b + d\\). Now consider the case where \\(c &lt; d\\). We know \\(a &lt; b\\), so \\(a + c &lt; b + c\\) and \\(b + c &lt; b + d\\) because \\(c &lt; d\\). Thus by transitivity of inequalities, we could say \\(a + c &lt; b + d\\)  □\n\n\n\nLean Proof\n\nSeting up the problem\nHere I put the theorem we want to prove into lean and we can see the resulting infoview panel. I name our two assumptions h1 and h2, for hypotheses one and two. After a colon I then write out the thing I am trying to prove with those hypotheses and use by to put lean into tactic mode.\nIt can now be seen that the infoview panel lists out both of our hypotheses as well as the goal we are working towards at the bottom. This panel will continue to change as more code is added to the lean file.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  \n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\n⊢ a + c &lt; b + d\n\n\n\n\nStep 1\nHere I lay out the two possible cases of our second hypothesis which allows me to strengthen the information that we know. We see this strengthened hypothesis reflected in h3 in the infoview.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: c = d\n⊢ a + c &lt; b + d\n\n\n\n\nStep 2\nHere I used hypothesis 3 to rewrite the c in our final goal as a d. This change is reflected in the infoview for this step.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: c = d\n⊢ a + d &lt; b + d\n\n\n\n\nStep 3\nIn this step I applied a theorem already in the Mathlib library for lean. The add_lt_add_right theorem simply states that if you have a b &lt; c, then b + a &lt; c + a which is exactly what we need to prove the goal for the first case. As the first case has been completed, the infoview then switches to the second case which is reflected in the new h3 and reset goal.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: ¬c = d\n⊢ a + c &lt; b + d\n\n\n\n\nStep 4\nIn order to better work with our new hypothesis, I use a tactic which pushes the negation symbol further into the thing it is negating. This results in a hypothesis which can actually be applied later on.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: c ≠ d\n⊢ a + c &lt; b + d\n\n\n\n\nStep 5\nHere I am laying out a new hypothesis which will be useful later in the proof. This hypothesis seems like an obvious conclusion based on hypotheses two and three, but we must still lay it out simply for lean if we want to actually use it. The infoview panel always displays the most current goal, which is why it is displaying the goal for h4 rather than the main goal.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n  have h4 : c &lt; d := by\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: c ≠ d\n⊢ c &lt; d\n\n\n\n\nStep 6\nHere I apply another theorem already in lean which takes the information h3 and h2 gives us and shows our current goal. Writing out h4 like this is technically optional, as lean allows you to evaluate tactics within arguments for other tactics. Despite this, I personally find it more clear and human-readable to write out extra hypotheses like this rather than just giving the body of the argument when necessary. Now that our new hypothesis has been proven, the infoview displays that we have no goals until we get back into our main theorem.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n  have h4 : c &lt; d := by\n    apply Ne.lt_of_le h3 h2\n\n  **done::\n\n\nNo goals\n\n\n\n\nStep 7\nI now use the calc tactic to work through the rest of the theorem. This tactic is quite useful as it allows us to chain together multiple equalities or inequalities while still giving proofs for each step. This is essentially a shortcut of writing out individual hypotheses and then using the rewrite tactic to get our desired goal.\nIn this case, I only need to do two steps of chaining inequalities, where I use transitivity to show that the starting value is less than the final value. It essentially follows the same path as the paragraph style proof, where the tactics add_lt_add_right and add_lt_add_left justify the steps taken.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n  have h4 : c &lt; d := by\n    apply Ne.lt_of_le h3 h2\n  exact calc\n    a + c &lt; b + c := add_lt_add_right h1 c\n    _ &lt; b + d := add_lt_add_left h4 b\n  done\n\n\nNo goals"
  },
  {
    "objectID": "Chap3.html#a-is-less-than-or-equal-to-b",
    "href": "Chap3.html#a-is-less-than-or-equal-to-b",
    "title": "2  Lean as a Theorem Prover",
    "section": "a is Less Than or Equal to b",
    "text": "a is Less Than or Equal to b\n\nParagraph Style Proof\n\nSuppose that \\(a, b \\in \\mathbb{R}\\) and for every \\(\\varepsilon &gt; 0\\), we have \\(a \\le b + \\varepsilon\\). Show that \\(a \\le b\\).\n\n\nProof. Assume for the sake of contradiction that \\(a\\) is not less than or equal to \\(b\\). Then it would be true that \\(a &gt; b\\). Now consider the case where \\(\\varepsilon = \\frac{a - b}{2}.\\) Then since \\(a &gt; b\\), epsilon is positive and by our assumption then \\(a \\le b + \\varepsilon\\). Then \\[\\begin{align*}\na & \\le b + \\varepsilon \\\\\n& = b + \\frac{a - b}{2} \\\\\n& = b + \\frac{a}{2} - \\frac{b}{2} \\\\\n& = \\frac{a}{2} + \\frac{b}{2}.\n\\end{align*}\\] So now, \\[\\begin{align*}\na & \\le \\frac{a}{2} + \\frac{b}{2} \\\\\na - \\frac{a}{2} & \\le \\frac{b}{2} \\\\\n\\frac{a}{2} & \\le \\frac{b}{2} \\\\\na & \\le b.\n\\end{align*}\\] But now we have that \\(a \\le b\\) and \\(a &gt; b\\), a contradiction!  □\n\n\n\nLean Proof\n\nSetting up the problem\nI again set up the proof with our one hypothesis and the goal we want to prove. These are then seen listed in the infoview on the right.\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\n⊢ a ≤ b\n\n\n\n\nStep 1\nThe by_contra tactic allows me to complete this problem using proof by contradiction. This tactic automatically creates a hypothesis containing the negation of the final goal named h2, and changes the final goal to False meaning that it needs us to show a contradiction.\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: ¬a ≤ b\n⊢ False\n\n\n\n\nStep 2\nHere I use the push_neg tactic similarly to the previous example to get a usable version of h2 as well as pick a specific epsilon for which we will find a contradiction. This new epsilon will now show up in the infoview on the side and can be used in our problem.\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\n⊢ False\n\n\n\n\nStep 3\nHere I lay out a hypothesis that we will later be able to apply to h1. Claiming that epsilon was positive in the paragraph style proof is fairly simple to back up, where we only really need to justify that \\(a - b\\) is positive. In lean however, it requires a bit more effort and as such I put in its own hypothesis.\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n\n    **done::\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\n⊢ ε &gt; 0\n\n\n\n\nStep 4\nAnyone reading a paragraph style proof such as ours would know that dividing a number by two does not impact whether the resulting number will be positive or negative, but this still needs to be justified in lean. As such, I use the half_pos theorem with the refine tactic to change the goal to what is currently shown in the infoview. The refine tactic is useful because it tries to apply the arguments it is given to the final goal and then changes the goal to whatever is needed to meet the hypotheses in the arguments. In this case, half_pos claims that if you have some \\(a &gt; 0,\\) then \\(\\frac{a}{2} &gt; 0.\\) The refine tactic then applies the result of that theorem and leaves us to show that \\(a &gt; 0,\\) and lean is smart enough to figure out that we actually need to show \\(a - b &gt; 0.\\)\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n\n      **done::\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\n⊢ 0 &lt; a - b\n\n\n\n\nStep 5\nThe sub_pos theorem says that \\(0 &lt; a - b\\) if and only if \\(b &lt; a,\\) so we only need to apply this with our second hypothesis to complete our current goal. This finishes off the proof of the third hypothesis and allows us to return to the main theorem.\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n    exact Iff.mpr sub_pos h2\n    done\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\nh3: ε &gt; 0\n⊢ False\n\n\n\n\nStep 6\nI now try to lay out the fourth and final hypothesis which will be used to find a contradiction with h2. This is another example of something being quickly explained in the paragraph style proof, but being more cumbersome to justify within lean.\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n    exact Iff.mpr sub_pos h2\n    done\n  have h4 : a ≤ b + ε := by\n\n    **done::\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\nh3: ε &gt; 0\n⊢ a ≤ b + ε\n\n\n\n\nStep 7\nI first apply h1 which has a similar effect to using the refine tactic earler: it applies the result of an if-then statement and changes our goal to proving the if.\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n    exact Iff.mpr sub_pos h2\n    done\n  have h4 : a ≤ b + ε := by\n    apply h1\n\n    **done::\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\nh3: ε &gt; 0\n⊢ ε &gt; 0\n\n\n\n\nStep 8\nNow that our goal has been properly modified, h3 is the only other thing necessary to justify this hypothesis.\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n    exact Iff.mpr sub_pos h2\n    done\n  have h4 : a ≤ b + ε := by\n    apply h1\n    apply h3\n    done\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\nh3: ε &gt; 0\nh4: a ≤ b + ε\n⊢ False\n\n\n\n\nStep 9\nThe dsimp tactic will do its best to automatically simplify anything it is given, in this case it substitutes our specific epsilon value in for the arbitrary epsilon. This will now allow us to use h4 to find our contradiction.\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n    exact Iff.mpr sub_pos h2\n    done\n  have h4 : a ≤ b + ε := by\n    apply h1\n    apply h3\n    done\n  dsimp at h4\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\nh3: ε &gt; 0\nh4: a ≤ b + (a - b) / 2\n⊢ False\n\n\n\n\nStep 10\nThe linarith tactic is quite powerful as it will attempt to simplify the goal as well as hypotheses and then look for a contradiction amongst the known hypotheses. This is one example where lean actually requires quite a bit less explanation than a typical proof. The majority of my paragraph style proof above was spent simplifying and manipulating h4 and h2, whereas in lean I need to specify none of that! It is quite impressive that lean is already able to do so much simplification and even find contradictions with no user input. This ability will likely only increase in power in the future, and some developments have even occured during the planning and writing of this thesis that make other simplification tactics substantially more powerful.\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n    exact Iff.mpr sub_pos h2\n    done\n  have h4 : a ≤ b + ε := by\n    apply h1\n    apply h3\n    done\n  dsimp at h4\n  linarith\n  done\n\n\nNo goals"
  },
  {
    "objectID": "Chap3.html#absolute-convergence",
    "href": "Chap3.html#absolute-convergence",
    "title": "2  Lean as a Theorem Prover",
    "section": "Absolute Convergence",
    "text": "Absolute Convergence\n\nParagraph Style Proof\n\nProve that \\(\\lim(x_{n}) = 0\\) if and only if \\(\\lim(\\left|x_{n}\\right|) = 0.\\)\n\n\nProof. \\((\\Longrightarrow)\\) First assume that \\(\\lim(x_{n}) = 0.\\) Then for all \\(\\varepsilon &gt; 0\\) we know there exists a \\(k_{n} \\in \\mathbb{N}\\) such that for all nautral numbers \\(n &gt; k_{n},\\) \\(\\left|x_{n} - 0\\right| &lt; \\varepsilon.\\) Thus \\(\\left|x_{n}\\right| &lt; \\varepsilon\\) and also \\(\\left|\\left|x_{n}\\right| - 0 \\right| &lt; \\varepsilon,\\) so \\(\\lim(\\left|x_{n}\\right|) = 0.\\)\n\\((\\Longleftarrow)\\) Now assume that \\(\\lim(\\left|x_{n}\\right|) = 0.\\) Then for all \\(\\varepsilon &gt; 0\\) we know there exists a \\(k_{n} \\in \\mathbb{N}\\) such that for all nautral numbers \\(n &gt; k_{n},\\) \\(\\left|\\left|x_{n}\\right| - 0\\right| &lt; \\varepsilon.\\) But \\(\\left|\\left|x_{n}\\right| - 0\\right| = \\left|\\left|x_{n}\\right|\\right| = \\left|x_{n}\\right| = \\left|x_{n} - 0\\right|.\\) So \\(\\left|x_{n} - 0\\right| &lt; \\varepsilon\\) and \\(\\lim(x_{n}) = 0.\\)  □\n\n\n\nLean Proof\n\nSetting up the problem\nLean does not include a built in epsilon definition of a limit for sequences, so it is first necessary to define a limit in lean. I use the following definition:\ndef ConvergesTo (s : ℕ → ℝ) (a : ℝ) :=\n  ∀ ε &gt; 0, ∃ N, ∀ n ≥ N, |s n - a| &lt; ε\nFrom this point we can set up our problem as normal.\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n\n  **done::\n\n\ns1: ℕ → ℝ\n⊢ ConvergesTo s1 0 \n&gt;&gt;  ↔ ConvergesTo |s1| 0\n\n\n\n\nStep 1\nThe first thing I ask lean to do is rewrite the definition of convergence that I defined earler when it is used in our goal. This will allow us to actually use and work towards the information in both instances of ConvergesTo in the problem. The fully expanded definition is shown in the infoview panel.\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n\n  **done::\n\n\ns1: ℕ → ℝ\n⊢ (∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |s1 n - 0| &lt; ε) ↔\n&gt;&gt;    ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |abs s1 n - 0| &lt; ε\n\n\n\n\nStep 2\nHere I set up a hypothesis which will later be used to rewrite both sides of the if and only if statement into something that is equal to the other.\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    \n    done\n\n  **done::\n\n\ns1: ℕ → ℝ\nx: ℕ\n⊢ |s1 x| = |abs s1 x|\n\n\n\n\nStep 3\nIn this instance lean essentially already knows that our goal is true, and only need to be told to simplify using the definition of absolute value in order to verify this. While it is impressive that lean requires little guidance, seeing some of the other things lean is capable of leaves me a bit underwhelmed that lean requires any input here. Because lean is constantly being developed there may come a time where simple statements like this are automatically verified without any user input.\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\n⊢ (∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |s1 n - 0| &lt; ε) ↔\n&gt;&gt;    ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |abs s1 n - 0| &lt; ε\n\n\n\n\nStep 4\nHere the Iff.intro tactic splits up the if and only if statement in the goal and allows us to prove each direction individually, as is often done in a paragraph style proof.\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\n⊢ (∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |s1 n - 0| &lt; ε) →\n&gt;&gt;    ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |abs s1 n - 0| &lt; ε\n\n\n\n\nStep 5\nThe intro tactic applied here allows me to assume the if part of an if-then statement and automatically names it with the hypothesis name I give it.\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  ∃ N, ∀ (n : ℕ), \n&gt;&gt;  n ≥ N → |s1 n - 0| &lt; ε\n⊢ ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |abs s1 n - 0| &lt; ε\n\n\n\n\nStep 6\nWith the simp tactic, lean attempts to simplify the current goal. In this case, the \\(\\left|\\left|s1_{n}\\right| - 0\\right|\\) is simplified to \\(\\left|\\left|s1_{n}\\right|\\right|.\\) This is now where our h3 hypothesis can be applied, but I will first attempt to simplify h1.\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  ∃ N, ∀ (n : ℕ), \n&gt;&gt;  n ≥ N → |s1 n - 0| &lt; ε\n⊢ ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    N ≤ n → \n&gt;&gt;    |abs s1 n| &lt; ε\n\n\n\n\nStep 7\nThe simp tactic has the same effect as in the previous step, but this time it is working on h1 rather than the end goal. By default simp will attempt to work on the goal but if asked to it will attempt to simplify hypotheses as well.\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n    simp at h1\n\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\nh1: ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;  ∃ N, ∀ (n : ℕ), \n&gt;&gt;  N ≤ n → |s1 n| &lt; ε\n⊢ ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    N ≤ n → \n&gt;&gt;    |abs s1 n| &lt; ε\n\n\n\n\nStep 8\nWe can now use the reverse direction of h3 to simplify our goal further. Notice that the leftwards facing arrow is necessary, as lean typically tries to apply equalities from left to right. This means if the left side of the equality does not match what lean is attempting to replace, lean will not be able to rewrite in other terms.\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n    simp at h1\n    simp [← h3]\n\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\nh1: ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;  ∃ N, ∀ (n : ℕ), \n&gt;&gt;  N ≤ n → |s1 n| &lt; ε\n⊢ ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    N ≤ n → \n&gt;&gt;    |s1 n| &lt; ε\n\n\n\n\nStep 9\nThe simplification done over the last few steps has modified both h1 and our goal to be the same thing. Since we are assuming h1 to be true, this allows us to apply that hypothesis and complete the first direction of our goal. Upon completion of the first goal, lean automatically begins displaying the second goal, which can be solved quite similarly to the first. This is one place where some mathematicians may leave the other direction out of their paragraph style proof because it is essentially proved the same way as the previous direction. While this is easy and convenient, it never hurts to give a full explanation like what lean will require of us.\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n    simp at h1\n    simp [← h3]\n    apply h1\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\n⊢ (∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |abs s1 n - 0| &lt; ε) →\n&gt;&gt;    ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |s1 n - 0| &lt; ε\n\n\n\n\nStep 10\nWith this direction I try to simplify in the same ways as before, but instead of using the leftwards direction of the equality in h3, I use the rightwards direction. This means that arrow does not need to be included and once again he have h1 equal to our current goal.\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n    simp at h1\n    simp [← h3]\n    apply h1\n  · --Reverse\n    intro h1\n    simp\n    simp at h1\n    simp_rw [h3]\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\nh1: ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;  ∃ N, ∀ (n : ℕ), \n&gt;&gt;  N ≤ n → |abs s1 n| &lt; ε\n⊢ ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;    ∃ N, ∀ (n : ℕ),\n&gt;&gt;    N ≤ n → \n&gt;&gt;    |abs s1 n| &lt; ε\n\n\n\n\nStep 11\nWith a hypothesis equal to our goal, we are able to apply the hypothesis and prove the other direction of the if and only if statement, completing the proof.\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n    simp at h1\n    simp [← h3]\n    apply h1\n  · --Reverse\n    intro h1\n    simp\n    simp at h1\n    simp_rw [h3]\n    apply h1\n  done\n\n\nNo goals"
  },
  {
    "objectID": "Chap3.html#convergence-of-a-specific-sequence",
    "href": "Chap3.html#convergence-of-a-specific-sequence",
    "title": "2  Lean as a Theorem Prover",
    "section": "Convergence of a Specific Sequence",
    "text": "Convergence of a Specific Sequence\nThe following is an example of one situation where lean is somewhat lacking in comparison to a paragraph style proof. The paragraph style proof is able to quickly and easily prove the desired end goal, but lean has to work around a lot of the simple rewriting we would do in a normal proof. In this attempt to prove the convergence of a specific sequence, there were many issues with simplification involving arbitrary variables and the change from natural numbers to real numbers. These sorts of things can be easily explained in a paragraph style proof, but required significant work to prove in lean.\nI mentioned earlier that lean’s ability to simplify and make connections without user input was advancing quickly, and I encountered this when working on this problem. I originally had great difficulty getting lean to accept that \\(2 = \\frac{2(n + 1)}{n + 1},\\) which is something which can easily be explained in a typical proof, but lean had difficulty accepting. Thankfully, lean has recently strengthened a tactic that renders much of my work here unnecessary. The field_simp tactic tries to simplify the current goal using what is known about all fields, and since we are working with the real numbers we are able to take advantage of this. I was not able to use this tactic since it was changed while I was working on the project, but seeing how quickly lean is progressing is very promising.\nLean internally defines limits using filters and topology rather than the real analysis approach of epsilons, so the approach I was taking here is not the optimal approach for theorems involving limits in lean. While this topological filter definition of a limit is very useful for the people who know how to use it, it makes lean more difficult to use for those who have not yet studied topology. Definitions such as this start to portray that lean is not really something meant to be used for lower level mathematics, but rather complex and high level proofs.\n\nParagraph Style Proof\n\nProve that \\(\\lim(\\frac{2n}{n + 1}) = 2.\\)\n\n\nProof. Let \\(\\varepsilon &gt; 0\\) and choose \\(k &gt; \\frac{1}{\\varepsilon} - 1\\) where \\(k \\in \\mathbb{N}\\) by the Archimedean Property. Then for \\(n &gt; k:\\) \\[\\begin{align*}\n\\left|\\frac{2n}{n + 1} - 2\\right| & = \\left|\\frac{2n}{n + 1} - \\frac{2(n + 1)}{n + 1}\\right|\\\\\n& = \\left|\\frac{-1}{n + 1}\\right|\\\\\n& = \\frac{1}{n + 1}\\\\\n& &lt; \\frac{1}{k + 1}\\\\\n& &lt; \\frac{1}{\\frac{1}{\\varepsilon} - 1 + 1} = \\varepsilon.\n\\end{align*}\\] Thus we have that \\(\\lim(\\frac{2n}{n + 1}) = 2.\\)  □\n\n\n\nLean Proof\nexample : ConvergesTo (fun (n : ℕ) ↦ \n    ((2 * n) / (n + 1))) 2 := by\n  intro ε\n  intro h1\n  obtain ⟨k, h13⟩ := \n    exists_nat_gt (2 / ε - 1) --Archimedean Property\n  use k\n  intro n\n  intro h2\n  dsimp\n  have h3 : (2 : ℝ) = 2 * ((n + 1) / (n + 1)) := by\n    have h4 : ((n + 1) / (n + 1)) = \n        (n + 1) * ((n + 1) : ℝ)⁻¹ := by\n      rfl\n      done\n    rw [h4]\n    have h5 : (n + 1) * ((n + 1) : ℝ)⁻¹ = 1 := by\n      rw [mul_inv_cancel]\n      exact Nat.cast_add_one_ne_zero n\n      done\n    rw [h5]\n    exact Eq.symm (mul_one 2)\n    done\n  nth_rewrite 2 [h3]\n  have h6 : 2 * ((↑n + 1) : ℝ) / (↑n + 1) = \n      ((2 * n) + 2) / (n + 1) := by\n    rw [Distribute n]\n    done\n  have h7 : 2 * (((↑n + 1) : ℝ) / (↑n + 1)) = \n      2 * (↑n + 1) / (↑n + 1) := by\n    rw [← mul_div_assoc 2 ((n + 1) : ℝ) ((n + 1) : ℝ)]\n    done\n  rw [h7]\n  rw [h6]\n  rw [div_sub_div_same (2 * n : ℝ) (2 * n + 2) (n + 1)]\n  rw [sub_add_cancel']\n  rw [abs_div]\n  simp\n  have h8 : |(↑n + 1 : ℝ)| = ↑n + 1 := by\n    simp\n    apply LT.lt.le (Nat.cast_add_one_pos ↑n)\n    done\n  rw [h8]\n  have h9 : (2 : ℝ) / (↑n + 1) ≤ 2 / (k + 1) := by\n    apply div_le_div_of_le_left\n    · --case 1\n      linarith\n      done\n    · --case 2\n      exact Nat.cast_add_one_pos k\n      done\n    · --case 3\n      convert add_le_add_right h2 1\n      apply Iff.intro\n      · --subcase 1\n        exact fun a =&gt; Nat.add_le_add_right h2 1\n        done\n      · --subcase 2\n        intro h14\n        apply add_le_add_right\n        exact Iff.mpr Nat.cast_le h2\n        done\n      done\n    done\n  have h10 : 2 / (k + 1) &lt; 2 / (2 / ε - 1 + 1) := by\n    apply div_lt_div_of_lt_left\n    · --case 1\n      linarith\n      done\n    · --case 2\n      simp\n      apply div_pos\n      linarith\n      apply h1\n      done\n    · --case 3\n      convert add_le_add_right h2 1\n      apply Iff.intro\n      · --subcase 1\n        intro h11\n        exact Nat.add_le_add_right h2 1\n        done\n      · --subcase 2\n        intro h11\n        have h12 : 2 / ε - 1 &lt; (k : ℝ) := by\n          simp only []\n          apply h13\n          done\n        exact add_lt_add_right h12 1\n        done\n      done\n    done\n  calc\n    2 / (↑n + 1) ≤ (2 : ℝ) / (k + 1) := by\n      apply h9\n      done\n    _ &lt; (2 : ℝ) / (2 / ε - 1 + 1) := by\n      apply h10\n      done\n    _ = ε := by\n      ring_nf\n      apply inv_inv\n      done\n  done\n\n\n\n\nAvigad, Jeremy, and Patrick Massot. 2020. “Mathematics in Lean.” Mathematics in Lean - Mathematics in Lean 0.1 Documentation. https://leanprover-community.github.io/mathematics_in_lean/index.html#.\n\n\nAvigad, Jeremy, Leonardo de Moura, Soonho Kong, and Sebastian Ullrich. 2021. “Theorem Proving in Lean 4.” Theorem Proving in Lean 4 - Theorem Proving in Lean 4. https://lean-lang.org/theorem_proving_in_lean4/title_page.html.\n\n\nChristiansen, David Thrane. 2023. “Functional Programming in Lean.” Functional Programming in Lean - Functional Programming in Lean. https://lean-lang.org/functional_programming_in_lean/title.html.\n\n\nVelleman, Daniel J. 2023. How To Prove It With Lean. https://djvelleman.github.io/HTPIwL/."
  },
  {
    "objectID": "Chap4.html#the-good",
    "href": "Chap4.html#the-good",
    "title": "3  Conclusions",
    "section": "The Good",
    "text": "The Good\nIt is easy to see the potential which lean has to aid in proof verification, and it only seems to be gaining more popularity. The language is continuously being expanded and made more powerful which should only help make it accessible to more people. The language already has some features that could be very helpful to new users, such as the apply? tactic. This tactic looks at the current goal and all hypotheses and suggests tactics and theorems which could be applied to get closer to the goal. While this is certainly not perfect, it is very helpful and I used it quite a few times during my time with the language. This tactic is most useful for peopple who are new to the language and are not sure how to apply the theorems that they need or what the theorems may be called in lean. This tactic worked best for me when completing simple steps that only required one more theorem already in lean’s library to reach my current goal.\nAnother helpful tactic is the sorry tactic. This is mainly helpful for those trying to initially prove theorems in lean rather than just convert previous proofs into lean. Applying sorry to a goal automatically proves that goal within the context of the problem, allowing the user to continue on with the proof and return to that sub-proof later. Since using this tactic does not actually prove a theorem, lean will underline the main theorem and not allow it to be used in any other proofs. While this line of thinking could also be done with pen and paper, the ability to see if one approach would even be fruitful before taking the time to justify everything is convenient and could help with the process of creating proofs.\nLean clearly laying out all known hypotheses and the current goal which would finish the proof could aid some users in figuring out how to prove theorems or problems they might have struggled with otherwise. This was one of the biggest benefits of the language when I was working with it, because it is often difficult to keep track of exactly what I know to be true. Being able to automatically simplify hypotheses and take things back to their definitions can greatly help figure out how each hypothesis could be applied.\nEven without these tactics which make the language more user friendly, lean still absolutely accomplishes its goal of automated proof verification. The language is somewhat difficult to get the hang of even with newly empowered tactics and theorems, but the users who have a deep understanding of the language are truly able to harness its full potential and easily work with difficult concepts in a way that is at times more concise than writing it out on paper. If a proof is being verified by another human, it may be necessary to go into great detail so that they are able to understand each step being taken. With lean, however, once one knows how to work within lean’s realm of understanding they should be able to prove anything and not need to go into great detail. This difference in explanation would only grow larger when venturing into higher level mathematics and newly developing topics.\nLean’s intent on proof verification also raises the question of how necessary automated proof verification truly is. No doubt is it useful to have a proof checked by a machine for you, but if this were to be used to develop new theorems, they would still need to eventually be written in a way on paper that other human mathematicians can easily understand and use. Automation in mathematics is nice, but ultimately the human mathematicians are the ones making new developments and as such should be prioritized when writing proofs. Lean could, however, help with the writing of human readable proofs so long as the writer fully understands what the lean code is doing. Lean can ensure that no logical jumps are being taken and if something is broken down into steps that lean can understand, someone could translate them into human readable steps that would be totally coherent and logical."
  },
  {
    "objectID": "Chap4.html#the-bad",
    "href": "Chap4.html#the-bad",
    "title": "3  Conclusions",
    "section": "The Bad",
    "text": "The Bad\nThe biggest downside to using lean is getting used to the programming language itself and trying to put mathematical steps into terms which lean is able to understand. If someone has not spent much time working with programming languages it would certainly be difficult and time consuming to learn something entirely new, but even for those who have had experience programming the switch into lean could still prove difficult. While there are methods within lean which could aid new users such as the aforementioned apply? tactic, it is still necessary to know how to manipulate hypotheses into a form that lean is able to work with, which may not always be as easy as it would be on paper.\nAnother downside to lean is the lack of options and potentially the inability to immediately keep up with mathematics in the future. Development takes time, and in order to do proofs in lean more theorems and definitions need to be added and worked out. As new areas of mathematics are expanded, it will be necessary to do upkeep on the language and add in new features or even make large overhauls to the language depending on the significance of the work being done. As I mentioned earlier, lean completely abandons some methods of proof in favor of more currently concise methods. This works fine for now, but if there was a newly developing area of mathematics which functioned better under a previously abandoned method, lean may need to be reworked and theorems may need to be rewritten to fit better into the new system.\nLean also abandons some parts of mathematics that are not neccesarily applicable outside of exercises. While working on a problem in lean I reached out on the Zulip forum for help and one person who contributes to the programming of lean responded that what I was looking for wasn’t included in lean’s library because it was really only useful for exercises. Cutting things like this may be necessary to save time programming the language, but it is a shame that everything cannot be included. Some simpler aspects of mathematics are important steps in developing ones understanding of higher level topics and to expect anyone coming into lean to already know high level mathematics seems nearsighted. If lean is to become more widely accepted, those learning mathematics need to be able to learn and use it as they grow in mathematical ability. This could help lead to mathematicians who are able to take full advantage of the language and even potentially contribute to development of the language."
  },
  {
    "objectID": "Chap4.html#the-future",
    "href": "Chap4.html#the-future",
    "title": "3  Conclusions",
    "section": "The Future",
    "text": "The Future\nWith lean constantly expanding and growing more powerful, it could become easy enough to use that it becomes widely used. The scene of users is quite active right now, and its libraries are constantly being updated. Lean has even gained enough popularity that a few textbooks have been written about proving mathematical theorems using lean. These vary in level of difficulty and some add their own libraries of theorems and definitions which are not included in the base installation of lean. The How To Prove It With Lean textbook as well as Mathematics in Lean were both quite instrumental in learning the language and gaining a full grasp of lean’s capabilities. How To Prove It With Lean makes some substantial changes to the base language which I believe makes it easier to use than the base language. Due to the added tactics and simpler syntax rules in this book, I would certainly recommend any new users start with this book. Once the basics have been understood, Mathematics in Lean goes back to the base language and takes the language into higher level mathematics such as topology and calculus. These books do a great job of teaching the language and some of the math at the same time, making it possible for those starting to learn mathematical proofs to start in lean and learn to take full advantage of it. If lean continues to be supported and expanded we could certainly see a greater acceptance and implementation into mainstream mathematics.\n\n\n\n\nAvigad, Jeremy, and Patrick Massot. 2020. “Mathematics in Lean.” Mathematics in Lean - Mathematics in Lean 0.1 Documentation. https://leanprover-community.github.io/mathematics_in_lean/index.html#.\n\n\nAvigad, Jeremy, Leonardo de Moura, Soonho Kong, and Sebastian Ullrich. 2021. “Theorem Proving in Lean 4.” Theorem Proving in Lean 4 - Theorem Proving in Lean 4. https://lean-lang.org/theorem_proving_in_lean4/title_page.html.\n\n\nChristiansen, David Thrane. 2023. “Functional Programming in Lean.” Functional Programming in Lean - Functional Programming in Lean. https://lean-lang.org/functional_programming_in_lean/title.html.\n\n\nVelleman, Daniel J. 2023. How To Prove It With Lean. https://djvelleman.github.io/HTPIwL/."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Automated Proof Verification with Lean",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\n\nPreface\nThis thesis is intended to address the potential that the lean programming language has in aiding with the verification of mathematical proofs. Lean was developed as a functional programming language with the intent that it could be used for theorem proving. Development on the language started in 2013 and has now seen four different fully released versions. I would recommend that while reading this thesis, you download lean and put my code onto your own machine to see how it works. I have included a file on my github repository which contains code for each of the examples I put into the “Lean as a Theorem Prover” section of the thesis. The Mathlib package is not contained within this repository, so in order to see my examples for yourself, you will need to copy the examples into your own lean project. While I have done my best to show the language in a way that displays both its positive and negative aspects, the best way to get a grasp for that will be to try it out for yourself. Instructions on how to install a copy of lean can be found here.\nIf you find this language interesting and would like to learn more, the textbook How To Prove It With Lean is a great starting point, and the textbook Mathematics in Lean goes into further detail on some higher level topics such as calculus and topology. Lean also has a dedicated forum on Zulip where other users can help address any questions regarding the language. I used the forum a few times while working on this project, and the feedback I recieved was quite helpful.\n\n\n\n\nAvigad, Jeremy, and Patrick Massot. 2020. “Mathematics in Lean.” Mathematics in Lean - Mathematics in Lean 0.1 Documentation. https://leanprover-community.github.io/mathematics_in_lean/index.html#.\n\n\nAvigad, Jeremy, Leonardo de Moura, Soonho Kong, and Sebastian Ullrich. 2021. “Theorem Proving in Lean 4.” Theorem Proving in Lean 4 - Theorem Proving in Lean 4. https://lean-lang.org/theorem_proving_in_lean4/title_page.html.\n\n\nChristiansen, David Thrane. 2023. “Functional Programming in Lean.” Functional Programming in Lean - Functional Programming in Lean. https://lean-lang.org/functional_programming_in_lean/title.html.\n\n\nVelleman, Daniel J. 2023. How To Prove It With Lean. https://djvelleman.github.io/HTPIwL/."
  }
]