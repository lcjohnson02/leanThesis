[
  {
    "objectID": "Chap3.html#differences-from-paragraph-style-proofs",
    "href": "Chap3.html#differences-from-paragraph-style-proofs",
    "title": "3  Lean as a Theorem Prover",
    "section": "Differences From Paragraph Style Proofs",
    "text": "Differences From Paragraph Style Proofs\nDespite the incredible power that lean could provide in the verification of mathematical proofs, this does pose some difficulties, namely the ease with which the aforementioned proofs can be written up. Typically, proofs are simply written up in a paragraph style, where the steps being taken and the theorems being applied are laid out in plain terms so that it can be easily understood by fellow mathematicians. There are often times when mathematicians will take things for granted or skip over steps that they think the reader will either already know to be fact or can easily reason out for themselves when writing out typical proofs. This lax approach for conveying information simply does not work when trying to communicate with technology, and a much more specific and methodical approach must be adopted in order to take advantage of the logical verification benefits. Thankfully, lean has a community working to create libraries of previously proven theorems that can be applied to speed up the writing and verification of future proofs. This thankfully means that all proofs do not need to be taken all the way back to basic axioms: Users can save time by avoiding proving adjacent theorems and instead focus only on the immediately relevant steps of their proof.\nFor each of the following proofs, I will first provide a typical “paragraph style” version of the proof, so the differences between the two can easily be compared."
  },
  {
    "objectID": "Chap3.html#inequality-addition",
    "href": "Chap3.html#inequality-addition",
    "title": "3  Lean as a Theorem Prover",
    "section": "Inequality Addition",
    "text": "Inequality Addition\n\nIf \\(a &lt; b\\) and \\(c \\le d\\), prove that \\(a + c &lt; b + d\\)\n\nThere are multiple ways to approach this in a paragraph style proof, so I will attempt to have this proof follow along the same lines as the lean proof.\n\nProof. There are two possible cases: either \\(c = d\\) or \\(c &lt; d\\). We will first consider the case where \\(c = d\\). We know \\(a &lt; b\\), so it would also be true that \\(a + c &lt; b + c\\). Then because \\(c = d\\), \\(a + c &lt; b + d\\). Now consider the case where \\(c &lt; d\\). We know \\(a &lt; b\\), so \\(a + c &lt; b + c\\) and \\(b + c &lt; b + d\\) because \\(c &lt; d\\). Thus by transitivity of inequalities, we could say \\(a + c &lt; b + d\\)  □\n\n\nSeting up the problem\nHere I put the theorem we want to prove into lean and we can see the resulting infoview panel. I name our two assumptions h1 and h2, for hypotheses one and two. After a colon I then write out the thing I am trying to prove with those hypotheses and use by to put lean into tactic mode.\nIt can now be seen that the infoview panel lists out both of our hypotheses as well as the goal we are working towards at the bottom. This panel will continue to change as more code is added to the lean file.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  \n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\n⊢ a + c &lt; b + d\n\n\n\n\nStep 1\nHere I lay out the two possible cases of our second hypothesis which allows me to strengthen the information that we know. We see this strengthened hypothesis reflected in h3 in the infoview.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: c = d\n⊢ a + c &lt; b + d\n\n\n\n\nStep 2\nHere I used hypothesis 3 to rewrite he c in our final goal as a d. This change is reflected in the infoview for this step.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: c = d\n⊢ a + d &lt; b + d\n\n\n\n\nStep 3\nIn this step I applied a theorem already in the Mathlib library for lean. The add_lt_add_right theorem simply states that if you have a b &lt; c, then b + a &lt; c + a which is exactly what we need to prove the goal for the first case. As the first case has been completed, the infoview then switches to the second case which is reflected in the new h3 and reset goal.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: ¬c = d\n⊢ a + c &lt; b + d\n\n\n\n\nStep 4\nIn order to better work with our new hypothesis, I use a tactic which pushes the negation symbol further into the thing it is negating. This results in a hypothesis which can actually be applied later on.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: c ≠ d\n⊢ a + c &lt; b + d\n\n\n\n\nStep 5\nHere I am laying out a new hypothesis which will be useful later in the proof. This hypothesis seems like an obvious conclusion based on hypotheses two and three, but we must still lay it out simply for lean if we want to actually use it. The infoview panel always displays the most current goal, which is why it is displaying the goal for h4 rather than the main goal.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n  have h4 : c &lt; d := by\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: c ≠ d\n⊢ c &lt; d\n\n\n\n\nStep 6\nHere I apply another theorem already in lean which takes the information h3 and h2 gives us and shows our current goal. Writing out h4 like this is technically optional, as lean allows you to evaluate tactics within arguments for other tactics. Despite this, I personally find it more convenient and clear to write out extra hypotheses like this rather than just giving the body of the argument when necessary. Now that our new hypothesis has been proven, the infoview displays that we have no goals until we get back into our main theorem.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n  have h4 : c &lt; d := by\n    apply Ne.lt_of_le h3 h2\n\n  **done::\n\n\nNo goals\n\n\n\n\nStep 7\nI now use the calc tactic to work through the rest of the theorem. This tactic is quite useful as it allows us to chain together multiple equalities or inequalities while still giving proofs for each step. This is essentially a shortcut of writing out individual hypotheses and then using the rewrite tactic to get our desired goal.\nIn this case, I only need to do two steps of chaining inequalities, where I use transitivity to show that the starting value is less than the final value. It essentially follows the same path as the paragraph style proof, where the tactics add_lt_add_right and add_lt_add_left justify the steps taken.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n  have h4 : c &lt; d := by\n    apply Ne.lt_of_le h3 h2\n  exact calc\n    a + c &lt; b + c := add_lt_add_right h1 c\n    _ &lt; b + d := add_lt_add_left h4 b\n  done\n\n\nNo goals"
  },
  {
    "objectID": "Chap3.html#a-is-less-than-or-equal-to-b",
    "href": "Chap3.html#a-is-less-than-or-equal-to-b",
    "title": "3  Lean as a Theorem Prover",
    "section": "a is Less Than or Equal to b",
    "text": "a is Less Than or Equal to b\n\nSetting up the problem\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\n⊢ a ≤ b\n\n\n\n\nStep 1\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: ¬a ≤ b\n⊢ False\n\n\n\n\nStep 2\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\n⊢ False\n\n\n\n\nStep 3\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n\n    **done::\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\n⊢ ε &gt; 0\n\n\n\n\nStep 4\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n\n      **done::\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\n⊢ 0 &lt; a - b\n\n\n\n\nStep 5\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n    exact Iff.mpr sub_pos h2\n    done\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\nh3: ε &gt; 0\n⊢ False\n\n\n\n\nStep 6\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n    exact Iff.mpr sub_pos h2\n    done\n  have h4 : a ≤ b + ε := by\n\n    **done::\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\nh3: ε &gt; 0\n⊢ a ≤ b + ε\n\n\n\n\nStep 7\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n    exact Iff.mpr sub_pos h2\n    done\n  have h4 : a ≤ b + ε := by\n    apply h1\n\n    **done::\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\nh3: ε &gt; 0\n⊢ ε &gt; 0\n\n\n\n\nStep 8\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n    exact Iff.mpr sub_pos h2\n    done\n  have h4 : a ≤ b + ε := by\n    apply h1\n    apply h3\n    done\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\nh3: ε &gt; 0\nh4: a ≤ b + ε\n⊢ False\n\n\n\n\nStep 9\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n    exact Iff.mpr sub_pos h2\n    done\n  have h4 : a ≤ b + ε := by\n    apply h1\n    apply h3\n    done\n  dsimp at h4\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\nh3: ε &gt; 0\nh4: a ≤ b + (a - b) / 2\n⊢ False\n\n\n\n\nStep 10\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n    exact Iff.mpr sub_pos h2\n    done\n  have h4 : a ≤ b + ε := by\n    apply h1\n    apply h3\n    done\n  dsimp at h4\n  linarith\n  done\n\n\nNo goals"
  },
  {
    "objectID": "Chap3.html#absolute-convergence",
    "href": "Chap3.html#absolute-convergence",
    "title": "3  Lean as a Theorem Prover",
    "section": "Absolute Convergence",
    "text": "Absolute Convergence\nI will now display how I used to lean to demonstrate that a sequence converges if and only if the absolute value of that sequence converges.\n\nLaying out the goal\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n\n  **done::\n\n\ns1: ℕ → ℝ\n⊢ ConvergesTo s1 0 \n&gt;&gt;  ↔ ConvergesTo |s1| 0\n\n\n\n\nStep 1\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n\n  **done::\n\n\ns1: ℕ → ℝ\n⊢ (∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |s1 n - 0| &lt; ε) ↔\n&gt;&gt;    ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |abs s1 n - 0| &lt; ε\n\n\n\n\nStep 2\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    \n    done\n\n  **done::\n\n\ns1: ℕ → ℝ\nx: ℕ\n⊢ |s1 x| = |abs s1 x|\n\n\n\n\nStep 3\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\n⊢ (∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |s1 n - 0| &lt; ε) ↔\n&gt;&gt;    ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |abs s1 n - 0| &lt; ε\n\n\n\n\nStep 4\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\n⊢ (∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |s1 n - 0| &lt; ε) →\n&gt;&gt;    ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |abs s1 n - 0| &lt; ε\n\n\n\n\nStep 5\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  ∃ N, ∀ (n : ℕ), \n&gt;&gt;  n ≥ N → |s1 n - 0| &lt; ε\n⊢ ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |abs s1 n - 0| &lt; ε\n\n\n\n\nStep 6\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  ∃ N, ∀ (n : ℕ), \n&gt;&gt;  n ≥ N → |s1 n - 0| &lt; ε\n⊢ ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    N ≤ n → \n&gt;&gt;    |abs s1 n| &lt; ε\n\n\n\n\nStep 7\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n    simp at h1\n\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\nh1: ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;  ∃ N, ∀ (n : ℕ), \n&gt;&gt;  N ≤ n → |s1 n| &lt; ε\n⊢ ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    N ≤ n → \n&gt;&gt;    |abs s1 n| &lt; ε\n\n\n\n\nStep 8\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n    simp at h1\n    simp [← h3]\n\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\nh1: ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;  ∃ N, ∀ (n : ℕ), \n&gt;&gt;  N ≤ n → |s1 n| &lt; ε\n⊢ ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    N ≤ n → \n&gt;&gt;    |s1 n| &lt; ε\n\n\n\n\nStep 9\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n    simp at h1\n    simp [← h3]\n    apply h1\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\n⊢ (∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |abs s1 n - 0| &lt; ε) →\n&gt;&gt;    ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |s1 n - 0| &lt; ε\n\n\n\n\nStep 10\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n    simp at h1\n    simp [← h3]\n    apply h1\n  · --Reverse\n    intro h1\n    simp\n    simp at h1\n    simp_rw [h3]\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\nh1: ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;  ∃ N, ∀ (n : ℕ), \n&gt;&gt;  N ≤ n → |abs s1 n| &lt; ε\n⊢ ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;    ∃ N, ∀ (n : ℕ),\n&gt;&gt;    N ≤ n → \n&gt;&gt;    |abs s1 n| &lt; ε\n\n\n\n\nStep 11\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n    simp at h1\n    simp [← h3]\n    apply h1\n  · --Reverse\n    intro h1\n    simp\n    simp at h1\n    simp_rw [h3]\n    apply h1\n  done\n\n\nNo goals"
  },
  {
    "objectID": "Chap3.html#convergence-of-a-specific-sequence",
    "href": "Chap3.html#convergence-of-a-specific-sequence",
    "title": "3  Lean as a Theorem Prover",
    "section": "Convergence of a Specific Sequence",
    "text": "Convergence of a Specific Sequence\nThe following is an example of one situation where lean is somewhat lacking in comparison to a paragraph style proof. In this attempt to prove the convergence of a specific sequence, there were many issues with simplifying involving arbitrary variables and the change from natural numbers to real numbers. These sorts of things can be easily explained in a paragraph style proof, but required significant work to prove in lean.\nLean internally defines limits using filters and topology rather than the real analysis approach of epsilons, so the approach I was taking here is not the optimal approach for theorems involving limits in lean. While this high level definition of a limit is very useful for the people who know how to use it, it makes lean more difficult to use for those who have not yet studied topology. Definitions such as this start to portray that lean is not really something meant to be used for lower level mathematics, but rather complex and high level proofs.\nexample : ConvergesTo (fun (n : ℕ) ↦ \n    ((2 * n) / (n + 1))) 2 := by\n  intro ε\n  intro h1\n  obtain ⟨k, h13⟩ := \n    exists_nat_gt (2 / ε - 1) --Archimedean Property\n  use k\n  intro n\n  intro h2\n  dsimp\n  have h3 : (2 : ℝ) = 2 * ((n + 1) / (n + 1)) := by\n    have h4 : ((n + 1) / (n + 1)) = \n        (n + 1) * ((n + 1) : ℝ)⁻¹ := by\n      rfl\n      done\n    rw [h4]\n    have h5 : (n + 1) * ((n + 1) : ℝ)⁻¹ = 1 := by\n      rw [mul_inv_cancel]\n      exact Nat.cast_add_one_ne_zero n\n      done\n    rw [h5]\n    exact Eq.symm (mul_one 2)\n    done\n  nth_rewrite 2 [h3]\n  have h6 : 2 * ((↑n + 1) : ℝ) / (↑n + 1) = \n      ((2 * n) + 2) / (n + 1) := by\n    rw [Distribute n]\n    done\n  have h7 : 2 * (((↑n + 1) : ℝ) / (↑n + 1)) = \n      2 * (↑n + 1) / (↑n + 1) := by\n    rw [← mul_div_assoc 2 ((n + 1) : ℝ) ((n + 1) : ℝ)]\n    done\n  rw [h7]\n  rw [h6]\n  rw [div_sub_div_same (2 * n : ℝ) (2 * n + 2) (n + 1)]\n  rw [sub_add_cancel']\n  rw [abs_div]\n  simp\n  have h8 : |(↑n + 1 : ℝ)| = ↑n + 1 := by\n    simp\n    apply LT.lt.le (Nat.cast_add_one_pos ↑n)\n    done\n  rw [h8]\n  have h9 : (2 : ℝ) / (↑n + 1) ≤ 2 / (k + 1) := by\n    apply div_le_div_of_le_left\n    · --case 1\n      linarith\n      done\n    · --case 2\n      exact Nat.cast_add_one_pos k\n      done\n    · --case 3\n      convert add_le_add_right h2 1\n      apply Iff.intro\n      · --subcase 1\n        exact fun a =&gt; Nat.add_le_add_right h2 1\n        done\n      · --subcase 2\n        intro h14\n        apply add_le_add_right\n        exact Iff.mpr Nat.cast_le h2\n        done\n      done\n    done\n  have h10 : 2 / (k + 1) &lt; 2 / (2 / ε - 1 + 1) := by\n    apply div_lt_div_of_lt_left\n    · --case 1\n      linarith\n      done\n    · --case 2\n      simp\n      apply div_pos\n      linarith\n      apply h1\n      done\n    · --case 3\n      convert add_le_add_right h2 1\n      apply Iff.intro\n      · --subcase 1\n        intro h11\n        exact Nat.add_le_add_right h2 1\n        done\n      · --subcase 2\n        intro h11\n        have h12 : 2 / ε - 1 &lt; (k : ℝ) := by\n          simp only []\n          apply h13\n          done\n        exact add_lt_add_right h12 1\n        done\n      done\n    done\n  calc\n    2 / (↑n + 1) ≤ (2 : ℝ) / (k + 1) := by\n      apply h9\n      done\n    _ &lt; (2 : ℝ) / (2 / ε - 1 + 1) := by\n      apply h10\n      done\n    _ = ε := by\n      ring_nf\n      apply inv_inv\n      done\n  done"
  },
  {
    "objectID": "Chap1.html",
    "href": "Chap1.html",
    "title": "1  Real Analysis",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\n\n\n\n\nSymbol\nMeaning\n\n\n\n\n\\(\\neg\\)\nnot\n\n\n\\(\\wedge\\)\nand\n\n\n\\(\\vee\\)\nor\n\n\n\\(\\to\\)\nif … then\n\n\n\\(\\leftrightarrow\\)\niff (that is, if and only if)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\n\nEquivalence\n\n\n\n\n\nDe Morgan’s Laws\n\\(\\neg (P \\wedge Q)\\)\nis equivalent to\n\\(\\neg P \\vee \\neg Q\\)\n\n\n\n\\(\\neg (P \\vee Q)\\)\nis equivalent to\n\\(\\neg P \\wedge \\neg Q\\)\n\n\nDouble Negation Law\n\\(\\neg\\neg P\\)\nis equivalent to\n\\(P\\)\n\n\nConditional Laws\n\\(P \\to Q\\)\nis equivalent to\n\\(\\neg P \\vee Q\\)\n\n\n\n\\(P \\to Q\\)\nis equivalent to\n\\(\\neg(P \\wedge \\neg Q)\\)\n\n\nContrapositive Law\n\\(P \\to Q\\)\nis equivalent to\n\\(\\neg Q \\to \\neg P\\)\n\n\n\n\n\n\\(A \\cap B = \\{x \\mid x \\in A \\wedge x \\in B\\} = {}\\) the intersection of \\(A\\) and \\(B\\),\n\\(A \\cup B = \\{x \\mid x \\in A \\vee x \\in B\\} = {}\\) the union of \\(A\\) and \\(B\\),\n\\(A \\setmin B = \\{x \\mid x \\in A \\wedge x \\notin B\\} = {}\\) the difference of \\(A\\) and \\(B\\),\n\\(A \\symmdiff B = (A \\setmin B) \\cup (B \\setmin A) = {}\\) the symmetric difference of \\(A\\) and \\(B\\)."
  },
  {
    "objectID": "Chap2.html",
    "href": "Chap2.html",
    "title": "2  Functional Programming",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\n\n\\(\\forall x\\,P(x)\\) means “for all \\(x\\), \\(P(x)\\),”\n\n\n\n\n\n\nQuantifier Negation Laws\n\n\n\n\n\n\\(\\neg \\exists x\\,P(x)\\)\nis equivalent to\n\\(\\forall x\\,\\neg P(x)\\)\n\n\n\\(\\neg \\forall x\\,P(x)\\)\nis equivalent to\n\\(\\exists x\\,\\neg P(x)\\)"
  },
  {
    "objectID": "Chap4.html",
    "href": "Chap4.html",
    "title": "4  Conclusions",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\n\\[\n[x]_R = \\{y \\in A \\mid yRx\\}.\n\\] The set whose elements are all of these equivalence classes is called \\(A\\) mod \\(R\\). It is written \\(A/R\\), so \\[\nA/R = \\{[x]_R \\mid x \\in A\\}.\n\\] Note that \\(A/R\\) is a set whose elements are sets: for each \\(x \\in A\\), \\([x]_R\\) is a subset of \\(A\\), and \\([x]_R \\in A/R\\)."
  },
  {
    "objectID": "Chap5.html",
    "href": "Chap5.html",
    "title": "5  Works Cited",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\nThis work had been formatted and styled from the book How To Prove It With Lean, written by Daniel J. Velleman. How To Prove It With Lean contains short excerpts from How To Prove It: A Structured Approach, 3rd Edition, by Daniel J. Velleman and published by Cambridge University Press.\nexample : square1 = square2 := by rfl\n\n++#eval:: square1 7     --Answer: 49"
  },
  {
    "objectID": "Chap6.html",
    "href": "Chap6.html",
    "title": "6  Additional space",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\nExtra chapter to write more things if needed!!"
  }
]