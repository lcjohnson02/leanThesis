[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Untitled Lean Thesis",
    "section": "",
    "text": "Preface"
  },
  {
    "objectID": "index.html#making-chapters",
    "href": "index.html#making-chapters",
    "title": "Untitled Lean Thesis",
    "section": "Making Chapters",
    "text": "Making Chapters\nI am using this section to figure out how to incorporate a table of contents and different sections/chapters of the paper. This should prove useful in the final thesis and allow readers to quickly jump to important or interesting sections."
  },
  {
    "objectID": "index.html#incorporating-some-code",
    "href": "index.html#incorporating-some-code",
    "title": "Untitled Lean Thesis",
    "section": "Incorporating Some Code",
    "text": "Incorporating Some Code\nI will also be able to use some LaTeX equations within the document which could halp to make the paper look quite nice.\nIf \\(a &lt; b\\) and \\(c \\le d\\), prove that \\(a + c \\le b + d\\). It just so happens that I was able to prove this using lean!\nexample (a b c d : ℝ) (h1: a &lt; b) (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n  have h4 : c &lt; d := by\n    apply Ne.lt_of_le h3 h2\n  apply add_lt_add h1 h4\n  done\nNow to display the benefits of the lean infoview!"
  },
  {
    "objectID": "index.html#showing-the-infoview-with-picture-sequences",
    "href": "index.html#showing-the-infoview-with-picture-sequences",
    "title": "Untitled Lean Thesis",
    "section": "Showing the Infoview with Picture Sequences",
    "text": "Showing the Infoview with Picture Sequences\nNot going to do this now as I think the columns are far superior."
  },
  {
    "objectID": "index.html#showing-infoview-with-columns",
    "href": "index.html#showing-infoview-with-columns",
    "title": "Untitled Lean Thesis",
    "section": "Showing Infoview with Columns",
    "text": "Showing Infoview with Columns\nAs we can clearly see, this is the first step of the code and it can now be explained with great ease. Now onto the next step!\n\n\ntheorem Example_3_2_4_v2 (P Q R : Prop)\n    (h : P → (Q → R)) : ¬R → (P → ¬Q) := by\n  assume h2 : ¬R\n  assume h3 : P\n  **done::\n\n\nP Q R : Prop\nh : P → Q → R\nh2 : ¬R\nh3 : P\n⊢ ¬Q\n\n\nClick on the Extensions icon on the left side of the window, which is circled in red in the image above. That will bring up a list of available extensions:"
  },
  {
    "objectID": "index.html#acknowledgments",
    "href": "index.html#acknowledgments",
    "title": "Untitled Lean Thesis",
    "section": "Acknowledgments",
    "text": "Acknowledgments"
  },
  {
    "objectID": "Chap1.html",
    "href": "Chap1.html",
    "title": "1  Real Analysis",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\n\n\n\n\nSymbol\nMeaning\n\n\n\n\n\\(\\neg\\)\nnot\n\n\n\\(\\wedge\\)\nand\n\n\n\\(\\vee\\)\nor\n\n\n\\(\\to\\)\nif … then\n\n\n\\(\\leftrightarrow\\)\niff (that is, if and only if)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\n\nEquivalence\n\n\n\n\n\nDe Morgan’s Laws\n\\(\\neg (P \\wedge Q)\\)\nis equivalent to\n\\(\\neg P \\vee \\neg Q\\)\n\n\n\n\\(\\neg (P \\vee Q)\\)\nis equivalent to\n\\(\\neg P \\wedge \\neg Q\\)\n\n\nDouble Negation Law\n\\(\\neg\\neg P\\)\nis equivalent to\n\\(P\\)\n\n\nConditional Laws\n\\(P \\to Q\\)\nis equivalent to\n\\(\\neg P \\vee Q\\)\n\n\n\n\\(P \\to Q\\)\nis equivalent to\n\\(\\neg(P \\wedge \\neg Q)\\)\n\n\nContrapositive Law\n\\(P \\to Q\\)\nis equivalent to\n\\(\\neg Q \\to \\neg P\\)\n\n\n\n\n\n\\(A \\cap B = \\{x \\mid x \\in A \\wedge x \\in B\\} = {}\\) the intersection of \\(A\\) and \\(B\\),\n\\(A \\cup B = \\{x \\mid x \\in A \\vee x \\in B\\} = {}\\) the union of \\(A\\) and \\(B\\),\n\\(A \\setmin B = \\{x \\mid x \\in A \\wedge x \\notin B\\} = {}\\) the difference of \\(A\\) and \\(B\\),\n\\(A \\symmdiff B = (A \\setmin B) \\cup (B \\setmin A) = {}\\) the symmetric difference of \\(A\\) and \\(B\\)."
  },
  {
    "objectID": "Chap2.html",
    "href": "Chap2.html",
    "title": "2  Functional Programming",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\n\n\\(\\forall x\\,P(x)\\) means “for all \\(x\\), \\(P(x)\\),”\n\n\n\n\n\n\nQuantifier Negation Laws\n\n\n\n\n\n\\(\\neg \\exists x\\,P(x)\\)\nis equivalent to\n\\(\\forall x\\,\\neg P(x)\\)\n\n\n\\(\\neg \\forall x\\,P(x)\\)\nis equivalent to\n\\(\\exists x\\,\\neg P(x)\\)"
  },
  {
    "objectID": "Chap3.html#differences-from-paragraph-style-proofs",
    "href": "Chap3.html#differences-from-paragraph-style-proofs",
    "title": "3  Lean as a Theorem Prover",
    "section": "Differences From Paragraph Style Proofs",
    "text": "Differences From Paragraph Style Proofs\nDespite the incredible power that lean could provide in the verification of mathematical proofs, this does pose some difficulties, namely the ease with which the aforementioned proofs can be written up. Typically, proofs are simply written up in a paragraph style, where the steps being taken and the theorems being applied are laid out in plain terms so that it can be easily understood by fellow mathematicians. There are often times when mathematicians will take things for granted or skip over steps that they think the reader will either already know to be fact or can easily reason out for themselves when writing out typical proofs. This lax approach for conveying information simply does not work when trying to communicate with technology, and a much more specific and methodical approach must be adopted in order to take advantage of the logical verification benefits. Thankfully, lean has a community working to create libraries of previously proven theorems that can be applied to speed up the writing and verification of future proofs. This thankfully means that all proofs do not need to be taken all the way back to basic axioms: Users can save time by avoiding proving adjacent theorems and instead focus only on the immediately relevant steps of their proof.\nFor each of the following proofs, I will first provide a typical “paragraph style” version of the proof, so the differences between the two can easily be compared. ## Inequality Addition\n\nWhatever the problem is\n\n\nProof. whatever the solution to that problem is.  □\n\nStep 1 Putting the initial theorem we want to show in lean code and observing the final goal in the infoview.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  \n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\n⊢ a + c &lt; b + d\n\n\nStep 2\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: c = d\n⊢ a + c &lt; b + d\n\n\nStep 3\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: c = d\n⊢ a + d &lt; b + d\n\n\nStep 4\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: ¬c = d\n⊢ a + c &lt; b + d\n\n\nStep 5\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: c ≠ d\n⊢ a + c &lt; b + d\n\n\nStep 6a We can see here that the lean infoview is now displaying my new hypothesis as the current goal.\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n  have h4 : c &lt; d := by\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nabcd: ℝ\nh1: a &lt; b\nh2: c ≤ d\nh3: c ≠ d\n⊢ c &lt; d\n\n\nStep 6b\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n  have h4 : c &lt; d := by\n    apply Ne.lt_of_le h3 h2\n\n  **done::\n\n\nNo goals\n\n\nStep 7\n\n\nexample (a b c d : ℝ) (h1: a &lt; b) \n    (h2 : c ≤ d) : a + c &lt; b + d := by\n  by_cases h3 : c = d\n  rw [h3]\n  apply add_lt_add_right h1\n  push_neg at h3\n  have h4 : c &lt; d := by\n    apply Ne.lt_of_le h3 h2\n  apply add_lt_add h1 h4\n  done\n\n\nNo goals"
  },
  {
    "objectID": "Chap3.html#a-is-less-than-or-equal-to-b",
    "href": "Chap3.html#a-is-less-than-or-equal-to-b",
    "title": "3  Lean as a Theorem Prover",
    "section": "a is Less Than or Equal to b",
    "text": "a is Less Than or Equal to b\nSetting up the problem\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\n⊢ a ≤ b\n\n\nStep 1\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: ¬a ≤ b\n⊢ False\n\n\nStep 2\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\n⊢ False\n\n\nStep 3\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n\n    **done::\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\n⊢ ε &gt; 0\n\n\nStep 4\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n\n      **done::\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\n⊢ 0 &lt; a - b\n\n\nStep 5\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n    exact Iff.mpr sub_pos h2\n    done\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\nh3: ε &gt; 0\n⊢ False\n\n\nStep 6\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n    exact Iff.mpr sub_pos h2\n    done\n  have h4 : a ≤ b + ε := by\n\n    **done::\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\nh3: ε &gt; 0\n⊢ a ≤ b + ε\n\n\nStep 7\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n    exact Iff.mpr sub_pos h2\n    done\n  have h4 : a ≤ b + ε := by\n    apply h1\n\n    **done::\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\nh3: ε &gt; 0\n⊢ ε &gt; 0\n\n\nStep 8\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n    exact Iff.mpr sub_pos h2\n    done\n  have h4 : a ≤ b + ε := by\n    apply h1\n    apply h3\n    done\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\nh3: ε &gt; 0\nh4: a ≤ b + ε\n⊢ False\n\n\nStep 9\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n    exact Iff.mpr sub_pos h2\n    done\n  have h4 : a ≤ b + ε := by\n    apply h1\n    apply h3\n    done\n  dsimp at h4\n\n  **done::\n\n\nR: Type u_1\ninst✝: Ring R\nab: ℝ\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  a ≤ b + ε\nh2: b &lt; a\nε: ℝ := (a - b) / 2\nh3: ε &gt; 0\nh4: a ≤ b + (a - b) / 2\n⊢ False\n\n\nStep 10\n\n\nexample (a b : ℝ) (h1 : ∀ ε : ℝ, \n    ε &gt; 0 → a ≤ b + ε) : \n    a ≤ b := by\n  by_contra h2\n  push_neg at h2\n  let ε := (a - b) / 2\n  have h3 : ε &gt; 0 := by\n    refine half_pos ?h\n    exact Iff.mpr sub_pos h2\n    done\n  have h4 : a ≤ b + ε := by\n    apply h1\n    apply h3\n    done\n  dsimp at h4\n  linarith\n  done\n\n\nNo goals"
  },
  {
    "objectID": "Chap3.html#absolute-convergence",
    "href": "Chap3.html#absolute-convergence",
    "title": "3  Lean as a Theorem Prover",
    "section": "Absolute Convergence",
    "text": "Absolute Convergence\nI will now display how I used to lean to demonstrate that a sequence converges if and only if the absolute value of that sequence converges.\nLaying out the goal\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n\n  **done::\n\n\ns1: ℕ → ℝ\n⊢ ConvergesTo s1 0 \n&gt;&gt;  ↔ ConvergesTo |s1| 0\n\n\nStep 1\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n\n  **done::\n\n\ns1: ℕ → ℝ\n⊢ (∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |s1 n - 0| &lt; ε) ↔\n&gt;&gt;    ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |abs s1 n - 0| &lt; ε\n\n\nStep 2\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    \n    done\n\n  **done::\n\n\ns1: ℕ → ℝ\nx: ℕ\n⊢ |s1 x| = |abs s1 x|\n\n\nStep 3\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\n⊢ (∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |s1 n - 0| &lt; ε) ↔\n&gt;&gt;    ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |abs s1 n - 0| &lt; ε\n\n\nStep 4\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\n⊢ (∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |s1 n - 0| &lt; ε) →\n&gt;&gt;    ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |abs s1 n - 0| &lt; ε\n\n\nStep 5\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  ∃ N, ∀ (n : ℕ), \n&gt;&gt;  n ≥ N → |s1 n - 0| &lt; ε\n⊢ ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |abs s1 n - 0| &lt; ε\n\n\nStep 6\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\nh1: ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;  ∃ N, ∀ (n : ℕ), \n&gt;&gt;  n ≥ N → |s1 n - 0| &lt; ε\n⊢ ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    N ≤ n → \n&gt;&gt;    |abs s1 n| &lt; ε\n\n\nStep 7\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n    simp at h1\n\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\nh1: ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;  ∃ N, ∀ (n : ℕ), \n&gt;&gt;  N ≤ n → |s1 n| &lt; ε\n⊢ ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    N ≤ n → \n&gt;&gt;    |abs s1 n| &lt; ε\n\n\nStep 8\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n    simp at h1\n    simp [← h3]\n\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\nh1: ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;  ∃ N, ∀ (n : ℕ), \n&gt;&gt;  N ≤ n → |s1 n| &lt; ε\n⊢ ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    N ≤ n → \n&gt;&gt;    |s1 n| &lt; ε\n\n\nStep 9\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n    simp at h1\n    simp [← h3]\n    apply h1\n  · --Reverse\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\n⊢ (∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |abs s1 n - 0| &lt; ε) →\n&gt;&gt;    ∀ (ε : ℝ), ε &gt; 0 → \n&gt;&gt;    ∃ N, ∀ (n : ℕ), \n&gt;&gt;    n ≥ N → \n&gt;&gt;    |s1 n - 0| &lt; ε\n\n\nStep 10\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n    simp at h1\n    simp [← h3]\n    apply h1\n  · --Reverse\n    intro h1\n    simp\n    simp at h1\n    simp_rw [h3]\n\n  **done::\n\n\ns1: ℕ → ℝ\nh3: ∀ (x : ℕ), |s1 x| = \n&gt;&gt;  |abs s1 x|\nh1: ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;  ∃ N, ∀ (n : ℕ), \n&gt;&gt;  N ≤ n → |abs s1 n| &lt; ε\n⊢ ∀ (ε : ℝ), 0 &lt; ε → \n&gt;&gt;    ∃ N, ∀ (n : ℕ),\n&gt;&gt;    N ≤ n → \n&gt;&gt;    |abs s1 n| &lt; ε\n\n\nStep 11\n\n\nexample (s1 : ℕ → ℝ) : \n    ConvergesTo s1 (0 : ℝ) ↔\n    ConvergesTo (abs s1) (0 : ℝ) \n    := by\n  rw [ConvergesTo]\n  rw [ConvergesTo]\n  have h3 (x : ℕ) : |s1 x| = \n      |abs s1 x| := by\n    simp [abs]\n    done\n  apply Iff.intro\n  · --Forwards\n    intro h1\n    simp\n    simp at h1\n    simp [← h3]\n    apply h1\n  · --Reverse\n    intro h1\n    simp\n    simp at h1\n    simp_rw [h3]\n    apply h1\n  done\n\n\nNo goals"
  },
  {
    "objectID": "Chap3.html#convergence-of-a-specific-sequence",
    "href": "Chap3.html#convergence-of-a-specific-sequence",
    "title": "3  Lean as a Theorem Prover",
    "section": "Convergence of a Specific Sequence",
    "text": "Convergence of a Specific Sequence\nexample of lean bad.\nexample : ConvergesTo (fun (n : ℕ) ↦ \n    ((2 * n) / (n + 1))) 2 := by\n  intro ε\n  intro h1\n  obtain ⟨k, h13⟩ := \n    exists_nat_gt (2 / ε - 1) --Archimedean Property\n  use k\n  intro n\n  intro h2\n  dsimp\n  have h3 : (2 : ℝ) = 2 * ((n + 1) / (n + 1)) := by\n    have h4 : ((n + 1) / (n + 1)) = \n        (n + 1) * ((n + 1) : ℝ)⁻¹ := by\n      rfl\n      done\n    rw [h4]\n    have h5 : (n + 1) * ((n + 1) : ℝ)⁻¹ = 1 := by\n      rw [mul_inv_cancel]\n      exact Nat.cast_add_one_ne_zero n\n      done\n    rw [h5]\n    exact Eq.symm (mul_one 2)\n    done\n  nth_rewrite 2 [h3]\n  have h6 : 2 * ((↑n + 1) : ℝ) / (↑n + 1) = \n      ((2 * n) + 2) / (n + 1) := by\n    rw [Distribute n]\n    done\n  have h7 : 2 * (((↑n + 1) : ℝ) / (↑n + 1)) = \n      2 * (↑n + 1) / (↑n + 1) := by\n    rw [← mul_div_assoc 2 ((n + 1) : ℝ) ((n + 1) : ℝ)]\n    done\n  rw [h7]\n  rw [h6]\n  rw [div_sub_div_same (2 * n : ℝ) (2 * n + 2) (n + 1)]\n  rw [sub_add_cancel']\n  rw [abs_div]\n  simp\n  have h8 : |(↑n + 1 : ℝ)| = ↑n + 1 := by\n    simp\n    apply LT.lt.le (Nat.cast_add_one_pos ↑n)\n    done\n  rw [h8]\n  have h9 : (2 : ℝ) / (↑n + 1) ≤ 2 / (k + 1) := by\n    apply div_le_div_of_le_left\n    · --case 1\n      linarith\n      done\n    · --case 2\n      exact Nat.cast_add_one_pos k\n      done\n    · --case 3\n      convert add_le_add_right h2 1\n      apply Iff.intro\n      · --subcase 1\n        exact fun a =&gt; Nat.add_le_add_right h2 1\n        done\n      · --subcase 2\n        intro h14\n        apply add_le_add_right\n        exact Iff.mpr Nat.cast_le h2\n        done\n      done\n    done\n  have h10 : 2 / (k + 1) &lt; 2 / (2 / ε - 1 + 1) := by\n    apply div_lt_div_of_lt_left\n    · --case 1\n      linarith\n      done\n    · --case 2\n      simp\n      apply div_pos\n      linarith\n      apply h1\n      done\n    · --case 3\n      convert add_le_add_right h2 1\n      apply Iff.intro\n      · --subcase 1\n        intro h11\n        exact Nat.add_le_add_right h2 1\n        done\n      · --subcase 2\n        intro h11\n        have h12 : 2 / ε - 1 &lt; (k : ℝ) := by\n          simp only []\n          apply h13\n          done\n        exact add_lt_add_right h12 1\n        done\n      done\n    done\n  calc\n    2 / (↑n + 1) ≤ (2 : ℝ) / (k + 1) := by\n      apply h9\n      done\n    _ &lt; (2 : ℝ) / (2 / ε - 1 + 1) := by\n      apply h10\n      done\n    _ = ε := by\n      ring_nf\n      apply inv_inv\n      done\n  done"
  },
  {
    "objectID": "Chap3.html#proofs-involving-quantifiers",
    "href": "Chap3.html#proofs-involving-quantifiers",
    "title": "3  Lean as a Theorem Prover",
    "section": "3.3. Proofs Involving Quantifiers",
    "text": "3.3. Proofs Involving Quantifiers\n\nSuppose \\(B\\) is a set and \\(\\mathcal{F}\\) is a family of sets. If \\(\\bigcup\\mathcal{F} \\subseteq B\\) then \\(\\mathcal{F} \\subseteq \\mathscr{P}(B)\\).\n\n\nProof. Suppose \\(\\bigcup \\mathcal{F} \\subseteq B\\). Let \\(x\\) be an arbitrary element of \\(\\mathcal{F}\\). Let \\(y\\) be an arbitrary element of \\(x\\). Since \\(y \\in x\\) and \\(x \\in \\mathcal{F}\\), by the definition of \\(\\bigcup \\mathcal{F}\\), \\(y \\in \\bigcup \\mathcal{F}\\). But then since \\(\\bigcup \\mathcal{F} \\subseteq B\\), \\(y \\in B\\). Since \\(y\\) was an arbitrary element of \\(x\\), we can conclude that \\(x \\subseteq B\\), so \\(x \\in \\mathscr{P}(B)\\). But \\(x\\) was an arbitrary element of \\(\\mathcal{F}\\), so this shows that \\(\\mathcal{F} \\subseteq \\mathscr{P}(B)\\), as required.  □\n\n\nFor every integer \\(n\\), \\(6 \\mid n\\) iff \\(2 \\mid n\\) and \\(3 \\mid n\\).\n\n\nProof. Let \\(n\\) be an arbitrary integer.\n(\\(\\to\\)) Suppose \\(6 \\mid n\\). Then we can choose an integer \\(k\\) such that \\(6k=n\\). Therefore \\(n = 6k = 2(3k)\\), so \\(2 \\mid n\\), and similarly \\(n = 6k = 3(2k)\\), so \\(3 \\mid n\\).\n(\\(\\leftarrow\\)) Suppose \\(2 \\mid n\\) and \\(3 \\mid n\\). Then we can choose integers \\(j\\) and \\(k\\) such that \\(n = 2j\\) and \\(n = 3k\\). Therefore \\(6(j-k) = 6j - 6k = 3(2j) - 2(3k) = 3n - 2n = n\\), so \\(6 \\mid n\\).  □"
  },
  {
    "objectID": "Chap4.html",
    "href": "Chap4.html",
    "title": "4  Conclusions",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\n\\[\n[x]_R = \\{y \\in A \\mid yRx\\}.\n\\] The set whose elements are all of these equivalence classes is called \\(A\\) mod \\(R\\). It is written \\(A/R\\), so \\[\nA/R = \\{[x]_R \\mid x \\in A\\}.\n\\] Note that \\(A/R\\) is a set whose elements are sets: for each \\(x \\in A\\), \\([x]_R\\) is a subset of \\(A\\), and \\([x]_R \\in A/R\\)."
  },
  {
    "objectID": "Chap5.html",
    "href": "Chap5.html",
    "title": "5  Works Cited",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\nThis work had been formatted and styled from the book How To Prove It With Lean, written by Daniel J. Velleman. How To Prove It With Lean contains short excerpts from How To Prove It: A Structured Approach, 3rd Edition, by Daniel J. Velleman and published by Cambridge University Press.\nexample : square1 = square2 := by rfl\n\n++#eval:: square1 7     --Answer: 49"
  },
  {
    "objectID": "Chap6.html",
    "href": "Chap6.html",
    "title": "6  Additional space",
    "section": "",
    "text": "$$\n\\newcommand{\\setmin}{\\mathbin{\\backslash}}\n\\newcommand{\\symmdiff}{\\bigtriangleup}\n$$\n\n\n\n\nExtra chapter to write more things if needed!!"
  }
]