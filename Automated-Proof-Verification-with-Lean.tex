% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  letterpaper,
]{scrreprt}

\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else  
    % xetex/luatex font selection
  \setmonofont[]{JuliaMono}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\setcounter{secnumdepth}{0}
% Make \paragraph and \subparagraph free-standing
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{241,243,245}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.40,0.45,0.13}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.28,0.35,0.67}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.46,0.62}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.07,0.07,0.07}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\newlength{\cslhangindent}
\setlength{\cslhangindent}{1.5em}
\newlength{\csllabelwidth}
\setlength{\csllabelwidth}{3em}
\newlength{\cslentryspacingunit} % times entry-spacing
\setlength{\cslentryspacingunit}{\parskip}
\newenvironment{CSLReferences}[2] % #1 hanging-ident, #2 entry spacing
 {% don't indent paragraphs
  \setlength{\parindent}{0pt}
  % turn on hanging indent if param 1 is 1
  \ifodd #1
  \let\oldpar\par
  \def\par{\hangindent=\cslhangindent\oldpar}
  \fi
  % set entry spacing
  \setlength{\parskip}{#2\cslentryspacingunit}
 }%
 {}
\usepackage{calc}
\newcommand{\CSLBlock}[1]{#1\hfill\break}
\newcommand{\CSLLeftMargin}[1]{\parbox[t]{\csllabelwidth}{#1}}
\newcommand{\CSLRightInline}[1]{\parbox[t]{\linewidth - \csllabelwidth}{#1}\break}
\newcommand{\CSLIndent}[1]{\hspace{\cslhangindent}#1}

\usepackage{mathrsfs}
\usepackage{twemojis}
\usepackage[normalem]{ulem}
\usepackage{scrlayer-scrpage}
\usepackage{textpos}
\automark{section}
\newcommand{\copyrightnotice}{\footnotesize\ Logan Johnson}
\newcommand{\longcopyrightnotice}{\footnotesize\ Logan Johnson 2023}
\setkomafont{pagefoot}{\upshape}
\ifoot*{\longcopyrightnotice}
\cfoot*{}
\ofoot*{\pagemark}

\makeatletter
\def\redsquiggly{\bgroup \markoverwith{\textcolor{red}{\lower3.5\p@\hbox{\sixly \char58}}}\ULon}
\def\brownsquiggly{\bgroup \markoverwith{\textcolor[HTML]{B8860B}{\lower3.5\p@\hbox{\sixly \char58}}}\ULon}
\def\bluesquiggly{\bgroup \markoverwith{\textcolor[HTML]{1E90FF}{\lower3.5\p@\hbox{\sixly \char58}}}\ULon}
\makeatother

\renewcommand{\NormalTok}[1]{\textcolor[HTML]{000000}{#1}}
\renewcommand{\KeywordTok}[1]{\textcolor[HTML]{0000FF}{#1}}
\renewcommand{\SpecialCharTok}[1]{}
\renewcommand{\ErrorTok}[1]{\redsquiggly{#1}}
\renewcommand{\WarningTok}[1]{\redsquiggly{\textcolor[HTML]{0000FF}{#1}}}
\renewcommand{\StringTok}[1]{\textcolor[HTML]{A52A2A}{#1}}
\renewcommand{\CommentTok}[1]{\textcolor[HTML]{008000}{#1}}
\renewcommand{\InformationTok}[1]{\textcolor[HTML]{D2691E}{\textbf{#1}}}
\renewcommand{\RegionMarkerTok}[1]{▼\:\textcolor[HTML]{008000}{\textbf{#1}}}
\renewcommand{\SpecialStringTok}[1]{\textcolor[HTML]{4682B4}{\textbf{#1}}}
\renewcommand{\ConstantTok}[1]{\textcolor[HTML]{DC143C}{#1}}
\renewcommand{\AnnotationTok}[1]{\brownsquiggly{#1}}
\renewcommand{\AlertTok}[1]{\brownsquiggly{\textcolor[HTML]{0000FF}{#1}}}
\renewcommand{\OtherTok}[1]{\bluesquiggly{#1}}
\renewcommand{\DocumentationTok}[1]{\bluesquiggly{\textcolor[HTML]{0000FF}{#1}}}

\newenvironment{ind}
	{\begin{list}{}{\setlength{\leftmargin}{1em}}\item\relax}
	{\end{list}}

%redefines Shaded so it can't break
\newcommand{\nobreakShaded}{\renewenvironment{Shaded}
	{\begin{tcolorbox}[frame hidden, enhanced, interior hidden, boxrule=0pt,
		borderline west={3pt}{0pt}{shadecolor}, sharp corners]}
	{\end{tcolorbox}}}

%Make end of environment ignore pars that come after it
\def\useignorespacesandallpars#1\ignorespaces\fi{%
#1\fi\ignorespacesandallpars}

\makeatletter
\def\ignorespacesandallpars{%
  \@ifnextchar\par
    {\expandafter\ignorespacesandallpars\@gobble}%
    {}%
}
\makeatother

\newenvironment{inpt}
	{\nobreakShaded\noindent\begin{minipage}[t]{0.63\textwidth}
		\uline{Lean File}}
	{\end{minipage}\hfill\useignorespacesandallpars}

\newenvironment{outpt}
	{\nobreakShaded\begin{minipage}[t]{0.32\textwidth}
		\uline{Tactic State in Infoview}}
	{\end{minipage}}

\newenvironment{bef}
	{\nobreakShaded\noindent\begin{minipage}[t]{0.475\textwidth}
		\uline{Tactic State Before Using Strategy}}
	{\end{minipage}\hfill\useignorespacesandallpars}

\newenvironment{aft}
	{\nobreakShaded\begin{minipage}[t]{0.475\textwidth}
		\uline{Tactic State After Using Strategy}}
	{\end{minipage}}

\newenvironment{numex}[1]
	{\begin{minipage}[t]{0.04\textwidth}\vspace{8pt}{#1}.
		\end{minipage}\nobreakShaded\begin{minipage}[t]{0.96\textwidth}\vspace{0pt}}
	{\end{minipage}}

\newenvironment{mdsk}
	{\medskip}
	{}

\newenvironment{absnobreak}
  {\par\nobreak\vfil\penalty0\vfilneg
   \vtop\bgroup}
  {\par\xdef\tpd{\the\prevdepth}\egroup
   \prevdepth=\tpd}

\newcommand{\excl}[1]{}
\newcommand{\incl}[1]{#1}

\newcommand{\setmin}{\mathbin{\backslash}}
\newcommand{\symmdiff}{\bigtriangleup}

\pagenumbering{roman}  %So front matter uses roman numerals.  Switch back to arabic at beginning of preface.
\publishers{\longcopyrightnotice}
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{bookmark}{}{\usepackage{bookmark}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Table of contents}
\else
  \newcommand\contentsname{Table of contents}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{List of Figures}
\else
  \newcommand\listfigurename{List of Figures}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{List of Tables}
\else
  \newcommand\listtablename{List of Tables}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figure}
\else
  \newcommand\figurename{Figure}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Table}
\else
  \newcommand\tablename{Table}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{List of Listings}}
\usepackage{amsthm}
\theoremstyle{remark}
\AtBeginDocument{\renewcommand*{\proofname}{Proof}}
\newtheorem*{remark}{Remark}
\newtheorem*{solution}{Solution}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother
\makeatletter
\@ifpackageloaded{tcolorbox}{}{\usepackage[skins,breakable]{tcolorbox}}
\makeatother
\makeatletter
\@ifundefined{shadecolor}{\definecolor{shadecolor}{rgb}{.97, .97, .97}}
\makeatother
\makeatletter
\makeatother
\makeatletter
\makeatother
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same} % disable monospaced font for URLs
\hypersetup{
  pdftitle={Automated Proof Verification with Lean},
  pdfauthor={Logan Johnson},
  colorlinks=true,
  linkcolor={blue},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}

\title{Automated Proof Verification with Lean}
\author{Logan Johnson}
\date{Invalid Date}

\begin{document}
\newcommand{\fromtop}[1]{%
  \dimexpr-1in-\topskip-\topmargin-\headheight-\headsep+#1\relax
}
\newcommand{\fromleft}[1]{%
  \dimexpr-1in-\oddsidemargin+#1\relax
}
\setlength{\textwidth}{6in}
\begin{titlepage}
\cleardoublepage
\thispagestyle{empty}
\begin{textblock*}{\paperwidth}(\fromleft{0cm},\fromtop{144pt})
\centering
Automated Proof Verification with Lean
\end{textblock*}
\begin{textblock*}{\paperwidth}(\fromleft{0cm},\fromtop{300pt})
\centering
A Thesis Submitted to the Faculty of\\
\vspace{12pt}
Georgetown College\\
\vspace{12pt}
In Partial Fulfillment of the Requirements for the\\
\vspace{12pt}
Honors Program
\end{textblock*}
\begin{textblock*}{\paperwidth}(\fromleft{0cm},\fromtop{492pt})
\centering
By\\
\vspace{12pt}
Logan Johnson
\end{textblock*}
\begin{textblock*}{\paperwidth}(\fromleft{0cm},\fromtop{600pt})
\centering
Georgetown, Kentucky\\
\vspace{12pt}
May 2024
\end{textblock*}
\pagebreak
\thispagestyle{empty}
\begin{textblock*}{\paperwidth}(\fromleft{0cm},\fromtop{180pt})
\centering
Abstract\\
\vspace{12pt}
Automated Proof Verification with Lean\\
\vspace{12pt}
Logan C. Johnson\\
\vspace{12pt}
Director: Dr. Homer White, Ph.D.
\end{textblock*}
\begin{textblock*}{\textwidth}(\fromleft{1.5in},\fromtop{300pt})
\raggedright
This thesis is meant to explore Lean Theorem Prover and address its potential in automating the 
verification of mathematical proofs. I explore how lean functions as a functional programming 
language and how this changes the proof process. This leads to Lean treating theorems as functions 
that essentially convert known hypotheses into a new conclusion. Lean does this by taking advantage 
of typed objects rather than following a traditional set theory approach. I then directly compare 
the ways in which Lean proofs differ from traditional paragraph-style proofs and try to explain 
the upsides and downsides of these differences. Lean does end up being useful for automated proof 
verification, so long as one is able to learn the language and get used to the different style of 
proof. It is still being developed and is only becoming more powerful with time, so its userbase will 
likely only continue to grow.
\end{textblock*}
\pagebreak
\thispagestyle{empty}
\begin{textblock*}{\paperwidth}(\fromleft{2in},\fromtop{144pt})
APPROVED BY THE DIRECTOR OF HONORS THESES:
\end{textblock*}
\begin{textblock*}{\paperwidth}(\fromleft{3in},\fromtop{192pt})
\underline{\hspace{4.5in}}
\end{textblock*}
\begin{textblock*}{\paperwidth}(\fromleft{3in},\fromtop{216pt})
Dr. Homer White, Department of Mathematics
\end{textblock*}
\begin{textblock*}{\paperwidth}(\fromleft{2in},\fromtop{396pt})
APPROVED BY THE HONORS PROGRAM:
\end{textblock*}
\begin{textblock*}{\paperwidth}(\fromleft{2in},\fromtop{444pt})
\underline{\hspace{4.5in}}
\end{textblock*}
\begin{textblock*}{\paperwidth}(\fromleft{2in},\fromtop{468pt})
Dr. Barbara Burch, Director
\end{textblock*}
\begin{textblock*}{\paperwidth}(\fromleft{1.5in},\fromtop{612pt})
DATE:\underline{\hspace{2in}}
\end{textblock*}
\end{titlepage}%Can't be in preamble because Quarto loads amsthm too late.
\theoremstyle{plain}
\newtheorem*{thm}{Theorem}
\newcommand{\thmnm}{Theorem}
\newtheorem*{namedthm}{\thmnm}
\theoremstyle{definition}
\newtheorem*{dfn}{Definition}
\newcommand{\defnm}{Definition}
\newtheorem*{nameddfn}{\defnm}

\newenvironment{nthm}[1]
  {\renewcommand{\thmnm}{#1}\begin{namedthm}}
  {\end{namedthm}}

\newenvironment{ndfn}[1]
  {\renewcommand{\defnm}{#1}\begin{nameddfn}}
  {\end{nameddfn}}

\newenvironment{npf}[1]
  {\begin{proof}[#1]}
  {\end{proof}}

% Usage:
% ::: {.thm} will create an unnumbered thm environment with title Theorem.
% ::: {.nthm arguments="Name of Theorem"} will create an unnumbered theorem whose title is Name of Theorem.

\let\oldgreater\textgreater
\renewcommand{\textgreater}{\null\oldgreater}   % To prevent => changing to double arrow

\ifdefined\Shaded\renewenvironment{Shaded}{\begin{tcolorbox}[frame hidden, breakable, enhanced, sharp corners, boxrule=0pt, interior hidden, borderline west={3pt}{0pt}{shadecolor}]}{\end{tcolorbox}}\fi

\renewcommand*\contentsname{Table of contents}
{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{1}
\tableofcontents
}
\bookmarksetup{startatroot}

\hypertarget{acknowledgements}{%
\chapter*{Acknowledgements}\label{acknowledgements}}
\addcontentsline{toc}{chapter}{Acknowledgements}

\markboth{Acknowledgements}{Acknowledgements}

\pagenumbering{arabic}

Firstly, I need to mention that this entire thesis has been formatted
using the book \emph{How To Prove It With Lean,} written by Daniel J.
Velleman. His book was instrumental in learning to program in Lean and
without this book all of my work would have been much more difficult. I
would also like to give thanks to my thesis director Dr.~White for the
time and effort that he has put into this project. He chose to work with
me on this project over the summer and without his guidance I could not
have completed something of this scale. Another round of thanks should
be given to my second reader, \textbf{\emph{Name Here.}} Elaborate
further. Finally, I would like to thank my parents for supporting me
throughout all of my schooling and always taking care of me.

\bookmarksetup{startatroot}

\hypertarget{preface}{%
\chapter*{Preface}\label{preface}}
\addcontentsline{toc}{chapter}{Preface}

\markboth{Preface}{Preface}

This thesis is intended to address the potential that the Lean
programming language has in aiding with the verification of mathematical
proofs. Lean was developed as a functional programming language with the
intent that it could be used for theorem proving. Development on the
language started in 2013 and has now seen four different fully released
versions. I would recommend that while reading this thesis, you download
Lean and put my code onto your own machine to see how it works. I have
included a file on my github repository which contains code for each of
the examples I put into the ``Lean as a Theorem Prover'' section of the
thesis. The \texttt{Mathlib} package is not contained within this
repository, so in order to see my examples for yourself, you will need
to copy the examples into your own Lean project. While I have done my
best to show the language in a way that displays both its positive and
negative aspects, the best way to get a grasp for that will be to try it
out for yourself. Instructions on how to install a copy of Lean can be
found \href{https://lean-lang.org/lean4/doc/quickstart.html}{here}.

If you find this language interesting and would like to learn more, the
textbook \href{https://djvelleman.github.io/HTPIwL/}{How To Prove It
With Lean} is a great starting point, and the textbook
\href{https://leanprover-community.github.io/mathematics_in_lean/index.html}{Mathematics
in Lean} goes into further detail on some higher level topics such as
calculus and topology. Lean also has a dedicated forum on
\href{https://leanprover.zulipchat.com}{Zulip} where other users can
help address any questions regarding the language. I used the forum a
few times while working on this project, and the feedback I recieved was
quite helpful.

\bookmarksetup{startatroot}

\hypertarget{functional-programming}{%
\chapter{Functional Programming}\label{functional-programming}}

\hypertarget{basic-functional-programming}{%
\section{Basic Functional
Programming}\label{basic-functional-programming}}

A programming paradigm is a way of categorizing any given programming
language based on its features and how it computes its code. Programming
languages will typically fall into one main programming paradigm even if
they are capable of using multiple, sometimes chosen because of the
intended use of the language. Lean happens to be a functional
programming language, meaning that every single thing in Lean is a
function. A deep understanding of functional programming is not
necessary to utilise Lean, but in order to take full advantage of the
theorem proving capabilities it is able to provide, it helps to have
some idea of how the language works.

When we write out mathematical proofs on paper, it is easy to think of
each step we take or theorem we apply as part of a bridge between the
hypotheses we are assuming to be true and the result we are trying to
prove. Another way of thinking about each step in the proof process is
as that of a function. In some proofs this is easier to picture than
others, but when we take a step in a proof, we are essentially
converting some fact that we know to be true into a different fact that
we now know to be true. This process repeats over and over again until
eventually we have converted something into our end goal. When the
process of proving is thought of in this way it becomes more clear how
Lean is able to verify proofs.

We could think of Lean as a sort of kitchen in which we are cooking
proofs out of raw hypotheses. When making a cake, we have to start with
eggs, flour, milk, sugar, and a few other ingredients and take specific
steps towards finishing the cake. We may first crack the eggs open
before mixing them in alongside the flour and sugar. Later on we need to
pour the batter into a pan and then bake that in the oven. Completing a
proof is done in a somewhat similar way, as we mix hypotheses together
to get closer to our goal and use different methods of proof such as
contradiction or induction like an oven that cooks our hypotheses into a
finished proof. Lean effectively provides a space where we can do that
cooking while it verifies that we didn't skip any steps in the process
along the way. Lean makes sure that we actually cracked the eggs before
mixing them in just as is makes sure we are applying a theorem in
exactly the way in which it needs to be applied.

One more important thing to mention before diving into an example is
that Lean also takes advantages of \emph{types.} We could say for
example that \(5\) has type Nat, or natural. This means that every
single thing in Lean has a given type, which can lead to some issues if
typing is not taken care of correctly. Just as some given number in
mathematics could be a natural, integer, rational, irrational, or real,
that same number in Lean could be assigned to one of those specific
types. While we typically think of a given natural number as also being
an integer, rational, and real, Lean tends to be strict and say that
each natural number is only a natural number. While this level of
specificty is quite useful in maintaining logical consistency, it can
make some processes a bit more difficult. I ran into a few issues during
my time with the language when trying to make a recursively defined
function that took a natural number to represent which term was being
computed and returned a real number. Because Lean was so strict with its
typing, it did not allow me to define that recursive function the same
way it would easily be defined if I was trying to output another natural
number. While the theorems in Lean are functions, the actual
mathematical information is stored in types. Lean is then able to
logically verify each step of a proof because of this strict typing. It
will not allow for one type to be changed to another type without a
valid function being applied.

\hypertarget{theorems-as-functions}{%
\section{Theorems as Functions}\label{theorems-as-functions}}

Let's compare a simple Lean function to a simple theorem.

\hypertarget{simple-function}{%
\subsubsection{Simple Function}\label{simple-function}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ adding (n1 : Nat) (n2 : Nat) : Nat := }
\NormalTok{  n1 + n2}
\end{Highlighting}
\end{Shaded}

\hypertarget{simple-theorem}{%
\subsubsection{Simple Theorem}\label{simple-theorem}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (x : α) (A B : Set α) (h1 : A ⊆ B) }
\NormalTok{    (h2 : x ∈ A) : x ∈ B := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ h1}
  \KeywordTok{apply}\NormalTok{ h2}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

When using Lean, you set up a theorem to be proved using similar
notation to the notation used when defining a function. The hypotheses
you are assuming to be true are put in parentheses, just like arguments
to a function. In the simple function above I defined two arguments for
the function, the two natural numbers \texttt{n1} and \texttt{n2}. The
function then takes these naturals and adds them together to produce
another natural number. Within each set of parentheses is information
separated by a colon. The information on the left side defines
something, and the right side tells us what type that previously defined
thing has. Whereas in the simple function we are only defining things of
type natural, in the theorem we see that Lean will allow us to define
objects of an arbitrary type \texttt{α} so long as we continue to use
that arbitrary type throughout the rest of the theorem.

The function itself is even split into two parts, with everything left
of the colon being inputs, and everything to the right being the type of
the output of the function itself. When we set up a theorem or example
in Lean, Lean will not let us end the theorem until we have something of
the type set out when defining the theorem. This is where we are able to
use tactics and apply previous theorems to either convert the types of
hypotheses we are assuming, or convert the type of the goal we are
trying to prove. In my example theorem above, I applied our first
hypothesis which acted as a function and changed the current type in the
function. After applying the second hypothesis, I had essentially
applied functions to convert our assumptions from their initial types
into the goal we wanted to prove. Now that we have a proved theorem, we
can apply this in proving other theorems just like any other built-in
theorem. Since everything is a function, Lean is easily able to use
newly proved theorems to convert the types of hypotheses in a different
theorem. Having some basic understanding of how the language works, we
can begin to apply these concepts to more complex theorems and see the
potential benefits of using Lean.

\textbf{Note:} \texttt{h1} is not actually a proposition claiming that
\(A \subseteq B,\) but rather an object of \emph{type} \(A \subseteq B\)
that we call \texttt{h1}. It is also interesting to note that within
Lean even the various types have their own types. The type
\(A \subseteq B,\) for example, would have type proposition. Each of
what we traditionally think of as hypotheses would be types in Lean with
a type of proposition. Because Lean takes this approach with types, it
means that Lean is not concerned with truth or falsehood. Lean does not
necessarily prove that anything is true or false, but instead is focused
on converting objects of one type into another. Because of the way in
which Lean was set up, if some hypotheses can be converted from one
given type to another we then have a true theorem. Despite this, the
language itself is not actually claiming any given object or proposition
is true or false.

\bookmarksetup{startatroot}

\hypertarget{lean-as-a-theorem-prover}{%
\chapter{Lean as a Theorem Prover}\label{lean-as-a-theorem-prover}}

\hypertarget{differences-from-paragraph-style-proofs}{%
\section{Differences From Paragraph Style
Proofs}\label{differences-from-paragraph-style-proofs}}

Despite the incredible power that Lean could provide in the verification
of mathematical proofs, this does pose some difficulties, namely the
ease with which the aforementioned proofs can be written up. Typically,
proofs are simply written up in a paragraph style, where the steps being
taken and the theorems being applied are laid out in plain terms so that
it can be easily understood by fellow mathematicians. There are often
times when mathematicians writing a typical proof will take things for
granted or skip over steps that they think the reader will either
already know to be fact or can easily reason out for themselves. This
lax approach for conveying information simply does not work when trying
to communicate with technology, and a much more specific and methodical
approach must be adopted in order to take advantage of the logical
verification benefits. Thankfully, Lean has a community working to
create libraries of previously proven theorems that can be applied to
speed up the writing and verification of future proofs. This thankfully
means that all proofs do not need to be taken all the way back to basic
axioms: Users can save time by avoiding proving adjacent theorems and
instead focus only on the immediately relevant steps of their proof.

\hypertarget{term-mode-vs.-tactic-mode}{%
\subsection{Term Mode vs.~Tactic Mode}\label{term-mode-vs.-tactic-mode}}

Lean features two different ways to write out proofs: term mode and
tactic mode. Writing out a proof in term mode is typically done with
simpler proofs where you can simply chain together a couple theorems or
hypotheses to acquire the desired goal, whereas in tactic mode Lean will
break everything down into steps. All of the examples later in this
thesis will be completed in tactic mode because this is where lean is
really at its strongest. To go back to the earlier example of Lean being
a sort of kitchen, we could think of writing a proof in term mode like
making a salad. You have a few different ingredients that you lay on top
of each other to make something new, but there isn't anything changing
in the process of making the salad. There are also no tools being used
when making the salad. You lay all of the individual pieces in a bowl
and you may mix them around a bit, but there is nothing you cannot do by
hand. The lettuce contributes to making the salad, but it still remains
lettuce within the context of the final product. Lean being put into
tactic mode however is something more akin to making a lasagna.
Different tactics in Lean are like tools in a kitchen, where they can in
one step convert something that you currently have into something
different. When making our lasagna of a proof, we could employ tactic
stove to our assumed raw beef hypothesis to produce cooked ground beef.
We could also apply tactic oven to essentially cook the lasagna ahead of
time and reduce our final goal to getting all of the ingredients in a
pan. This ability to break each proof down step by step is much more
similar to a paragraph style proof than writing in term mode is, and the
tactics it gives us are where the power of lean really comes from.

Here is a simple example of the difference between a term style proof
and a tactic style proof. I won't go into too much detail since we will
see the benefits of tactic mode later, but it will be useful to see
other options that lean offers.

\hypertarget{term-mode-proof}{%
\subsubsection{Term Mode Proof}\label{term-mode-proof}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (x : α) (A B : Set α) (h1 : A ⊆ B) }
\NormalTok{    (h2 : x ∈ A) : x ∈ B := h1 h2}
\end{Highlighting}
\end{Shaded}

\hypertarget{tactic-mode-proof}{%
\subsubsection{Tactic Mode Proof}\label{tactic-mode-proof}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (x : α) (A B : Set α) (h1 : A ⊆ B) }
\NormalTok{    (h2 : x ∈ A) : x ∈ B := }\KeywordTok{by}
  \KeywordTok{apply}\NormalTok{ h1}
  \KeywordTok{apply}\NormalTok{ h2}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

Both examples are proving the same thing, but we can tell one is in
tactic mode because of the \texttt{by} right after the \texttt{:=} which
indicates the beginning of the justification for the proof.

\hypertarget{by_cases}{%
\subsection{\texorpdfstring{\texttt{by\_cases}}{by\_cases}}\label{by_cases}}

One specific example of a tactic we can use when doing a proof in tactic
mode is that of \texttt{by\_cases.} When completing a proof where some
object could have multiple possible states, if we show that each
individual state would lead to the desired conclusion, then we have
completed the proof. If, for example, some variable \(x\) that we are
working with is an integer, then we could say that there are two
possible cases: either \(x\) is even or \(x\) is odd. We could then
assume first that \(x\) is even and use that to complete our proof
followed by assuming that \(x\) is odd and finishing the proof. If we
say that \(x\) being even is a proposition \(P,\) and we call our end
goal \(R,\) then when using proof by cases it is true that if
\(P \Rightarrow R\) and \(\neg P \Rightarrow R,\) then \(R\) is true.

This is one example of a rule of inference used in mathematical proofs.
Different tactics in Lean correspond to different rules of inference and
will modify our current goal or one of our hypotheses. We could again
think of each of theses rules as tools in our mathematical kitchen which
allow us to work our current knowledge into a fully formed proof.

For each of the following proofs, I will first provide a typical
``paragraph style'' version of the proof, so the differences between the
two can easily be compared.

\hypertarget{inequality-addition}{%
\section{Inequality Addition}\label{inequality-addition}}

\hypertarget{paragraph-style-proof}{%
\subsection{Paragraph Style Proof}\label{paragraph-style-proof}}

\begin{thm}
If \(a < b\) and \(c \le d\), prove that \(a + c < b + d\)

\end{thm}

There are multiple ways to approach this in a paragraph style proof, so
I will attempt to have this proof follow along the same lines as the
Lean proof.

\begin{proof}

There are two possible cases: either \(c = d\) or \(c < d\). We will
first consider the case where \(c = d\). We know \(a < b\), so it would
also be true that \(a + c < b + c\). Then because \(c = d\),
\(a + c < b + d\). Now consider the case where \(c < d\). We know
\(a < b\), so \(a + c < b + c\) and \(b + c < b + d\) because \(c < d\).
Thus by transitivity of inequalities, we could say \(a + c < b + d\)
\excl{~□}\qedhere

\end{proof}

\hypertarget{lean-proof}{%
\subsection{Lean Proof}\label{lean-proof}}

\hypertarget{seting-up-the-problem}{%
\subsubsection{Seting up the problem}\label{seting-up-the-problem}}

Here I put the theorem we want to prove into Lean and we can see the
resulting infoview panel. I name our two assumptions \texttt{h1} and
\texttt{h2}, for hypotheses one and two. After a colon I then write out
the thing I am trying to prove with those hypotheses and use \texttt{by}
to put Lean into tactic mode.

It can now be seen that the infoview panel lists out both of our
hypotheses as well as the goal we are working towards at the bottom.
This panel will continue to change as more code is added to the Lean
file.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (a b c d : ℝ) (h1: a \textless{} b) }
\NormalTok{    (h2 : c ≤ d) : a + c \textless{} b + d := }\KeywordTok{by}
  
  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{R}\NormalTok{: Type u\_1}
\InformationTok{inst✝}\NormalTok{: Ring R}
\InformationTok{abcd}\NormalTok{: ℝ}
\InformationTok{h1}\NormalTok{: a \textless{} b}
\InformationTok{h2}\NormalTok{: c ≤ d}
\NormalTok{⊢ a + c \textless{} b + d}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-1}{%
\subsubsection{Step 1}\label{step-1}}

Here I lay out the two possible cases of our second hypothesis which
allows me to strengthen the information that we know. We see this
strengthened hypothesis reflected in \texttt{h3} in the infoview.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (a b c d : ℝ) (h1: a \textless{} b) }
\NormalTok{    (h2 : c ≤ d) : a + c \textless{} b + d := }\KeywordTok{by}
  \KeywordTok{by\_cases}\NormalTok{ h3 : c = d}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{R}\NormalTok{: Type u\_1}
\InformationTok{inst✝}\NormalTok{: Ring R}
\InformationTok{abcd}\NormalTok{: ℝ}
\InformationTok{h1}\NormalTok{: a \textless{} b}
\InformationTok{h2}\NormalTok{: c ≤ d}
\InformationTok{h3}\NormalTok{: c = d}
\NormalTok{⊢ a + c \textless{} b + d}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-2}{%
\subsubsection{Step 2}\label{step-2}}

Here I used hypothesis 3 to rewrite the \texttt{c} in our final goal as
a \texttt{d}. This change is reflected in the infoview for this step.
This is where we can see tactics changing our goal into something that
will be easier for us to reach.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (a b c d : ℝ) (h1: a \textless{} b) }
\NormalTok{    (h2 : c ≤ d) : a + c \textless{} b + d := }\KeywordTok{by}
  \KeywordTok{by\_cases}\NormalTok{ h3 : c = d}
  \KeywordTok{rw}\NormalTok{ [h3]}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{R}\NormalTok{: Type u\_1}
\InformationTok{inst✝}\NormalTok{: Ring R}
\InformationTok{abcd}\NormalTok{: ℝ}
\InformationTok{h1}\NormalTok{: a \textless{} b}
\InformationTok{h2}\NormalTok{: c ≤ d}
\InformationTok{h3}\NormalTok{: c = d}
\NormalTok{⊢ a + d \textless{} b + d}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-3}{%
\subsubsection{Step 3}\label{step-3}}

In this step I applied a theorem already in the Mathlib library for
Lean. The \texttt{add\_lt\_add\_right} theorem simply states that if you
have a \texttt{b\ \textless{}\ c}, then
\texttt{b\ +\ a\ \textless{}\ c\ +\ a} which is exactly what we need to
prove the goal for the first case. As the first case has been completed,
the infoview then switches to the second case which is reflected in the
new \texttt{h3} and reset goal.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (a b c d : ℝ) (h1: a \textless{} b) }
\NormalTok{    (h2 : c ≤ d) : a + c \textless{} b + d := }\KeywordTok{by}
  \KeywordTok{by\_cases}\NormalTok{ h3 : c = d}
  \KeywordTok{rw}\NormalTok{ [h3]}
  \KeywordTok{apply}\NormalTok{ add\_lt\_add\_right h1}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{R}\NormalTok{: Type u\_1}
\InformationTok{inst✝}\NormalTok{: Ring R}
\InformationTok{abcd}\NormalTok{: ℝ}
\InformationTok{h1}\NormalTok{: a \textless{} b}
\InformationTok{h2}\NormalTok{: c ≤ d}
\InformationTok{h3}\NormalTok{: ¬c = d}
\NormalTok{⊢ a + c \textless{} b + d}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-4}{%
\subsubsection{Step 4}\label{step-4}}

In order to better work with our new hypothesis, I use a tactic which
pushes the negation symbol further into the thing it is negating. This
results in a hypothesis which can actually be applied later on. This is
a perfect example of a tactic in lean modifying one of our hypotheses,
rather than just the end goal.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (a b c d : ℝ) (h1: a \textless{} b) }
\NormalTok{    (h2 : c ≤ d) : a + c \textless{} b + d := }\KeywordTok{by}
  \KeywordTok{by\_cases}\NormalTok{ h3 : c = d}
  \KeywordTok{rw}\NormalTok{ [h3]}
  \KeywordTok{apply}\NormalTok{ add\_lt\_add\_right h1}
  \KeywordTok{push\_neg} \KeywordTok{at}\NormalTok{ h3}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{R}\NormalTok{: Type u\_1}
\InformationTok{inst✝}\NormalTok{: Ring R}
\InformationTok{abcd}\NormalTok{: ℝ}
\InformationTok{h1}\NormalTok{: a \textless{} b}
\InformationTok{h2}\NormalTok{: c ≤ d}
\InformationTok{h3}\NormalTok{: c ≠ d}
\NormalTok{⊢ a + c \textless{} b + d}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-5}{%
\subsubsection{Step 5}\label{step-5}}

Here I am laying out a new hypothesis which will be useful later in the
proof. This hypothesis seems like an obvious conclusion based on
hypotheses two and three, but we must still lay it out simply for Lean
if we want to actually use it. The infoview panel always displays the
most current goal, which is why it is displaying the goal for
\texttt{h4} rather than the main goal.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (a b c d : ℝ) (h1: a \textless{} b) }
\NormalTok{    (h2 : c ≤ d) : a + c \textless{} b + d := }\KeywordTok{by}
  \KeywordTok{by\_cases}\NormalTok{ h3 : c = d}
  \KeywordTok{rw}\NormalTok{ [h3]}
  \KeywordTok{apply}\NormalTok{ add\_lt\_add\_right h1}
  \KeywordTok{push\_neg} \KeywordTok{at}\NormalTok{ h3}
  \KeywordTok{have}\NormalTok{ h4 : c \textless{} d := }\KeywordTok{by}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{R}\NormalTok{: Type u\_1}
\InformationTok{inst✝}\NormalTok{: Ring R}
\InformationTok{abcd}\NormalTok{: ℝ}
\InformationTok{h1}\NormalTok{: a \textless{} b}
\InformationTok{h2}\NormalTok{: c ≤ d}
\InformationTok{h3}\NormalTok{: c ≠ d}
\NormalTok{⊢ c \textless{} d}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-6}{%
\subsubsection{Step 6}\label{step-6}}

Here I apply another theorem already in Lean which takes the information
\texttt{h3} and \texttt{h2} gives us and shows our current goal. Writing
out \texttt{h4} like this is technically optional, as Lean allows you to
evaluate tactics within arguments for other tactics. Despite this, I
personally find it more clear and human-readable to write out extra
hypotheses like this rather than just giving the body of the argument
when necessary. Now that our new hypothesis has been proven, the
infoview displays that we have no goals until we get back into our main
theorem.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (a b c d : ℝ) (h1: a \textless{} b) }
\NormalTok{    (h2 : c ≤ d) : a + c \textless{} b + d := }\KeywordTok{by}
  \KeywordTok{by\_cases}\NormalTok{ h3 : c = d}
  \KeywordTok{rw}\NormalTok{ [h3]}
  \KeywordTok{apply}\NormalTok{ add\_lt\_add\_right h1}
  \KeywordTok{push\_neg} \KeywordTok{at}\NormalTok{ h3}
  \KeywordTok{have}\NormalTok{ h4 : c \textless{} d := }\KeywordTok{by}
    \KeywordTok{apply}\NormalTok{ Ne.lt\_of\_le h3 h2}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialStringTok{No}\InformationTok{ }\SpecialStringTok{goals}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-7}{%
\subsubsection{Step 7}\label{step-7}}

I now use the calc tactic to work through the rest of the theorem. This
tactic is quite useful as it allows us to chain together multiple
equalities or inequalities while still giving proofs for each step. This
is essentially a shortcut of writing out individual hypotheses and then
using the rewrite tactic to get our desired goal.

In this case, I only need to do two steps of chaining inequalities,
where I use transitivity to show that the starting value is less than
the final value. It essentially follows the same path as the paragraph
style proof, where the tactics \texttt{add\_lt\_add\_right} and
\texttt{add\_lt\_add\_left} justify the steps taken.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (a b c d : ℝ) (h1: a \textless{} b) }
\NormalTok{    (h2 : c ≤ d) : a + c \textless{} b + d := }\KeywordTok{by}
  \KeywordTok{by\_cases}\NormalTok{ h3 : c = d}
  \KeywordTok{rw}\NormalTok{ [h3]}
  \KeywordTok{apply}\NormalTok{ add\_lt\_add\_right h1}
  \KeywordTok{push\_neg} \KeywordTok{at}\NormalTok{ h3}
  \KeywordTok{have}\NormalTok{ h4 : c \textless{} d := }\KeywordTok{by}
    \KeywordTok{apply}\NormalTok{ Ne.lt\_of\_le h3 h2}
  \KeywordTok{exact} \KeywordTok{calc}
\NormalTok{    a + c \textless{} b + c := add\_lt\_add\_right h1 c}
\NormalTok{    \_ \textless{} b + d := add\_lt\_add\_left h4 b}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialStringTok{No}\InformationTok{ }\SpecialStringTok{goals}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{a-is-less-than-or-equal-to-b}{%
\section{a is Less Than or Equal to
b}\label{a-is-less-than-or-equal-to-b}}

\hypertarget{paragraph-style-proof-1}{%
\subsection{Paragraph Style Proof}\label{paragraph-style-proof-1}}

\begin{thm}
Suppose that \(a, b \in \mathbb{R}\) and for every \(\varepsilon > 0\),
we have \(a \le b + \varepsilon\). Show that \(a \le b\).

\end{thm}

\begin{proof}

Assume for the sake of contradiction that \(a\) is not less than or
equal to \(b\). Then it would be true that \(a > b\). Now consider the
case where \(\varepsilon = \frac{a - b}{2}.\) Then since \(a > b\),
epsilon is positive and by our assumption then
\(a \le b + \varepsilon\). Then \begin{align*}
a & \le b + \varepsilon \\
& = b + \frac{a - b}{2} \\
& = b + \frac{a}{2} - \frac{b}{2} \\
& = \frac{a}{2} + \frac{b}{2}. 
\end{align*} So now, \begin{align*}
a & \le \frac{a}{2} + \frac{b}{2} \\
a - \frac{a}{2} & \le \frac{b}{2} \\
\frac{a}{2} & \le \frac{b}{2} \\
a & \le b.
\end{align*} But now we have that \(a \le b\) and \(a > b\), a
contradiction! \excl{~□}\qedhere

\end{proof}

\hypertarget{lean-proof-1}{%
\subsection{Lean Proof}\label{lean-proof-1}}

\hypertarget{setting-up-the-problem}{%
\subsubsection{Setting up the problem}\label{setting-up-the-problem}}

I again set up the proof with our one hypothesis and the goal we want to
prove. These are then seen listed in the infoview on the right.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (a b : ℝ) (h1 : ∀ ε : ℝ, }
\NormalTok{    ε \textgreater{} 0 → a ≤ b + ε) : }
\NormalTok{    a ≤ b := }\KeywordTok{by}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{R}\NormalTok{: Type u\_1}
\InformationTok{inst✝}\NormalTok{: Ring R}
\InformationTok{ab}\NormalTok{: ℝ}
\InformationTok{h1}\NormalTok{: ∀ (ε : ℝ), ε \textgreater{} 0 → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  a ≤ b + ε}
\NormalTok{⊢ a ≤ b}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-1-1}{%
\subsubsection{Step 1}\label{step-1-1}}

The \texttt{by\_contra} tactic allows me to complete this problem using
proof by contradiction. This tactic automatically creates a hypothesis
containing the negation of the final goal named \texttt{h2}, and changes
the final goal to \texttt{False} meaning that it needs us to show a
contradiction.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (a b : ℝ) (h1 : ∀ ε : ℝ, }
\NormalTok{    ε \textgreater{} 0 → a ≤ b + ε) : }
\NormalTok{    a ≤ b := }\KeywordTok{by}
  \KeywordTok{by\_contra}\NormalTok{ h2}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{R}\NormalTok{: Type u\_1}
\InformationTok{inst✝}\NormalTok{: Ring R}
\InformationTok{ab}\NormalTok{: ℝ}
\InformationTok{h1}\NormalTok{: ∀ (ε : ℝ), ε \textgreater{} 0 → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  a ≤ b + ε}
\InformationTok{h2}\NormalTok{: ¬a ≤ b}
\NormalTok{⊢ False}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-2-1}{%
\subsubsection{Step 2}\label{step-2-1}}

Here I use the \texttt{push\_neg} tactic similarly to the previous
example to get a usable version of \texttt{h2} as well as pick a
specific epsilon for which we will find a contradiction. This new
epsilon will now show up in the infoview on the side and can be used in
our problem.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (a b : ℝ) (h1 : ∀ ε : ℝ, }
\NormalTok{    ε \textgreater{} 0 → a ≤ b + ε) : }
\NormalTok{    a ≤ b := }\KeywordTok{by}
  \KeywordTok{by\_contra}\NormalTok{ h2}
  \KeywordTok{push\_neg} \KeywordTok{at}\NormalTok{ h2}
  \KeywordTok{let}\NormalTok{ ε := (a {-} b) / 2}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{R}\NormalTok{: Type u\_1}
\InformationTok{inst✝}\NormalTok{: Ring R}
\InformationTok{ab}\NormalTok{: ℝ}
\InformationTok{h1}\NormalTok{: ∀ (ε : ℝ), ε \textgreater{} 0 → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  a ≤ b + ε}
\InformationTok{h2}\NormalTok{: b \textless{} a}
\InformationTok{ε}\NormalTok{: ℝ := (a {-} b) / 2}
\NormalTok{⊢ False}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-3-1}{%
\subsubsection{Step 3}\label{step-3-1}}

Here I lay out a hypothesis that we will later be able to apply to
\texttt{h1}. Claiming that epsilon was positive in the paragraph style
proof is fairly simple to back up, where we only really need to justify
that \(a - b\) is positive. In Lean however, it requires a bit more
effort and as such I put it in its own hypothesis.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (a b : ℝ) (h1 : ∀ ε : ℝ, }
\NormalTok{    ε \textgreater{} 0 → a ≤ b + ε) : }
\NormalTok{    a ≤ b := }\KeywordTok{by}
  \KeywordTok{by\_contra}\NormalTok{ h2}
  \KeywordTok{push\_neg} \KeywordTok{at}\NormalTok{ h2}
  \KeywordTok{let}\NormalTok{ ε := (a {-} b) / 2}
  \KeywordTok{have}\NormalTok{ h3 : ε \textgreater{} 0 := }\KeywordTok{by}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{R}\NormalTok{: Type u\_1}
\InformationTok{inst✝}\NormalTok{: Ring R}
\InformationTok{ab}\NormalTok{: ℝ}
\InformationTok{h1}\NormalTok{: ∀ (ε : ℝ), ε \textgreater{} 0 → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  a ≤ b + ε}
\InformationTok{h2}\NormalTok{: b \textless{} a}
\InformationTok{ε}\NormalTok{: ℝ := (a {-} b) / 2}
\NormalTok{⊢ ε \textgreater{} 0}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-4-1}{%
\subsubsection{Step 4}\label{step-4-1}}

Anyone reading a paragraph style proof such as ours would know that
dividing a number by two does not impact whether the resulting number
will be positive or negative, but this still needs to be justified in
Lean. As such, I use the \texttt{half\_pos} theorem with the
\texttt{refine} tactic to change the goal to what is currently shown in
the infoview. The \texttt{refine} tactic is useful because it tries to
apply the arguments it is given to the final goal and then changes the
goal to whatever is needed to meet the hypotheses in the arguments. In
this case, \texttt{half\_pos} claims that if you have some \(a > 0,\)
then \(\frac{a}{2} > 0.\) The \texttt{refine} tactic then applies the
result of that theorem and leaves us to show that \(a > 0,\) and Lean is
smart enough to figure out that we actually need to show \(a - b > 0.\)

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (a b : ℝ) (h1 : ∀ ε : ℝ, }
\NormalTok{    ε \textgreater{} 0 → a ≤ b + ε) : }
\NormalTok{    a ≤ b := }\KeywordTok{by}
  \KeywordTok{by\_contra}\NormalTok{ h2}
  \KeywordTok{push\_neg} \KeywordTok{at}\NormalTok{ h2}
  \KeywordTok{let}\NormalTok{ ε := (a {-} b) / 2}
  \KeywordTok{have}\NormalTok{ h3 : ε \textgreater{} 0 := }\KeywordTok{by}
\NormalTok{    refine half\_pos ?h}

      \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{R}\NormalTok{: Type u\_1}
\InformationTok{inst✝}\NormalTok{: Ring R}
\InformationTok{ab}\NormalTok{: ℝ}
\InformationTok{h1}\NormalTok{: ∀ (ε : ℝ), ε \textgreater{} 0 → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  a ≤ b + ε}
\InformationTok{h2}\NormalTok{: b \textless{} a}
\InformationTok{ε}\NormalTok{: ℝ := (a {-} b) / 2}
\NormalTok{⊢ 0 \textless{} a {-} b}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-5-1}{%
\subsubsection{Step 5}\label{step-5-1}}

The \texttt{sub\_pos} theorem says that \(0 < a - b\) if and only if
\(b < a,\) so we only need to apply this with our second hypothesis to
complete our current goal. This finishes off the proof of the third
hypothesis and allows us to return to the main theorem.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (a b : ℝ) (h1 : ∀ ε : ℝ, }
\NormalTok{    ε \textgreater{} 0 → a ≤ b + ε) : }
\NormalTok{    a ≤ b := }\KeywordTok{by}
  \KeywordTok{by\_contra}\NormalTok{ h2}
  \KeywordTok{push\_neg} \KeywordTok{at}\NormalTok{ h2}
  \KeywordTok{let}\NormalTok{ ε := (a {-} b) / 2}
  \KeywordTok{have}\NormalTok{ h3 : ε \textgreater{} 0 := }\KeywordTok{by}
\NormalTok{    refine half\_pos ?h}
    \KeywordTok{exact}\NormalTok{ Iff.mpr sub\_pos h2}
    \KeywordTok{done}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{R}\NormalTok{: Type u\_1}
\InformationTok{inst✝}\NormalTok{: Ring R}
\InformationTok{ab}\NormalTok{: ℝ}
\InformationTok{h1}\NormalTok{: ∀ (ε : ℝ), ε \textgreater{} 0 → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  a ≤ b + ε}
\InformationTok{h2}\NormalTok{: b \textless{} a}
\InformationTok{ε}\NormalTok{: ℝ := (a {-} b) / 2}
\InformationTok{h3}\NormalTok{: ε \textgreater{} 0}
\NormalTok{⊢ False}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-6-1}{%
\subsubsection{Step 6}\label{step-6-1}}

I now try to lay out the fourth and final hypothesis which will be used
to find a contradiction with \texttt{h2}. This is another example of
something being quickly explained in the paragraph style proof, but
being more cumbersome to justify within Lean.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (a b : ℝ) (h1 : ∀ ε : ℝ, }
\NormalTok{    ε \textgreater{} 0 → a ≤ b + ε) : }
\NormalTok{    a ≤ b := }\KeywordTok{by}
  \KeywordTok{by\_contra}\NormalTok{ h2}
  \KeywordTok{push\_neg} \KeywordTok{at}\NormalTok{ h2}
  \KeywordTok{let}\NormalTok{ ε := (a {-} b) / 2}
  \KeywordTok{have}\NormalTok{ h3 : ε \textgreater{} 0 := }\KeywordTok{by}
\NormalTok{    refine half\_pos ?h}
    \KeywordTok{exact}\NormalTok{ Iff.mpr sub\_pos h2}
    \KeywordTok{done}
  \KeywordTok{have}\NormalTok{ h4 : a ≤ b + ε := }\KeywordTok{by}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{R}\NormalTok{: Type u\_1}
\InformationTok{inst✝}\NormalTok{: Ring R}
\InformationTok{ab}\NormalTok{: ℝ}
\InformationTok{h1}\NormalTok{: ∀ (ε : ℝ), ε \textgreater{} 0 → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  a ≤ b + ε}
\InformationTok{h2}\NormalTok{: b \textless{} a}
\InformationTok{ε}\NormalTok{: ℝ := (a {-} b) / 2}
\InformationTok{h3}\NormalTok{: ε \textgreater{} 0}
\NormalTok{⊢ a ≤ b + ε}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-7-1}{%
\subsubsection{Step 7}\label{step-7-1}}

I first apply \texttt{h1} which has a similar effect to using the refine
tactic earler: it applies the result of an if-then statement and changes
our goal to proving the if.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (a b : ℝ) (h1 : ∀ ε : ℝ, }
\NormalTok{    ε \textgreater{} 0 → a ≤ b + ε) : }
\NormalTok{    a ≤ b := }\KeywordTok{by}
  \KeywordTok{by\_contra}\NormalTok{ h2}
  \KeywordTok{push\_neg} \KeywordTok{at}\NormalTok{ h2}
  \KeywordTok{let}\NormalTok{ ε := (a {-} b) / 2}
  \KeywordTok{have}\NormalTok{ h3 : ε \textgreater{} 0 := }\KeywordTok{by}
\NormalTok{    refine half\_pos ?h}
    \KeywordTok{exact}\NormalTok{ Iff.mpr sub\_pos h2}
    \KeywordTok{done}
  \KeywordTok{have}\NormalTok{ h4 : a ≤ b + ε := }\KeywordTok{by}
    \KeywordTok{apply}\NormalTok{ h1}

    \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{R}\NormalTok{: Type u\_1}
\InformationTok{inst✝}\NormalTok{: Ring R}
\InformationTok{ab}\NormalTok{: ℝ}
\InformationTok{h1}\NormalTok{: ∀ (ε : ℝ), ε \textgreater{} 0 → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  a ≤ b + ε}
\InformationTok{h2}\NormalTok{: b \textless{} a}
\InformationTok{ε}\NormalTok{: ℝ := (a {-} b) / 2}
\InformationTok{h3}\NormalTok{: ε \textgreater{} 0}
\NormalTok{⊢ ε \textgreater{} 0}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-8}{%
\subsubsection{Step 8}\label{step-8}}

Now that our goal has been properly modified, \texttt{h3} is the only
other thing necessary to justify this hypothesis.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (a b : ℝ) (h1 : ∀ ε : ℝ, }
\NormalTok{    ε \textgreater{} 0 → a ≤ b + ε) : }
\NormalTok{    a ≤ b := }\KeywordTok{by}
  \KeywordTok{by\_contra}\NormalTok{ h2}
  \KeywordTok{push\_neg} \KeywordTok{at}\NormalTok{ h2}
  \KeywordTok{let}\NormalTok{ ε := (a {-} b) / 2}
  \KeywordTok{have}\NormalTok{ h3 : ε \textgreater{} 0 := }\KeywordTok{by}
\NormalTok{    refine half\_pos ?h}
    \KeywordTok{exact}\NormalTok{ Iff.mpr sub\_pos h2}
    \KeywordTok{done}
  \KeywordTok{have}\NormalTok{ h4 : a ≤ b + ε := }\KeywordTok{by}
    \KeywordTok{apply}\NormalTok{ h1}
    \KeywordTok{apply}\NormalTok{ h3}
    \KeywordTok{done}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{R}\NormalTok{: Type u\_1}
\InformationTok{inst✝}\NormalTok{: Ring R}
\InformationTok{ab}\NormalTok{: ℝ}
\InformationTok{h1}\NormalTok{: ∀ (ε : ℝ), ε \textgreater{} 0 → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  a ≤ b + ε}
\InformationTok{h2}\NormalTok{: b \textless{} a}
\InformationTok{ε}\NormalTok{: ℝ := (a {-} b) / 2}
\InformationTok{h3}\NormalTok{: ε \textgreater{} 0}
\InformationTok{h4}\NormalTok{: a ≤ b + ε}
\NormalTok{⊢ False}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-9}{%
\subsubsection{Step 9}\label{step-9}}

The \texttt{dsimp} tactic will do its best to automatically simplify
anything it is given, in this case it substitutes our specific epsilon
value in for the arbitrary epsilon. This will now allow us to use
\texttt{h4} to find our contradiction.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (a b : ℝ) (h1 : ∀ ε : ℝ, }
\NormalTok{    ε \textgreater{} 0 → a ≤ b + ε) : }
\NormalTok{    a ≤ b := }\KeywordTok{by}
  \KeywordTok{by\_contra}\NormalTok{ h2}
  \KeywordTok{push\_neg} \KeywordTok{at}\NormalTok{ h2}
  \KeywordTok{let}\NormalTok{ ε := (a {-} b) / 2}
  \KeywordTok{have}\NormalTok{ h3 : ε \textgreater{} 0 := }\KeywordTok{by}
\NormalTok{    refine half\_pos ?h}
    \KeywordTok{exact}\NormalTok{ Iff.mpr sub\_pos h2}
    \KeywordTok{done}
  \KeywordTok{have}\NormalTok{ h4 : a ≤ b + ε := }\KeywordTok{by}
    \KeywordTok{apply}\NormalTok{ h1}
    \KeywordTok{apply}\NormalTok{ h3}
    \KeywordTok{done}
\NormalTok{  dsimp }\KeywordTok{at}\NormalTok{ h4}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{R}\NormalTok{: Type u\_1}
\InformationTok{inst✝}\NormalTok{: Ring R}
\InformationTok{ab}\NormalTok{: ℝ}
\InformationTok{h1}\NormalTok{: ∀ (ε : ℝ), ε \textgreater{} 0 → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  a ≤ b + ε}
\InformationTok{h2}\NormalTok{: b \textless{} a}
\InformationTok{ε}\NormalTok{: ℝ := (a {-} b) / 2}
\InformationTok{h3}\NormalTok{: ε \textgreater{} 0}
\InformationTok{h4}\NormalTok{: a ≤ b + (a {-} b) / 2}
\NormalTok{⊢ False}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-10}{%
\subsubsection{Step 10}\label{step-10}}

The \texttt{linarith} tactic is quite powerful as it will attempt to
simplify the goal as well as hypotheses and then look for a
contradiction amongst the known hypotheses. This is one example where
Lean actually requires quite a bit less explanation than a typical
proof. The majority of my paragraph style proof above was spent
simplifying and manipulating \texttt{h4} and \texttt{h2}, whereas in
Lean I need to specify none of that! It is quite impressive that Lean is
already able to do so much simplification and even find contradictions
with no user input. This ability will likely only increase in power in
the future, and some developments have even occured during the planning
and writing of this thesis that make other simplification tactics
substantially more powerful.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (a b : ℝ) (h1 : ∀ ε : ℝ, }
\NormalTok{    ε \textgreater{} 0 → a ≤ b + ε) : }
\NormalTok{    a ≤ b := }\KeywordTok{by}
  \KeywordTok{by\_contra}\NormalTok{ h2}
  \KeywordTok{push\_neg} \KeywordTok{at}\NormalTok{ h2}
  \KeywordTok{let}\NormalTok{ ε := (a {-} b) / 2}
  \KeywordTok{have}\NormalTok{ h3 : ε \textgreater{} 0 := }\KeywordTok{by}
\NormalTok{    refine half\_pos ?h}
    \KeywordTok{exact}\NormalTok{ Iff.mpr sub\_pos h2}
    \KeywordTok{done}
  \KeywordTok{have}\NormalTok{ h4 : a ≤ b + ε := }\KeywordTok{by}
    \KeywordTok{apply}\NormalTok{ h1}
    \KeywordTok{apply}\NormalTok{ h3}
    \KeywordTok{done}
\NormalTok{  dsimp }\KeywordTok{at}\NormalTok{ h4}
  \KeywordTok{linarith}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialStringTok{No}\InformationTok{ }\SpecialStringTok{goals}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{absolute-convergence}{%
\section{Absolute Convergence}\label{absolute-convergence}}

\hypertarget{paragraph-style-proof-2}{%
\subsection{Paragraph Style Proof}\label{paragraph-style-proof-2}}

\begin{thm}
Prove that \(\lim(x_{n}) = 0\) if and only if
\(\lim(\left|x_{n}\right|) = 0.\)

\end{thm}

\begin{proof}

\((\Longrightarrow)\) First assume that \(\lim(x_{n}) = 0.\) Then for
all \(\varepsilon > 0\) we know there exists a \(k_{n} \in \mathbb{N}\)
such that for all nautral numbers \(n > k_{n},\)
\(\left|x_{n} - 0\right| < \varepsilon.\) Thus
\(\left|x_{n}\right| < \varepsilon\) and also
\(\left|\left|x_{n}\right| - 0 \right| < \varepsilon,\) so
\(\lim(\left|x_{n}\right|) = 0.\)

\((\Longleftarrow)\) Now assume that \(\lim(\left|x_{n}\right|) = 0.\)
Then for all \(\varepsilon > 0\) we know there exists a
\(k_{n} \in \mathbb{N}\) such that for all nautral numbers
\(n > k_{n},\) \(\left|\left|x_{n}\right| - 0\right| < \varepsilon.\)
But
\(\left|\left|x_{n}\right| - 0\right| = \left|\left|x_{n}\right|\right| = \left|x_{n}\right| = \left|x_{n} - 0\right|.\)
So \(\left|x_{n} - 0\right| < \varepsilon\) and \(\lim(x_{n}) = 0.\)
\excl{~□}\qedhere

\end{proof}

\hypertarget{lean-proof-2}{%
\subsection{Lean Proof}\label{lean-proof-2}}

\hypertarget{setting-up-the-problem-1}{%
\subsubsection{Setting up the problem}\label{setting-up-the-problem-1}}

Lean does not include a built in epsilon definition of a limit for
sequences, so it is first necessary to define a limit in Lean. I use the
following definition:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ ConvergesTo (s : ℕ → ℝ) (a : ℝ) :=}
\NormalTok{  ∀ ε \textgreater{} 0, ∃ N, ∀ n ≥ N, |s n {-} a| \textless{} ε}
\end{Highlighting}
\end{Shaded}

From this point we can set up our problem as normal.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (s1 : ℕ → ℝ) : }
\NormalTok{    ConvergesTo s1 (0 : ℝ) ↔}
\NormalTok{    ConvergesTo (abs s1) (0 : ℝ) }
\NormalTok{    := }\KeywordTok{by}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{s1}\NormalTok{: ℕ → ℝ}
\NormalTok{⊢ ConvergesTo s1 0 }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  ↔ ConvergesTo |s1| 0}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-1-2}{%
\subsubsection{Step 1}\label{step-1-2}}

The first thing I ask Lean to do is rewrite the definition of
convergence that I defined earler when it is used in our goal. This will
allow us to actually use and work towards the information in both
instances of \texttt{ConvergesTo} in the problem. The fully expanded
definition is shown in the infoview panel.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (s1 : ℕ → ℝ) : }
\NormalTok{    ConvergesTo s1 (0 : ℝ) ↔}
\NormalTok{    ConvergesTo (abs s1) (0 : ℝ) }
\NormalTok{    := }\KeywordTok{by}
  \KeywordTok{rw}\NormalTok{ [ConvergesTo]}
  \KeywordTok{rw}\NormalTok{ [ConvergesTo]}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{s1}\NormalTok{: ℕ → ℝ}
\NormalTok{⊢ (∀ (ε : ℝ), ε \textgreater{} 0 → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    ∃ N, ∀ (n : ℕ), }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    n ≥ N → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    |s1 n {-} 0| \textless{} ε) ↔}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    ∀ (ε : ℝ), ε \textgreater{} 0 → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    ∃ N, ∀ (n : ℕ), }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    n ≥ N → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    |abs s1 n {-} 0| \textless{} ε}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-2-2}{%
\subsubsection{Step 2}\label{step-2-2}}

Here I set up a hypothesis which will later be used to rewrite both
sides of the if and only if statement into something that is equal to
the other.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (s1 : ℕ → ℝ) : }
\NormalTok{    ConvergesTo s1 (0 : ℝ) ↔}
\NormalTok{    ConvergesTo (abs s1) (0 : ℝ) }
\NormalTok{    := }\KeywordTok{by}
  \KeywordTok{rw}\NormalTok{ [ConvergesTo]}
  \KeywordTok{rw}\NormalTok{ [ConvergesTo]}
  \KeywordTok{have}\NormalTok{ h3 (x : ℕ) : |s1 x| = }
\NormalTok{      |abs s1 x| := }\KeywordTok{by}
    
    \KeywordTok{done}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{s1}\NormalTok{: ℕ → ℝ}
\InformationTok{x}\NormalTok{: ℕ}
\NormalTok{⊢ |s1 x| = |abs s1 x|}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-3-2}{%
\subsubsection{Step 3}\label{step-3-2}}

In this instance Lean essentially already knows that our goal is true,
and only need to be told to simplify using the definition of absolute
value in order to verify this. While it is impressive that Lean requires
little guidance, seeing some of the other things Lean is capable of
leaves me a bit underwhelmed that Lean requires any input here. Because
Lean is constantly being developed there may come a time where simple
statements like this are automatically verified without any user input.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (s1 : ℕ → ℝ) : }
\NormalTok{    ConvergesTo s1 (0 : ℝ) ↔}
\NormalTok{    ConvergesTo (abs s1) (0 : ℝ) }
\NormalTok{    := }\KeywordTok{by}
  \KeywordTok{rw}\NormalTok{ [ConvergesTo]}
  \KeywordTok{rw}\NormalTok{ [ConvergesTo]}
  \KeywordTok{have}\NormalTok{ h3 (x : ℕ) : |s1 x| = }
\NormalTok{      |abs s1 x| := }\KeywordTok{by}
    \KeywordTok{simp}\NormalTok{ [abs]}
    \KeywordTok{done}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{s1}\NormalTok{: ℕ → ℝ}
\InformationTok{h3}\NormalTok{: ∀ (x : ℕ), |s1 x| = }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  |abs s1 x|}
\NormalTok{⊢ (∀ (ε : ℝ), ε \textgreater{} 0 → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    ∃ N, ∀ (n : ℕ), }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    n ≥ N → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    |s1 n {-} 0| \textless{} ε) ↔}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    ∀ (ε : ℝ), ε \textgreater{} 0 → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    ∃ N, ∀ (n : ℕ), }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    n ≥ N → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    |abs s1 n {-} 0| \textless{} ε}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-4-2}{%
\subsubsection{Step 4}\label{step-4-2}}

Here the \texttt{Iff.intro} tactic splits up the if and only if
statement in the goal and allows us to prove each direction
individually, as is often done in a paragraph style proof.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (s1 : ℕ → ℝ) : }
\NormalTok{    ConvergesTo s1 (0 : ℝ) ↔}
\NormalTok{    ConvergesTo (abs s1) (0 : ℝ) }
\NormalTok{    := }\KeywordTok{by}
  \KeywordTok{rw}\NormalTok{ [ConvergesTo]}
  \KeywordTok{rw}\NormalTok{ [ConvergesTo]}
  \KeywordTok{have}\NormalTok{ h3 (x : ℕ) : |s1 x| = }
\NormalTok{      |abs s1 x| := }\KeywordTok{by}
    \KeywordTok{simp}\NormalTok{ [abs]}
    \KeywordTok{done}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-}Forwards}

\NormalTok{  · }\CommentTok{{-}{-}Reverse}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{s1}\NormalTok{: ℕ → ℝ}
\InformationTok{h3}\NormalTok{: ∀ (x : ℕ), |s1 x| = }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  |abs s1 x|}
\NormalTok{⊢ (∀ (ε : ℝ), ε \textgreater{} 0 → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    ∃ N, ∀ (n : ℕ), }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    n ≥ N → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    |s1 n {-} 0| \textless{} ε) →}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    ∀ (ε : ℝ), ε \textgreater{} 0 → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    ∃ N, ∀ (n : ℕ), }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    n ≥ N → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    |abs s1 n {-} 0| \textless{} ε}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-5-2}{%
\subsubsection{Step 5}\label{step-5-2}}

The \texttt{intro} tactic applied here allows me to assume the if part
of an if-then statement and automatically names it with the hypothesis
name I give it.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (s1 : ℕ → ℝ) : }
\NormalTok{    ConvergesTo s1 (0 : ℝ) ↔}
\NormalTok{    ConvergesTo (abs s1) (0 : ℝ) }
\NormalTok{    := }\KeywordTok{by}
  \KeywordTok{rw}\NormalTok{ [ConvergesTo]}
  \KeywordTok{rw}\NormalTok{ [ConvergesTo]}
  \KeywordTok{have}\NormalTok{ h3 (x : ℕ) : |s1 x| = }
\NormalTok{      |abs s1 x| := }\KeywordTok{by}
    \KeywordTok{simp}\NormalTok{ [abs]}
    \KeywordTok{done}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-}Forwards}
\NormalTok{    intro h1}

\NormalTok{  · }\CommentTok{{-}{-}Reverse}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{s1}\NormalTok{: ℕ → ℝ}
\InformationTok{h3}\NormalTok{: ∀ (x : ℕ), |s1 x| = }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  |abs s1 x|}
\InformationTok{h1}\NormalTok{: ∀ (ε : ℝ), ε \textgreater{} 0 → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  ∃ N, ∀ (n : ℕ), }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  n ≥ N → |s1 n {-} 0| \textless{} ε}
\NormalTok{⊢ ∀ (ε : ℝ), ε \textgreater{} 0 → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    ∃ N, ∀ (n : ℕ), }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    n ≥ N → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    |abs s1 n {-} 0| \textless{} ε}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-6-2}{%
\subsubsection{Step 6}\label{step-6-2}}

With the \texttt{simp} tactic, Lean attempts to simplify the current
goal. In this case, the \(\left|\left|s1_{n}\right| - 0\right|\) is
simplified to \(\left|\left|s1_{n}\right|\right|.\) This is now where
our \texttt{h3} hypothesis can be applied, but I will first attempt to
simplify \texttt{h1}.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (s1 : ℕ → ℝ) : }
\NormalTok{    ConvergesTo s1 (0 : ℝ) ↔}
\NormalTok{    ConvergesTo (abs s1) (0 : ℝ) }
\NormalTok{    := }\KeywordTok{by}
  \KeywordTok{rw}\NormalTok{ [ConvergesTo]}
  \KeywordTok{rw}\NormalTok{ [ConvergesTo]}
  \KeywordTok{have}\NormalTok{ h3 (x : ℕ) : |s1 x| = }
\NormalTok{      |abs s1 x| := }\KeywordTok{by}
    \KeywordTok{simp}\NormalTok{ [abs]}
    \KeywordTok{done}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-}Forwards}
\NormalTok{    intro h1}
    \KeywordTok{simp}

\NormalTok{  · }\CommentTok{{-}{-}Reverse}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{s1}\NormalTok{: ℕ → ℝ}
\InformationTok{h3}\NormalTok{: ∀ (x : ℕ), |s1 x| = }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  |abs s1 x|}
\InformationTok{h1}\NormalTok{: ∀ (ε : ℝ), ε \textgreater{} 0 → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  ∃ N, ∀ (n : ℕ), }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  n ≥ N → |s1 n {-} 0| \textless{} ε}
\NormalTok{⊢ ∀ (ε : ℝ), 0 \textless{} ε → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    ∃ N, ∀ (n : ℕ), }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    N ≤ n → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    |abs s1 n| \textless{} ε}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-7-2}{%
\subsubsection{Step 7}\label{step-7-2}}

The \texttt{simp} tactic has the same effect as in the previous step,
but this time it is working on \texttt{h1} rather than the end goal. By
default \texttt{simp} will attempt to work on the goal but if asked to
it will attempt to simplify hypotheses as well.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (s1 : ℕ → ℝ) : }
\NormalTok{    ConvergesTo s1 (0 : ℝ) ↔}
\NormalTok{    ConvergesTo (abs s1) (0 : ℝ) }
\NormalTok{    := }\KeywordTok{by}
  \KeywordTok{rw}\NormalTok{ [ConvergesTo]}
  \KeywordTok{rw}\NormalTok{ [ConvergesTo]}
  \KeywordTok{have}\NormalTok{ h3 (x : ℕ) : |s1 x| = }
\NormalTok{      |abs s1 x| := }\KeywordTok{by}
    \KeywordTok{simp}\NormalTok{ [abs]}
    \KeywordTok{done}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-}Forwards}
\NormalTok{    intro h1}
    \KeywordTok{simp}
    \KeywordTok{simp} \KeywordTok{at}\NormalTok{ h1}

\NormalTok{  · }\CommentTok{{-}{-}Reverse}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{s1}\NormalTok{: ℕ → ℝ}
\InformationTok{h3}\NormalTok{: ∀ (x : ℕ), |s1 x| = }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  |abs s1 x|}
\InformationTok{h1}\NormalTok{: ∀ (ε : ℝ), 0 \textless{} ε → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  ∃ N, ∀ (n : ℕ), }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  N ≤ n → |s1 n| \textless{} ε}
\NormalTok{⊢ ∀ (ε : ℝ), 0 \textless{} ε → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    ∃ N, ∀ (n : ℕ), }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    N ≤ n → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    |abs s1 n| \textless{} ε}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-8-1}{%
\subsubsection{Step 8}\label{step-8-1}}

We can now use the reverse direction of \texttt{h3} to simplify our goal
further. Notice that the leftwards facing arrow is necessary, as Lean
typically tries to apply equalities from left to right. This means if
the left side of the equality does not match what Lean is attempting to
replace, Lean will not be able to rewrite in other terms.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (s1 : ℕ → ℝ) : }
\NormalTok{    ConvergesTo s1 (0 : ℝ) ↔}
\NormalTok{    ConvergesTo (abs s1) (0 : ℝ) }
\NormalTok{    := }\KeywordTok{by}
  \KeywordTok{rw}\NormalTok{ [ConvergesTo]}
  \KeywordTok{rw}\NormalTok{ [ConvergesTo]}
  \KeywordTok{have}\NormalTok{ h3 (x : ℕ) : |s1 x| = }
\NormalTok{      |abs s1 x| := }\KeywordTok{by}
    \KeywordTok{simp}\NormalTok{ [abs]}
    \KeywordTok{done}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-}Forwards}
\NormalTok{    intro h1}
    \KeywordTok{simp}
    \KeywordTok{simp} \KeywordTok{at}\NormalTok{ h1}
    \KeywordTok{simp}\NormalTok{ [← h3]}

\NormalTok{  · }\CommentTok{{-}{-}Reverse}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{s1}\NormalTok{: ℕ → ℝ}
\InformationTok{h3}\NormalTok{: ∀ (x : ℕ), |s1 x| = }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  |abs s1 x|}
\InformationTok{h1}\NormalTok{: ∀ (ε : ℝ), 0 \textless{} ε → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  ∃ N, ∀ (n : ℕ), }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  N ≤ n → |s1 n| \textless{} ε}
\NormalTok{⊢ ∀ (ε : ℝ), 0 \textless{} ε → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    ∃ N, ∀ (n : ℕ), }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    N ≤ n → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    |s1 n| \textless{} ε}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-9-1}{%
\subsubsection{Step 9}\label{step-9-1}}

The simplification done over the last few steps has modified both
\texttt{h1} and our goal to be the same thing. Since we are assuming
\texttt{h1} to be true, this allows us to apply that hypothesis and
complete the first direction of our goal. Upon completion of the first
goal, Lean automatically begins displaying the second goal, which can be
solved quite similarly to the first. This is one place where some
mathematicians may leave the other direction out of their paragraph
style proof because it is essentially proved the same way as the
previous direction. While this is easy and convenient, it never hurts to
give a full explanation like what Lean will require of us.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (s1 : ℕ → ℝ) : }
\NormalTok{    ConvergesTo s1 (0 : ℝ) ↔}
\NormalTok{    ConvergesTo (abs s1) (0 : ℝ) }
\NormalTok{    := }\KeywordTok{by}
  \KeywordTok{rw}\NormalTok{ [ConvergesTo]}
  \KeywordTok{rw}\NormalTok{ [ConvergesTo]}
  \KeywordTok{have}\NormalTok{ h3 (x : ℕ) : |s1 x| = }
\NormalTok{      |abs s1 x| := }\KeywordTok{by}
    \KeywordTok{simp}\NormalTok{ [abs]}
    \KeywordTok{done}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-}Forwards}
\NormalTok{    intro h1}
    \KeywordTok{simp}
    \KeywordTok{simp} \KeywordTok{at}\NormalTok{ h1}
    \KeywordTok{simp}\NormalTok{ [← h3]}
    \KeywordTok{apply}\NormalTok{ h1}
\NormalTok{  · }\CommentTok{{-}{-}Reverse}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{s1}\NormalTok{: ℕ → ℝ}
\InformationTok{h3}\NormalTok{: ∀ (x : ℕ), |s1 x| = }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  |abs s1 x|}
\NormalTok{⊢ (∀ (ε : ℝ), ε \textgreater{} 0 → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    ∃ N, ∀ (n : ℕ), }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    n ≥ N → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    |abs s1 n {-} 0| \textless{} ε) →}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    ∀ (ε : ℝ), ε \textgreater{} 0 → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    ∃ N, ∀ (n : ℕ), }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    n ≥ N → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    |s1 n {-} 0| \textless{} ε}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-10-1}{%
\subsubsection{Step 10}\label{step-10-1}}

With this direction I try to simplify in the same ways as before, but
instead of using the leftwards direction of the equality in \texttt{h3},
I use the rightwards direction. This means that arrow does not need to
be included and once again he have \texttt{h1} equal to our current
goal.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (s1 : ℕ → ℝ) : }
\NormalTok{    ConvergesTo s1 (0 : ℝ) ↔}
\NormalTok{    ConvergesTo (abs s1) (0 : ℝ) }
\NormalTok{    := }\KeywordTok{by}
  \KeywordTok{rw}\NormalTok{ [ConvergesTo]}
  \KeywordTok{rw}\NormalTok{ [ConvergesTo]}
  \KeywordTok{have}\NormalTok{ h3 (x : ℕ) : |s1 x| = }
\NormalTok{      |abs s1 x| := }\KeywordTok{by}
    \KeywordTok{simp}\NormalTok{ [abs]}
    \KeywordTok{done}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-}Forwards}
\NormalTok{    intro h1}
    \KeywordTok{simp}
    \KeywordTok{simp} \KeywordTok{at}\NormalTok{ h1}
    \KeywordTok{simp}\NormalTok{ [← h3]}
    \KeywordTok{apply}\NormalTok{ h1}
\NormalTok{  · }\CommentTok{{-}{-}Reverse}
\NormalTok{    intro h1}
    \KeywordTok{simp}
    \KeywordTok{simp} \KeywordTok{at}\NormalTok{ h1}
\NormalTok{    simp\_rw [h3]}

  \SpecialCharTok{**}\WarningTok{done}\SpecialCharTok{::}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\InformationTok{s1}\NormalTok{: ℕ → ℝ}
\InformationTok{h3}\NormalTok{: ∀ (x : ℕ), |s1 x| = }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  |abs s1 x|}
\InformationTok{h1}\NormalTok{: ∀ (ε : ℝ), 0 \textless{} ε → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  ∃ N, ∀ (n : ℕ), }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{  N ≤ n → |abs s1 n| \textless{} ε}
\NormalTok{⊢ ∀ (ε : ℝ), 0 \textless{} ε → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    ∃ N, ∀ (n : ℕ),}
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    N ≤ n → }
\SpecialCharTok{\textgreater{}\textgreater{}}\NormalTok{    |abs s1 n| \textless{} ε}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{step-11}{%
\subsubsection{Step 11}\label{step-11}}

With a hypothesis equal to our goal, we are able to apply the hypothesis
and prove the other direction of the if and only if statement,
completing the proof.

\begin{inpt}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (s1 : ℕ → ℝ) : }
\NormalTok{    ConvergesTo s1 (0 : ℝ) ↔}
\NormalTok{    ConvergesTo (abs s1) (0 : ℝ) }
\NormalTok{    := }\KeywordTok{by}
  \KeywordTok{rw}\NormalTok{ [ConvergesTo]}
  \KeywordTok{rw}\NormalTok{ [ConvergesTo]}
  \KeywordTok{have}\NormalTok{ h3 (x : ℕ) : |s1 x| = }
\NormalTok{      |abs s1 x| := }\KeywordTok{by}
    \KeywordTok{simp}\NormalTok{ [abs]}
    \KeywordTok{done}
  \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{  · }\CommentTok{{-}{-}Forwards}
\NormalTok{    intro h1}
    \KeywordTok{simp}
    \KeywordTok{simp} \KeywordTok{at}\NormalTok{ h1}
    \KeywordTok{simp}\NormalTok{ [← h3]}
    \KeywordTok{apply}\NormalTok{ h1}
\NormalTok{  · }\CommentTok{{-}{-}Reverse}
\NormalTok{    intro h1}
    \KeywordTok{simp}
    \KeywordTok{simp} \KeywordTok{at}\NormalTok{ h1}
\NormalTok{    simp\_rw [h3]}
    \KeywordTok{apply}\NormalTok{ h1}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\end{inpt}

\begin{outpt}

\begin{Shaded}
\begin{Highlighting}[]
\SpecialStringTok{No}\InformationTok{ }\SpecialStringTok{goals}
\end{Highlighting}
\end{Shaded}

\end{outpt}

\hypertarget{convergence-of-a-specific-sequence}{%
\section{Convergence of a Specific
Sequence}\label{convergence-of-a-specific-sequence}}

The following is an example of one situation where Lean is somewhat
lacking in comparison to a paragraph style proof. The paragraph style
proof is able to quickly and easily prove the desired end goal, but Lean
has to work around a lot of the simple rewriting we would do in a normal
proof. In this attempt to prove the convergence of a specific sequence,
there were many issues with simplification involving arbitrary variables
and the change from natural numbers to real numbers. These sorts of
things can be easily explained in a paragraph style proof, but required
significant work to prove in Lean.

I mentioned earlier that Lean's ability to simplify and make connections
without user input was advancing quickly, and I encountered this when
working on this problem. I originally had great difficulty getting Lean
to accept that \(2 = \frac{2(n + 1)}{n + 1},\) which is something which
can easily be explained in a typical proof, but Lean had difficulty
accepting. Thankfully, Lean has recently strengthened a tactic that
renders much of my work here unnecessary. The \texttt{field\_simp}
tactic tries to simplify the current goal using what is known about all
fields, and since we are working with the real numbers we are able to
take advantage of this. I was not able to use this tactic since it was
changed while I was working on the project, but seeing how quickly Lean
is progressing is very promising.

Lean internally defines limits using filters and topology rather than
the real analysis approach of epsilons, so the approach I was taking
here is not the optimal approach for theorems involving limits in Lean.
While this topological filter definition of a limit is very useful for
the people who know how to use it, it makes Lean more difficult to use
for those who have not yet studied topology. Definitions such as this
start to portray that Lean is not really something meant to be used for
lower level mathematics, but rather complex and high level proofs.

\hypertarget{paragraph-style-proof-3}{%
\subsection{Paragraph Style Proof}\label{paragraph-style-proof-3}}

\begin{thm}
Prove that \(\lim(\frac{2n}{n + 1}) = 2.\)

\end{thm}

\begin{proof}

Let \(\varepsilon > 0\) and choose \(k > \frac{1}{\varepsilon} - 1\)
where \(k \in \mathbb{N}\) by the Archimedean Property. Then for
\(n > k:\) \begin{align*}
\left|\frac{2n}{n + 1} - 2\right| & = \left|\frac{2n}{n + 1} - \frac{2(n + 1)}{n + 1}\right|\\
& = \left|\frac{-1}{n + 1}\right|\\
& = \frac{1}{n + 1}\\
& < \frac{1}{k + 1}\\
& < \frac{1}{\frac{1}{\varepsilon} - 1 + 1} = \varepsilon.
\end{align*} Thus we have that \(\lim(\frac{2n}{n + 1}) = 2.\)
\excl{~□}\qedhere

\end{proof}

\hypertarget{lean-proof-3}{%
\subsection{Lean Proof}\label{lean-proof-3}}

I will not attempt to walk through every step of this proof, but it
suffices to show that Lean somewhat struggles when being used for
lower-level proofs that it is not optimized for.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ : ConvergesTo (fun (n : ℕ) ↦ }
\NormalTok{    ((2 * n) / (n + 1))) 2 := }\KeywordTok{by}
\NormalTok{  intro ε}
\NormalTok{  intro h1}
  \KeywordTok{obtain}\NormalTok{ ⟨k, h13⟩ := }
\NormalTok{    exists\_nat\_gt (2 / ε {-} 1) }\CommentTok{{-}{-}Archimedean Property}
\NormalTok{  use k}
\NormalTok{  intro n}
\NormalTok{  intro h2}
\NormalTok{  dsimp}
  \KeywordTok{have}\NormalTok{ h3 : (2 : ℝ) = 2 * ((n + 1) / (n + 1)) := }\KeywordTok{by}
    \KeywordTok{have}\NormalTok{ h4 : ((n + 1) / (n + 1)) = }
\NormalTok{        (n + 1) * ((n + 1) : ℝ)⁻¹ := }\KeywordTok{by}
      \KeywordTok{rfl}
      \KeywordTok{done}
    \KeywordTok{rw}\NormalTok{ [h4]}
    \KeywordTok{have}\NormalTok{ h5 : (n + 1) * ((n + 1) : ℝ)⁻¹ = 1 := }\KeywordTok{by}
      \KeywordTok{rw}\NormalTok{ [mul\_inv\_cancel]}
      \KeywordTok{exact}\NormalTok{ Nat.cast\_add\_one\_ne\_zero n}
      \KeywordTok{done}
    \KeywordTok{rw}\NormalTok{ [h5]}
    \KeywordTok{exact}\NormalTok{ Eq.symm (mul\_one 2)}
    \KeywordTok{done}
\NormalTok{  nth\_rewrite 2 [h3]}
  \KeywordTok{have}\NormalTok{ h6 : 2 * ((↑n + 1) : ℝ) / (↑n + 1) = }
\NormalTok{      ((2 * n) + 2) / (n + 1) := }\KeywordTok{by}
    \KeywordTok{rw}\NormalTok{ [Distribute n]}
    \KeywordTok{done}
  \KeywordTok{have}\NormalTok{ h7 : 2 * (((↑n + 1) : ℝ) / (↑n + 1)) = }
\NormalTok{      2 * (↑n + 1) / (↑n + 1) := }\KeywordTok{by}
    \KeywordTok{rw}\NormalTok{ [← mul\_div\_assoc 2 ((n + 1) : ℝ) ((n + 1) : ℝ)]}
    \KeywordTok{done}
  \KeywordTok{rw}\NormalTok{ [h7]}
  \KeywordTok{rw}\NormalTok{ [h6]}
  \KeywordTok{rw}\NormalTok{ [div\_sub\_div\_same (2 * n : ℝ) (2 * n + 2) (n + 1)]}
  \KeywordTok{rw}\NormalTok{ [sub\_add\_cancel\textquotesingle{}]}
  \KeywordTok{rw}\NormalTok{ [abs\_div]}
  \KeywordTok{simp}
  \KeywordTok{have}\NormalTok{ h8 : |(↑n + 1 : ℝ)| = ↑n + 1 := }\KeywordTok{by}
    \KeywordTok{simp}
    \KeywordTok{apply}\NormalTok{ LT.lt.le (Nat.cast\_add\_one\_pos ↑n)}
    \KeywordTok{done}
  \KeywordTok{rw}\NormalTok{ [h8]}
  \KeywordTok{have}\NormalTok{ h9 : (2 : ℝ) / (↑n + 1) ≤ 2 / (k + 1) := }\KeywordTok{by}
    \KeywordTok{apply}\NormalTok{ div\_le\_div\_of\_le\_left}
\NormalTok{    · }\CommentTok{{-}{-}case 1}
      \KeywordTok{linarith}
      \KeywordTok{done}
\NormalTok{    · }\CommentTok{{-}{-}case 2}
      \KeywordTok{exact}\NormalTok{ Nat.cast\_add\_one\_pos k}
      \KeywordTok{done}
\NormalTok{    · }\CommentTok{{-}{-}case 3}
\NormalTok{      convert add\_le\_add\_right h2 1}
      \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{      · }\CommentTok{{-}{-}subcase 1}
        \KeywordTok{exact}\NormalTok{ fun a =\textgreater{} Nat.add\_le\_add\_right h2 1}
        \KeywordTok{done}
\NormalTok{      · }\CommentTok{{-}{-}subcase 2}
\NormalTok{        intro h14}
        \KeywordTok{apply}\NormalTok{ add\_le\_add\_right}
        \KeywordTok{exact}\NormalTok{ Iff.mpr Nat.cast\_le h2}
        \KeywordTok{done}
      \KeywordTok{done}
    \KeywordTok{done}
  \KeywordTok{have}\NormalTok{ h10 : 2 / (k + 1) \textless{} 2 / (2 / ε {-} 1 + 1) := }\KeywordTok{by}
    \KeywordTok{apply}\NormalTok{ div\_lt\_div\_of\_lt\_left}
\NormalTok{    · }\CommentTok{{-}{-}case 1}
      \KeywordTok{linarith}
      \KeywordTok{done}
\NormalTok{    · }\CommentTok{{-}{-}case 2}
      \KeywordTok{simp}
      \KeywordTok{apply}\NormalTok{ div\_pos}
      \KeywordTok{linarith}
      \KeywordTok{apply}\NormalTok{ h1}
      \KeywordTok{done}
\NormalTok{    · }\CommentTok{{-}{-}case 3}
\NormalTok{      convert add\_le\_add\_right h2 1}
      \KeywordTok{apply}\NormalTok{ Iff.intro}
\NormalTok{      · }\CommentTok{{-}{-}subcase 1}
\NormalTok{        intro h11}
        \KeywordTok{exact}\NormalTok{ Nat.add\_le\_add\_right h2 1}
        \KeywordTok{done}
\NormalTok{      · }\CommentTok{{-}{-}subcase 2}
\NormalTok{        intro h11}
        \KeywordTok{have}\NormalTok{ h12 : 2 / ε {-} 1 \textless{} (k : ℝ) := }\KeywordTok{by}
          \KeywordTok{simp}\NormalTok{ only []}
          \KeywordTok{apply}\NormalTok{ h13}
          \KeywordTok{done}
        \KeywordTok{exact}\NormalTok{ add\_lt\_add\_right h12 1}
        \KeywordTok{done}
      \KeywordTok{done}
    \KeywordTok{done}
  \KeywordTok{calc}
\NormalTok{    2 / (↑n + 1) ≤ (2 : ℝ) / (k + 1) := }\KeywordTok{by}
      \KeywordTok{apply}\NormalTok{ h9}
      \KeywordTok{done}
\NormalTok{    \_ \textless{} (2 : ℝ) / (2 / ε {-} 1 + 1) := }\KeywordTok{by}
      \KeywordTok{apply}\NormalTok{ h10}
      \KeywordTok{done}
\NormalTok{    \_ = ε := }\KeywordTok{by}
\NormalTok{      ring\_nf}
      \KeywordTok{apply}\NormalTok{ inv\_inv}
      \KeywordTok{done}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

\bookmarksetup{startatroot}

\hypertarget{conclusions}{%
\chapter{Conclusions}\label{conclusions}}

\hypertarget{the-good}{%
\section{The Good}\label{the-good}}

It is easy to see the potential which Lean has to aid in proof
verification, and it only seems to be gaining more popularity. The
language is continuously being expanded and made more powerful which
should only help make it accessible to more people. The language already
has some features that could be very helpful to new users, such as the
\texttt{apply?} tactic. This tactic looks at the current goal and all
hypotheses and suggests tactics and theorems which could be applied to
get closer to the goal. While this is certainly not perfect, it is very
helpful and I used it quite a few times during my time with the
language. This tactic is most useful for people who are new to the
language and are not sure how to apply the theorems that they need or
what the theorems may be called in Lean. This tactic worked best for me
when completing simple steps that only required one more theorem already
in Lean's library to reach my current goal.

Lean is like the kitchen we are cooking our proofs in and its libraries
full of theorems are like cupboards and pantries containing all of the
tools with which we are cooking. It would be impossible for us to have
read through the entire library and as such we can occasionally rely on
the \texttt{apply?} tactic for some assistance when necessary. Picture a
situation in which we already have boiled potatoes and we are attempting
to make mashed potatoes, but we are unsure of which tool we could use to
do this or in which cupboard it would be located. In this scenario, we
could consult the \texttt{apply?} tactic as if we were asking, ``What
can I use to mash these potatoes up?'' to which Lean may reply, ``I
would use the masher, found on the top shelf of that pantry over
there.'' This tactic is not perfect and cannot make every connection,
but if we are already quite close to a connection, \texttt{apply?} can
typically get us the rest of the way there.

Another helpful tactic is the \texttt{sorry} tactic. This is mainly
helpful for those trying to initially prove theorems in Lean rather than
just convert previous proofs into Lean. Applying \texttt{sorry} to a
goal automatically proves that goal within the context of the problem,
allowing the user to continue on with the proof and return to that
sub-proof later. Since using this tactic does not actually prove a
theorem, Lean will underline the main theorem and not allow it to be
used in any other proofs. While this line of thinking could also be done
with pen and paper, the ability to see if one approach would even be
fruitful before taking the time to justify everything is convenient and
could help with the process of creating proofs.

\hypertarget{sorry-example}{%
\subsubsection{\texorpdfstring{\texttt{sorry}
Example}{sorry Example}}\label{sorry-example}}

This is an example of sorry being used in a \texttt{by\_cases} proof.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{example}\NormalTok{ (a b c d : ℝ) (h1: a \textless{} b) }
\NormalTok{    (h2 : c ≤ d) : a + c \textless{} b + d := }\KeywordTok{by}
  \KeywordTok{by\_cases}\NormalTok{ h3 : c = d}
\NormalTok{  · }\CommentTok{{-}{-}Case 1 }
    \ConstantTok{sorry}
\NormalTok{  · }\CommentTok{{-}{-}Case 2}
    \KeywordTok{push\_neg} \KeywordTok{at}\NormalTok{ h3}
    \KeywordTok{have}\NormalTok{ h4 : c \textless{} d := }\KeywordTok{by}
      \KeywordTok{apply}\NormalTok{ Ne.lt\_of\_le h3 h2}
    \KeywordTok{exact} \KeywordTok{calc}
\NormalTok{      a + c \textless{} b + c := add\_lt\_add\_right h1 c}
\NormalTok{      \_ \textless{} b + d := add\_lt\_add\_left h4 b}
  \KeywordTok{done}
\end{Highlighting}
\end{Shaded}

In this example, I may think that the first case where \(c = d\) is
simple and decide that I would rather focus my efforts on the second
case first. Using \texttt{sorry} here allows me to only focus on the
second case of the proof and still see if my justification for it would
be valid. This tactic is not really about modifying the proof to make it
easier to solve, but rather about a way of organizing our proof. This
tactic also does not fit well into our cooking metaphor, because there
is no way to skip over some steps and still get a finished product. This
tactic may be more akin to a magical elf which would automatically make
the sauce for our pasta with the stipulation that we can't actually eat
any of it and we have to leave a note saying that the elf helped us.

Lean clearly laying out all known hypotheses and the current goal which
would finish the proof could aid some users in figuring out how to prove
theorems or problems they might have struggled with otherwise. This was
one of the biggest benefits of the language when I was working with it,
because it is often difficult to keep track of exactly what I know to be
true. Being able to automatically simplify hypotheses and take things
back to their definitions can greatly help figure out how each
hypothesis could be applied.

Even without these tactics which make the language more user friendly,
Lean still absolutely accomplishes its goal of automated proof
verification. The language is somewhat difficult to get the hang of even
with newly empowered tactics and theorems, but the users who have a deep
understanding of the language are truly able to harness its full
potential and easily work with difficult concepts in a way that is at
times more concise than writing it out on paper. If a proof is being
verified by another human, it may be necessary to go into great detail
so that they are able to understand each step being taken. With Lean,
however, once one knows how to work within Lean's realm of understanding
they should be able to prove anything and not need to go into great
detail. This difference in explanation would only grow larger when
venturing into higher level mathematics and newly developing topics.

Lean's intent on proof verification also raises the question of how
necessary automated proof verification truly is. No doubt is it useful
to have a proof checked by a machine for you, but if this were to be
used to develop new theorems, they would still need to eventually be
written in a way on paper that other human mathematicians can easily
understand and use. Automation in mathematics is nice, but ultimately
the human mathematicians are the ones making new developments and as
such should be prioritized when writing proofs. Lean could, however,
help with the writing of human readable proofs so long as the writer
fully understands what the Lean code is doing. Lean can ensure that no
logical jumps are being taken and if something is broken down into steps
that Lean can understand, someone could translate them into human
readable steps that would be totally coherent and logical.

\hypertarget{the-bad}{%
\section{The Bad}\label{the-bad}}

The biggest downside to using Lean is getting used to the programming
language itself and trying to put mathematical steps into terms which
Lean is able to understand. If someone has not spent much time working
with programming languages it would certainly be difficult and time
consuming to learn something entirely new, but even for those who have
had experience programming the switch into Lean could still prove
difficult. While there are methods within Lean which could aid new users
such as the aforementioned \texttt{apply?} tactic, it is still necessary
to know how to manipulate hypotheses into a form that Lean is able to
work with, which may not always be as easy as it would be on paper.

Another downside to Lean is the lack of options and potentially the
inability to immediately keep up with mathematics in the future.
Development takes time, and in order to do proofs in Lean more theorems
and definitions need to be added and worked out. As new areas of
mathematics are expanded, it will be necessary to do upkeep on the
language and add in new features or even make large overhauls to the
language depending on the significance of the work being done. As I
mentioned earlier, Lean completely abandons some methods of proof in
favor of more currently concise methods. This works fine for now, but if
there was a newly developing area of mathematics which functioned better
under a previously abandoned method, Lean may need to be reworked and
theorems may need to be rewritten to fit better into the new system.

Lean also abandons some parts of mathematics that are not neccesarily
applicable outside of exercises. While working on a problem in Lean I
reached out on the Zulip forum for help and one person who contributes
to the programming of Lean responded that what I was looking for wasn't
included in Lean's library because it was really only useful for
exercises. Cutting things like this may be necessary to save time
programming the language, but it is a shame that everything cannot be
included. Some simpler aspects of mathematics are important steps in
developing ones understanding of higher level topics and to expect
anyone coming into Lean to already know high level mathematics seems
nearsighted. If Lean is to become more widely accepted, those learning
mathematics need to be able to learn and use it as they grow in
mathematical ability. This could help lead to mathematicians who are
able to take full advantage of the language and even potentially
contribute to development of the language.

\hypertarget{the-future}{%
\section{The Future}\label{the-future}}

With Lean constantly expanding and growing more powerful, it could
become easy enough to use that it becomes widely used. The scene of
users is quite active right now, and its libraries are constantly being
updated. Lean has even gained enough popularity that a few textbooks
have been written about proving mathematical theorems using Lean. These
vary in level of difficulty and some add their own libraries of theorems
and definitions which are not included in the base installation of Lean.
The \emph{How To Prove It With Lean} textbook as well as
\emph{Mathematics in Lean} were both quite instrumental in learning the
language and gaining a full grasp of Lean's capabilities. \emph{How To
Prove It With Lean} makes some substantial changes to the base language
which I believe makes it easier to use than the base language. Due to
the added tactics and simpler syntax rules in this book, I would
certainly recommend any new users start with this book. Once the basics
have been understood, \emph{Mathematics in Lean} goes back to the base
language and takes the language into higher level mathematics such as
topology and calculus. These books do a great job of teaching the
language and some of the math at the same time, making it possible for
those starting to learn mathematical proofs to start in Lean and learn
to take full advantage of it. If Lean continues to be supported and
expanded we could certainly see a greater acceptance and implementation
into mainstream mathematics.

\bookmarksetup{startatroot}

\hypertarget{works-cited}{%
\chapter*{Works Cited}\label{works-cited}}
\addcontentsline{toc}{chapter}{Works Cited}

\markboth{Works Cited}{Works Cited}

This work had been formatted and styled from the book \emph{How To Prove
It With Lean}, written by Daniel J. Velleman. \emph{How To Prove It With
Lean} contains short excerpts from \emph{How To Prove It: A Structured
Approach, 3rd Edition}, by Daniel J. Velleman and published by Cambridge
University Press.

\hfill\break

\hypertarget{refs}{}
\begin{CSLReferences}{1}{0}
\leavevmode\vadjust pre{\hypertarget{ref-Avigad_Massot}{}}%
Avigad, Jeremy, and Patrick Massot. 2020. {``Mathematics in Lean.''}
\emph{Mathematics in Lean - Mathematics in Lean 0.1 Documentation}.
\url{https://leanprover-community.github.io/mathematics_in_lean/index.html\#}.

\leavevmode\vadjust pre{\hypertarget{ref-Avigad_de_Moura_Kong_Ullrich}{}}%
Avigad, Jeremy, Leonardo de Moura, Soonho Kong, and Sebastian Ullrich.
2021. {``Theorem Proving in Lean 4.''} \emph{Theorem Proving in Lean 4 -
Theorem Proving in Lean 4}.
\url{https://lean-lang.org/theorem_proving_in_lean4/title_page.html}.

\leavevmode\vadjust pre{\hypertarget{ref-Christiansen}{}}%
Christiansen, David Thrane. 2023. {``Functional Programming in Lean.''}
\emph{Functional Programming in Lean - Functional Programming in Lean}.
\url{https://lean-lang.org/functional_programming_in_lean/title.html}.

\leavevmode\vadjust pre{\hypertarget{ref-Velleman}{}}%
Velleman, Daniel J. 2023. \emph{How To Prove It With Lean}.
\url{https://djvelleman.github.io/HTPIwL/}.

\end{CSLReferences}



\end{document}
