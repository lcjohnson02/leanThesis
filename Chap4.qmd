# Conclusions


## The Good

It is easy to see the potential which Lean has to aid in proof verification, and it only seems to be gaining more popularity. The language is continuously being expanded and made more powerful which should only help make it accessible to more people. The language already has some features that could be very helpful to new users, such as the `apply?` tactic. This tactic looks at the current goal and all hypotheses and suggests tactics and theorems which could be applied to get closer to the goal. While this is certainly not perfect, it is very helpful and I used it quite a few times during my time with the language. This tactic is most useful for people who are new to the language and are not sure how to apply the theorems that they need or what the theorems may be called in Lean. This tactic worked best for me when completing simple steps that only required one more theorem already in Lean's library to reach my current goal. 

Lean is like the kitchen we are cooking our proofs in and its libraries full of theorems are like cupboards and pantries containing all of the tools with which we are cooking. It would be impossible for us to have read through the entire library and as such we can occasionally rely on the `apply?` tactic for some assistance when necessary. Picture a situation in which we already have boiled potatoes and we are attempting to make mashed potatoes, but we are unsure of which tool we could use to do this or in which cupboard it would be located. In this scenario, we could consult the `apply?` tactic as if we were asking, "What can I use to mash these potatoes up?" to which Lean may reply, "I would use the masher, found on the top shelf of that pantry over there." This tactic is not perfect and cannot make every connection, but if we are already quite close to a connection, `apply?` can typically get us the rest of the way there.

Another helpful tactic is the `sorry` tactic. This is mainly helpful for those trying to initially prove theorems in Lean rather than just convert previous proofs into Lean. Applying `sorry` to a goal automatically proves that goal within the context of the problem, allowing the user to continue on with the proof and return to that sub-proof later. Since using this tactic does not actually prove a theorem, Lean will underline the main theorem and not allow it to be used in any other proofs. While this line of thinking could also be done with pen and paper, the ability to see if one approach would even be fruitful before taking the time to justify everything is convenient and could help with the process of creating proofs. 

#### `sorry` Example

This is an example of sorry being used in a `by_cases` proof.

```lean
example (a b c d : ℝ) (h1: a < b) 
    (h2 : c ≤ d) : a + c < b + d := by
  by_cases h3 : c = d
  · --Case 1 
    sorry
  · --Case 2
    push_neg at h3
    have h4 : c < d := by
      apply Ne.lt_of_le h3 h2
    exact calc
      a + c < b + c := add_lt_add_right h1 c
      _ < b + d := add_lt_add_left h4 b
  done
```

In this example, I may think that the first case where $c = d$ is simple and decide that I would rather focus my efforts on the second case first. Using `sorry` here allows me to only focus on the second case of the proof and still see if my justification for it would be valid. This tactic is not really about modifying the proof to make it easier to solve, but rather about a way of organizing our proof. This tactic also does not fit well into our cooking metaphor, because there is no way to skip over some steps and still get a finished product. This tactic may be more akin to a magical elf which would automatically make the sauce for our pasta with the stipulation that we can't actually eat any of it and we have to leave a note saying that the elf helped us.

Lean clearly laying out all known hypotheses and the current goal which would finish the proof could aid some users in figuring out how to prove theorems or problems they might have struggled with otherwise. This was one of the biggest benefits of the language when I was working with it, because it is often difficult to keep track of exactly what I know to be true. Being able to automatically simplify hypotheses and take things back to their definitions can greatly help figure out how each hypothesis could be applied.

Even without these tactics which make the language more user friendly, Lean still absolutely accomplishes its goal of automated proof verification. The language is somewhat difficult to get the hang of even with newly empowered tactics and theorems, but the users who have a deep understanding of the language are truly able to harness its full potential and easily work with difficult concepts in a way that is at times more concise than writing it out on paper. If a proof is being verified by another human, it may be necessary to go into great detail so that they are able to understand each step being taken. With Lean, however, once one knows how to work within Lean's realm of understanding they should be able to prove anything and not need to go into great detail. This difference in explanation would only grow larger when venturing into higher level mathematics and newly developing topics. 

Lean's intent on proof verification also raises the question of how necessary automated proof verification truly is. No doubt is it useful to have a proof checked by a machine for you, but if this were to be used to develop new theorems, they would still need to eventually be written in a way on paper that other human mathematicians can easily understand and use. Automation in mathematics is nice, but ultimately the human mathematicians are the ones making new developments and as such should be prioritized when writing proofs. Lean could, however, help with the writing of human readable proofs so long as the writer fully understands what the Lean code is doing. Lean can ensure that no logical jumps are being taken and if something is broken down into steps that Lean can understand, someone could translate them into human readable steps that would be totally coherent and logical.


## The Bad

The biggest downside to using Lean is getting used to the programming language itself and trying to put mathematical steps into terms which Lean is able to understand. If someone has not spent much time working with programming languages it would certainly be difficult and time consuming to learn something entirely new, but even for those who have had experience programming the switch into Lean could still prove difficult. While there are methods within Lean which could aid new users such as the aforementioned `apply?` tactic, it is still necessary to know how to manipulate hypotheses into a form that Lean is able to work with, which may not always be as easy as it would be on paper. 

Another downside to Lean is the lack of options and potentially the inability to immediately keep up with mathematics in the future. Development takes time, and in order to do proofs in Lean more theorems and definitions need to be added and worked out. As new areas of mathematics are expanded, it will be necessary to do upkeep on the language and add in new features or even make large overhauls to the language depending on the significance of the work being done. As I mentioned earlier, Lean completely abandons some methods of proof in favor of more currently concise methods. This works fine for now, but if there was a newly developing area of mathematics which functioned better under a previously abandoned method, Lean may need to be reworked and theorems may need to be rewritten to fit better into the new system. 

Lean also abandons some parts of mathematics that are not neccesarily applicable outside of exercises. While working on a problem in Lean I reached out on the Zulip forum for help and one person who contributes to the programming of Lean responded that what I was looking for wasn't included in Lean's library because it was really only useful for exercises. Cutting things like this may be necessary to save time programming the language, but it is a shame that everything cannot be included. Some simpler aspects of mathematics are important steps in developing ones understanding of higher level topics and to expect anyone coming into Lean to already know high level mathematics seems nearsighted. If Lean is to become more widely accepted, those learning mathematics need to be able to learn and use it as they grow in mathematical ability. This could help lead to mathematicians who are able to take full advantage of the language and even potentially contribute to development of the language.

## The Future

With Lean constantly expanding and growing more powerful, it could become easy enough to use that it becomes widely used. The scene of users is quite active right now, and its libraries are constantly being updated. Lean has even gained enough popularity that a few textbooks have been written about proving mathematical theorems using Lean. These vary in level of difficulty and some add their own libraries of theorems and definitions which are not included in the base installation of Lean. The *How To Prove It With Lean* textbook as well as *Mathematics in Lean* were both quite instrumental in learning the language and gaining a full grasp of Lean's capabilities. *How To Prove It With Lean* makes some substantial changes to the base language which I believe makes it easier to use than the base language. Due to the added tactics and simpler syntax rules in this book, I would certainly recommend any new users start with this book. Once the basics have been understood, *Mathematics in Lean* goes back to the base language and takes the language into higher level mathematics such as topology and calculus. These books do a great job of teaching the language and some of the math at the same time, making it possible for those starting to learn mathematical proofs to start in Lean and learn to take full advantage of it. If Lean continues to be supported and expanded we could certainly see a greater acceptance and implementation into mainstream mathematics.